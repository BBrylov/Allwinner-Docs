* Обсуждение вопросов и отзывов https://github.com/100askTeam/Stage1_D1s-Applications/discussions/
# 1. Краткое описание Makefile

## 1.1 Зачем нужен Makefile
В современных проектах количество исходных файлов исчисляется десятками и сотнями. Они организованы по типу, функциям и модулям в различные директории. Если продолжать вводить команды компиляции вручную в терминале, это становится непрактичным и крайне неэффективным с точки зрения разработки.
Нам нужен инструмент для управления процессом компиляции - это "make". Make - это приложение, которое работает согласно Makefile. Makefile отвечает за управление всем процессом компиляции: какие файлы компилировать, как их компилировать, как связать их в исполняемую программу. Makefile определяет набор правил для реализации этого управления.

## 1.2 Введение в makefile
Makefile был создан для упрощения процесса компиляции и повышения скорости разработки. Ниже мы используем пример, чтобы показать, как Makefile упрощает процесс компиляции. Создадим проект, состоящий из пяти файлов: main.c, sub.c, sub.h, add.c, add.h. Файл sub.c выполняет вычитание двух чисел, add.c выполняет сложение двух чисел, затем компилируем исполняемый файл. Содержимое исходных файлов следующее:

```c
main.c:

#include <stdio.h>
#include "add.h"
#include "sub.h"
int main()
{
	printf("100 ask, add:%d\n", add(10, 10));
	printf("100 ask, sub:%d\n", sub(20, 10));
	return 0;
}
```

```c
add.c:
#include "add.h"
int add(int a, int b)
{
	return a + b;
}
```

```c
add.h:
#ifndef __ADD_H
#define __ADD_H
int add(int a, int b);
#endif
```

```c
sub.c:
#include "sub.h"
int sub(int a, int b)
{
return a - b;
}
```

```c
sub.h:
#ifndef __SUB_H
#define __SUB_H
int sub(int a, int b);
#endif
```

Компилируем вышеуказанный проект с помощью gcc и генерируем исполняемую программу, вводя следующую команду в терминале:

```bash
$ gcc main.c sub.c add.c -o ouput
$ ls
add.c add.h main.c output sub.c sub.h
$ ./output
100 ask, add:20
100 ask, sub:10
```

Приведенная выше команда использует компилятор gcc для компиляции трех файлов main.c, sub.c, add.c и генерирует исполняемую программу output, которая затем выполняется и производит результат.
Приведенный выше пример кажется довольно простым - одна команда компилирует три исходных файла и производит результат. Это связано с тем, что в настоящее время имеется всего три исходных файла.

Если у вас тысячи исходных файлов, даже если вы изменили только один файл, при выполнении такой команды будут перекомпилированы все исходные файлы. Это займет огромное количество времени.
Мы хотим реализовать следующее: какой файл был изменен, компилировать только этот измененный файл, другие неизмененные файлы не нужно перекомпилировать. Можно использовать следующие команды - сначала компилировать файлы по отдельности, затем связать их:

```bash
$ gcc -c main.c
$ gcc -c sub.c
$ gcc -c add.c
$ gcc main.o sub.o add.o -o output
```

Мы превратили одну команду в четыре, отдельно компилируя объектные файлы из исходных файлов, а затем связывая все объектные файлы в исполняемый файл.
Когда содержимое одного из исходных файлов изменяется, нам нужно только отдельно скомпилировать его, а затем пересвязать его с другими файлами в исполняемый файл, не нужно перекомпилировать другие файлы.
Предположим, мы изменили файл add.c, нужно только перекомпилировать объектный файл add.c, затем связать все .o файлы в исполняемый файл:

```bash
$ gcc -c add.c
$ gcc main.o sub.o add.o -o output
```

Такой подход действительно экономит время, но все еще существует несколько проблем:

* 1. Если исходных файлов очень много, то нам придется потратить значительное время на ввод команд.
* 2. Если исходных файлов очень много, и вы изменили много файлов, позже можете забыть, что именно изменили.
* 3. Если изменено содержимое заголовочного файла, заменен или перемещен в другую директорию, все исходные файлы, зависящие от этого заголовочного файла, нужно перекомпилировать.
Мы не можем искать и проверять эти проблемы одну за другой, введение Makefile может решить вышеупомянутые проблемы. Сначала покажем Makefile:



```makefile
Makefile:
output: main.o add.o sub.o
	gcc -o output main.o add.o sub.o
main.o: main.c
	gcc -c main.c
add.o: add.c
	gcc -c add.c
sub.o: sub.c
	gcc -c sub.c
clean:
	rm *.o output
```

После написания Makefile нужно только выполнить команду make, и она автоматически скомпилирует наш проект. Обратите внимание, что команда make должна выполняться в текущей директории, где находится Makefile:

```bash
$ ls
add.c add.h main.c Makefile sub.c sub.h
$ make
gcc -c main.c
gcc -c add.c
gcc -c sub.c
gcc -o output main.o add.o sub.o
$ ls
add.c add.h add.o main.c main.o Makefile output sub.c sub.h sub.o
```

С помощью команды make генерируются соответствующие объектные файлы .o и исполняемый файл.
Если мы снова используем команду make для компиляции, как показано ниже, она сообщит, что ваша программа уже актуальна и не требует никаких действий:

```bash
$ make
make: 'output' is up to date.
```

Мы можем изменить add.c, а затем снова выполнить make:

```bash
$ make
gcc -c add.c
gcc -o output main.o add.o sub.o
```

Вы увидите, что он перекомпилировал add.c и пересоздал исполняемую программу.
Из вышеприведенного примера видно, что Makefile решил все три наши проблемы - не нужно вручную вводить сложные команды, компилируются только измененные файлы. В очень большом проекте только первая компиляция занимает много времени, вторая компиляция значительно сокращает время, экономя наш цикл разработки.
Теперь давайте изучим основы Makefile.

