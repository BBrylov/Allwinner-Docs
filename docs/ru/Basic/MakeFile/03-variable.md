# 3. Переменные
## 3.1 Определение и использование переменных
Makefile также поддерживает определение переменных, переменные делают наш Makefile более простым и переиспользуемым.
Определение переменной: обычно используются заглавные буквы, присвоение значения похоже на присвоение в языке C:

```bash
DIR = ./100ask/
```

Получение значения переменной: используются круглые скобки для заключения переменной с символом доллара:

```bash
FOO = $(DIR)
```

Переменные позволяют упростить и переиспользовать Makefile, рассмотрим предыдущий файл Makefile:

```makefile
output: main.o add.o sub.o
	gcc -o output main.o add.o sub.o
main.o: main.c
	gcc -c main.c
add.o: add.c
	gcc -c add.c
sub.o: sub.c
	gcc -c sub.c
clean:
	rm *.o output
```

Мы можем оптимизировать его:

```makefile
#Определение переменных в Makefile
OBJ = main.o add.o sub.o
output: $(OBJ)
	gcc -o output $(OBJ)
main.o: main.c
	gcc -c main.c
add.o: add.c
	gcc -c add.c
sub.o: sub.c
	gcc -c sub.c
clean:
	rm $(OBJ) output
```

Проанализируем упрощенный Makefile: первая строка - это комментарий, комментарии в Makefile используют '#', и не поддерживается многострочный комментарий как в C. Во второй строке мы определили переменную OBJ и присвоили ей строку "main.o, add.o, sub.o". В строках 3, 4 и 13 используется эта переменная. Таким образом, везде где используется одна и та же строка, можно просто вызывать эту переменную, не повторяя длинную строку.
Помимо использования '=' для присвоения, в Makefile есть другие способы присвоения, такие как ':=' и '?=', рассмотрим различия между ними:

Оператор присвоения '='
Используем пример для объяснения использования оператора присвоения '='. Содержимое Makefile:

```makefile
PARA = 100
CURPARA = $(PARA)
PARA = ask

print:
	@echo $(CURPARA)
```

Анализ кода: первая строка определяет переменную PARA и присваивает значение "100", вторая строка определяет переменную CURPARA и присваивает ссылку на переменную PARA, в этот момент значение CURPARA такое же, как значение PARA, третья строка изменяет значение переменной PARA на "ask". Шестая строка выводит значение CURPARA, символ @ перед echo означает, что показывается только результат команды, а не сама команда.
Выполняем Makefile командой "make print":

```bash
$ make print
ask
```

Из результата видно, что значение переменной CURPARA не "100", а последнее присвоенное значение PARA. При использовании оператора присвоения "=" значение переменной определяется во время выполнения, это называется "отложенная переменная".
По сути это можно понять как в языке C - определение указательной переменной, указывающей на адрес переменной:

```c
01 int a = 10;
02 int *b = &a;
03 a=20;
```

Анализ кода: заменим "=" на ":=" во второй строке вышеприведенного Makefile, перекомпилируем:

```bash
$ make print
100
```

Из результата видно, что значение переменной CURPARA равно "100". Переменные, установленные с помощью ":=", называются "немедленными переменными", их значение определяется в момент присвоения.

Оператор присвоения '?='

Используем два Makefile для объяснения использования оператора присвоения "?=":

```makefile
Первый Makefile:
PARA = 100
PARA ?= ask
print:
	@echo $(PARA)
```

Результат компиляции:

```bash
$ make print
100
```

```makefile
Второй Makefile:
PARA ?= ask
print:
	@echo $(PARA)
```

Результат компиляции:

```bash
$ make print
ask
```

Приведенный выше пример показывает, что при использовании "?=" для установки значения переменной, если эта переменная не была установлена ранее, то "?=" сработает; если переменная была установлена ранее, то "?=" не будет действовать. Оператор присвоения '+='
Переменные в Makefile являются строками, иногда нам нужно добавить некоторые строки к ранее определенной переменной, в этом случае используется символ "+=", например:

```makefile
OBJ = main.o add.o
OBJ += sub.o
```

Результат - значение OBJ становится: "main.o, add.o, sub.o". Это показывает, что "+=" используется для добавления к переменной.

## 3.2 Системные встроенные переменные

Система предопределяет некоторые переменные, обычно они пишутся заглавными буквами, например CC, PWD, CLFAG и т.д., некоторые имеют значения по умолчанию, некоторые нет, например следующие:
* CPPFLAGS: опции, необходимые для препроцессора, например: -l
* CFLAGS: параметры, используемые при компиляции, -Wall -g -c
* LDFLAGS: опции, используемые при связывании библиотек, -L -l
При этом: значения по умолчанию можно изменить, например CC по умолчанию равен cc, но можно изменить на gcc: CC=gcc
Пример использования:

```
OBJ = main.o add.o sub.o
output: $(OBJ)
	gcc -o output $(OBJ)
main.o: main.c
	gcc -c main.c
add.o: add.c
	gcc -c add.c
sub.o: sub.c
	gcc -c sub.c

clean:
	rm $(OBJ) output
```

Использование системных встроенных переменных:

```
CC = gcc
OBJ = main.o add.o sub.o
output: $(OBJ)
	$(CC) -o output $(OBJ)
main.o: main.c
	$(CC) -c main.c
add.o: add.c
	$(CC) -c add.c
sub.o: sub.c
	$(CC) -c sub.c

clean:
	rm $(OBJ) output
```

В приведенном выше примере, если не изменять значение по умолчанию системной переменной CC, компиляция все равно будет работать, изменение сделано для явного указания использования gcc для компиляции.

## 3.3 Автоматические переменные
Синтаксис Makefile предоставляет некоторые автоматические переменные, эти переменные позволяют нам быстрее написать Makefile, при этом автоматические переменные могут использоваться только в командах правил, часто используемые автоматические переменные:
* $@: цель в правиле
* $<: первый файл зависимости в правиле
* $^: все файлы зависимостей в правиле
Продолжим совершенствовать наш пример, изменив его для использования автоматических переменных:

```makefile
CC = gcc
OBJ = main.o add.o sub.o
output: $(OBJ)
	$(CC) -o $@ $^
main.o: main.c
	$(CC) -c $<
add.o: add.c
	$(CC) -c $<
sub.o: sub.c
	$(CC) -c $<

clean:
	rm $(OBJ) output
```

При этом: в строке 4 $^ представляет значение переменной OBJ, т.е. main.o add.o sub.o, в строках 4, 6 и 8 $< представляют соответственно main.c add.c sub.c. $@ представляет output.
