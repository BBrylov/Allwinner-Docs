# 2. Правила makefile
## 2.1 Правила именования
Обычно файл Makefile называют "Makefile" или "makefile", по традиции используется "Makefile" с заглавной буквы. Также можно использовать другие имена, например makefile.linux, но тогда нужно указать это с помощью параметра "-f", пример:

```bash
make -f makefile.linux
```

## 2.2 Синтаксические правила
Основные синтаксические правила:

![image](https://github.com/1WMD1/script_file/blob/master/makefile/png/image-20230310110255519.png)

* target: целевой файл, который нужно сгенерировать
* prerequisites: файлы, от которых зависит генерация этой цели
* command: команда, которую нужно выполнить для генерации этой цели



Взаимосвязь трех элементов: target зависит от файлов в prerequisites, а правило его генерации определено в command. Например, обычно для компиляции файла используется:

```bash
$ gcc main.c -o main
```

В формате записи Makefile это выглядит так:

```makefile
main:main.c
	gcc main.c -o main
```

Строка 1 означает, что исполняемая программа main зависит от main.c, строка 2 означает, что для генерации main нужно использовать команду "gcc main.c -o main".
Обратите внимание: команды в файле Makefile должны начинаться с Tab, нельзя использовать пробелы.

## 2.3 Правила генерации цели

* Генерация цели:

> Проверить, существуют ли файлы зависимостей в правиле.

> Если файл зависимости не существует, найти правило для генерации этого файла зависимости.

Процесс генерации цели:

![image](https://github.com/1WMD1/script_file/blob/master/makefile/png/image-20230310111353906.png)

* Обновление цели:

> Проверить все зависимости цели, если любая зависимость обновлена, нужно пересоздать цель.
> Если целевой файл новее файлов зависимостей по времени обновления, требуется обновление.

Процесс обновления цели:

![image](https://github.com/1WMD1/script_file/blob/master/makefile/png/image-20230310111817321.png)

Используем приведенный выше пример, содержимое Makefile:

```makefile
output: main.o add.o sub.o
	gcc -o output main.o add.o sub.o
main.o: main.c
	gcc -c main.c
add.o: add.c
	gcc -c add.c
sub.o: sub.c
	gcc -c sub.c
clean:
	rm *.o output
```

Компиляция и выполнение:

```bash
$ make
gcc -c main.c
gcc -c add.c
gcc -c sub.c
gcc -o output main.o add.o sub.o
```

Команда make проверяет, существуют ли зависимости цели, если нет, ищет команду для генерации зависимостей.
1. output зависит от "main.o add.o sub.o", этих трех файлов нет, генерируем их по отдельности. Как генерировать? Продолжаем искать правила, обнаруживаем, что main.o зависит от main.c, поэтому используем "gcc -c main.c" для генерации; два других файла обрабатываются аналогично.

2. Теперь все файлы зависимостей для output есть, но самого файла output еще нет, поэтому используем "gcc -o output main.o add.o sub.o" для генерации файла output. Когда мы изменяем какой-либо файл, например только файл add.c, затем снова выполняем make:

```bash
$ make
gcc -c add.c
gcc -o output main.o add.o sub.o
```

Команда make снова проверяет и выполняет согласно Makefile:
1. output зависит от "main.o add.o sub.o", эти три файла есть, main.o зависит от main.c, main.c не изменился, поэтому не нужно пересоздавать main.o;
Но файл зависимости add.c для add.o был изменен, нужно пересоздать add.o, используя команду "gcc -c add.c"; sub.o аналогично main.o, также не требует повторной генерации.
2. Теперь output и все три его файла зависимостей существуют, но один из файлов зависимостей add.o новее файла output, поэтому используем "gcc -o output main.o add.o sub.o" для генерации файла output.

