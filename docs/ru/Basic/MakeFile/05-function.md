# 5. Функции Makefile
Makefile предоставляет множество функций, формат вызова функции следующий:

```
$(function arguments)
```

Здесь 'function' - имя функции, 'arguments' - параметры этой функции. Параметры и имя функции разделяются пробелом или Tab, если есть несколько параметров, они разделяются запятыми. Эти пробелы и запятые не являются частью значений параметров.
Мы часто используем две основные функции (wildcard, patsubst), сначала рассмотрим их отдельно. Создадим папку src, в ней создадим два файла: 100.c, ask.c:

```bash
.
├── Makefile
└── src
	├── 100.c
	└── ask.c
```

## 5.1 Часто используемые функции

> **Функция wildcard**

Используется для поиска файлов указанного типа в указанной директории, параметры функции: директория + тип файла:

```makefile
$(wildcard тип файла)
```

При этом, если не указан путь, то поиск выполняется по умолчанию в текущей директории, пример:

```makefile
01 SRC = $(wildcard ./src/*.c)
02
03 print:
04 	@echo $(SRC)
```

Выполнение команды make, результат:

```bash
$ make
./src/ask.c ./src/100.c
```

При этом, это правило означает: найти все файлы с расширением .c в директории ./src и присвоить их переменной SRC. После выполнения команды значение переменной SRC: ./src/ask.c ./src/100.c





> **Функция patsubst**

Используется для сопоставления и замены. Параметры функции: исходный шаблон + целевой шаблон + список файлов:

```makefile
$( patsubst исходный_шаблон, целевой_шаблон, список_файлов)
```

При этом, из списка файлов ищутся файлы, соответствующие типу исходного шаблона, затем они заменяются на целевой шаблон один за одним. Пример: заменим файлы с расширением .c в директории ./src на файлы с расширением .o и присвоим результат переменной obj:

```makefile
SRC = $(wildcard ./src/*.c)
OBJ = $(patsubst %.c, %.o, $(SRC))
print:
	@echo $(OBJ)
```

Выполнение команды make, результат:

```
$ make
./src/ask.o ./src/100.o
```

При этом, это правило означает: заменить все файлы с расширением .c в переменной на файлы с расширением .o. После выполнения команды значение переменной OBJ: ./src/ask.o ./src/100.o



## 5.2 Функции замены и анализа строк

> **$(subst from,to,text)**

В тексте 'text' заменяет каждое вхождение 'from' на 'to'. Например:

```makefile
$(subst ee,EE,feet on the street)
```

Результат: 'fEEt on the strEEt'.



> **$(patsubst pattern,replacement,text)**

Ищет в 'text' слова, соответствующие формату 'pattern', и заменяет их на 'replacement'.
В 'pattern' и 'replacement' можно использовать подстановочные знаки. Например:

```makefile
$(patsubst %.c,%.o,x.c.c bar.c)
```

Результат: 'x.c.o bar.o'.

**$(strip string)**
Удаляет начальные и конечные пробелы, а также сжимает множественные пробелы в середине до одиночного пробела. Например:

```makefile
$(strip a b c )
```

Результат: 'a b c'.



> **$(findstring find,in)**

Ищет 'find' в строке 'in', если находит, то возвращается значение 'find', иначе возвращается пустое значение. Например:

```makefile
$(findstring a,a b c)
$(findstring a,b c)
```

Результаты будут 'a' и '' (пустая строка) соответственно.



> **$(filter pattern...,text)**

Возвращает из 'text' слова, разделенные пробелами и соответствующие формату 'pattern...', удаляя слова, не соответствующие формату 'pattern...'. Например:

```makefile
$(filter %.c %.s,foo.c bar.c baz.s ugh.h)
```

Результат: 'foo.c bar.c baz.s'.



> **$(filter-out pattern...,text)**

Возвращает из 'text' слова, разделенные пробелами и не соответствующие формату 'pattern...', удаляя слова, соответствующие формату 'pattern...'. Это обратная функция к filter. Например:

```makefile
$(filter %.c %.s,foo.c bar.c baz.s ugh.h)
```

Результат: 'ugh.h'.



> **$(sort list)**

Сортирует слова в 'list' по алфавиту и удаляет дубликаты. Выводит список слов, разделенных одиночным пробелом. Например:

```makefile
$(sort foo bar lose)
```

Возвращает 'bar foo lose'.


***

## 5.3 Функции для работы с именами файлов

> **$(dir names...)**

Извлекает путь каждого имени файла из 'names...', путь файла включает все символы от первого символа имени файла до последней косой черты (включая косую черту). Например:

```makefile
$(dir src/foo.c hacks)
```

Результат: 'src/ ./'.



> **$(notdir names...)**

Извлекает из 'names...' все символы каждого имени файла, кроме пути (собственно имя файла). Например:

```makefile
$(notdir src/foo.c hacks)
```

Результат: 'foo.c hacks'.



> **$(suffix names...)**

Извлекает расширение каждого имени файла из 'names...'. Например:

```makefile
$(suffix src/foo.c src-1.0/bar.c hacks)
```

Результат: '.c .c'.



> **$(basename names...)**

Извлекает все символы каждого имени файла из 'names...', кроме расширения. Например:

```makefile
$(basename src/foo.c src-1.0/bar hacks)
```

Результат: 'src/foo src-1.0/bar hacks'.



> **$(addsuffix suffix,names...)**

Параметр 'names...' - это серия имен файлов, разделенных пробелами; suffix - расширение. Добавляет значение suffix (расширение) в конец каждого отдельного имени файла, затем объединяет имена файлов, разделяя их одиночным пробелом. Например:

```makefile
$(addsuffix .c,foo bar)
```

Результат: 'foo.c bar.c'.



> **$(addprefix prefix,names...)**

Параметр 'names' - это серия имен файлов, разделенных пробелами; prefix - префикс. Добавляет значение prefix (префикс) перед каждым отдельным именем файла, затем объединяет имена файлов, разделяя их одиночным пробелом. Например:

```makefile
$(addprefix src/,foo bar)
```

Результат: 'src/foo src/bar'.



> **$(wildcard pattern)**

Параметр 'pattern' - формат имени файла, содержащий подстановочные знаки (подстановочные знаки используются так же, как в shell). Результат функции wildcard - это список реально существующих файлов, соответствующих формату, имена файлов разделены одним пробелом.
Например, если в текущей директории есть файлы 1.c, 2.c, 1.h, 2.h, то:

```makefile
c_src := $(wildcard *.c)
```

Результат: '1.c 2.c'.



## 5.4 Другие функции

> **$(foreach var,list,text)**

Первые два параметра, 'var' и 'list' сначала расширяются, обратите внимание, что последний параметр 'text' в этот момент не расширяется; затем каждое слово из расширенного 'list' присваивается переменной 'var'; затем 'text' ссылается на эту переменную и расширяется, поэтому 'text' каждый раз расширяется по-разному.
Результат функции - это новый 'list', полученный из объединения множественных расширений 'text' в 'list', разделенных пробелами, то есть: строки, полученные из множественных расширений 'text', объединены, слова разделены пробелами, таким образом получается возвращаемое значение функции foreach.
Вот простой пример, который устанавливает значение переменной 'files' как список всех файлов во всех директориях из 'dirs':

```makefile
dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
```

Здесь 'text' - это '$(wildcard $(dir)/*)', процесс его расширения следующий:

a) Первое значение, присвоенное переменной dir - 'a', результат расширения: '$(wildcard a/*)';
b) Второе значение, присвоенное переменной dir - 'b', результат расширения: '$(wildcard b/*)';
c) Третье значение, присвоенное переменной dir - 'c', результат расширения: '$(wildcard c/*)';
d) И так далее.

Этот пример дает тот же результат, что и следующий пример:

```makefile
files := $(wildcard a/* b/* c/* d/*)
```

> **$(if condition,then-part[,else-part])**

Сначала из первого параметра 'condition' удаляются начальные и конечные пробелы, затем он расширяется. Если расширение дает непустую строку, то условие 'condition' считается 'истинным'; если расширение дает пустую строку, то условие 'condition' считается 'ложным'.
Если условие 'condition' 'истинно', то вычисляется значение второго параметра 'then-part', и это значение становится значением всей функции if.
Если условие 'condition' 'ложно', и третий параметр существует, то вычисляется значение третьего параметра 'else-part', и это значение становится значением всей функции if; если третий параметр не существует, функция if ничего не вычисляет и возвращает пустое значение.
Обратите внимание: может быть вычислен только один из 'then-part' или 'else-part', не оба одновременно. Это может вызвать побочные эффекты (например, вызов функции shell).

> **$(origin variable)**

Переменная 'variable' - это имя переменной для запроса, а не ссылка на эту переменную. Поэтому нельзя использовать '$' и круглые скобки для записи этой переменной, конечно, если нужно использовать непостоянное имя файла, можно использовать ссылку на переменную в имени файла.

Результат функции origin - это строка, описывающая как была определена переменная:

* 'undefined': если переменная 'variable' никогда не была определена;
*  'default': переменная 'variable' - это определение по умолчанию;
*  'environment': переменная 'variable' определена как переменная окружения, опция '-e' не включена;
*  'environment override': переменная 'variable' определена как переменная окружения, опция '-e' включена;
*  'file': переменная 'variable' определена в Makefile;
*  'command line': переменная 'variable' определена в командной строке;
*  'override': переменная 'variable' определена в Makefile с директивой override;
*  'automatic': переменная 'variable' - это автоматическая переменная


> **$(shell command arguments)**

Функция shell - это инструмент коммуникации make с внешней средой. Результат выполнения функции shell аналогичен результату выполнения 'command arguments' в консоли. Однако если результат 'command arguments' содержит символы новой строки (и возврата каретки), то в результате функции shell они обрабатываются как одиночные пробелы, если результат заканчивается символом новой строки (и возврата каретки), они удаляются.
Например, если в текущей директории есть файлы 1.c, 2.c, 1.h, 2.h, то:

```makefile
c_src := $(shell ls *.c)
```

Результат: '1.c 2.c'.



