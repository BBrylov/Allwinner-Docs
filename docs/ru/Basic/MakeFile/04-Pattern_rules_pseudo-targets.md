# 4. Шаблонные правила и псевдоцели
## 4.1 Шаблонные правила

Шаблонные правила используют % в цели и зависимостях для сопоставления соответствующих файлов, продолжим использовать предыдущий пример, применяя формат шаблонных правил:

```makeflie
CC = gcc
OBJ = main.o add.o sub.o
output: $(OBJ)
	$(CC) -o $@ $^
%.o: %.c
	$(CC) -c $<

clean:
	rm $(OBJ) output
```

При этом: пятая строка %.o: %.c означает следующее:
1. main.o генерируется из main.c
2. add.o генерируется из add.c
3. sub.o генерируется из sub.c

## 4.2 Псевдоцели

В предыдущих примерах мы просто выполняли команду "make", цель которой - выполнить первое правило, это аналогично выполнению "make output". Здесь "output" является и целью правила, и реальным файлом.
Что такое псевдоцель? Для предыдущих примеров сначала выполним команду make, затем команду "make clean":

```bash
$make
gcc -c main.c
gcc -c add.c
gcc -c sub.c
gcc -o output main.o add.o sub.o
$make clean
rm *.o output
```

Все работает нормально! Теперь сделаем хитрость - создадим файл с именем clean в директории Makefile, затем снова выполним make и make clean:

```bash
$touch clean
$make
gcc -c main.c
gcc -c add.c
gcc -c sub.c
gcc -o output main.o add.o sub.o
$make clean
make: 'clean' is up to date.
```

Почему при выполнении "make clean" команда не выполнилась? Потому что уже существует файл с именем clean, и его зависимости пусты, условия для выполнения правила не выполнены.
Псевдоцель решает эту проблему, добавим ".PHONY:clean" перед clean:

```makefile
CC = gcc
OBJ = main.o add.o sub.o
output: $(OBJ)
	$(CC) -o $@ $^
%.o: %.c
	$(CC) -c $<

.PHONY:clean
clean:
	rm $(OBJ) output
```

Результат выполнения:

```bash
$make
gcc -c main.c
gcc -c add.c
gcc -c sub.c
gcc -o output main.o add.o sub.o
$make clean
rm *.o output
```

Когда цель объявлена как псевдоцель, make при выполнении правила будет по умолчанию считать, что условия для выполнения выполнены.
Это повышает эффективность выполнения make и не нужно беспокоиться о совпадении имени цели с именем файла.
Два главных преимущества псевдоцелей:
1. Избежать конфликта имен между целями, предназначенными только для выполнения команд, и реальными файлами в рабочей директории.
2. Повысить эффективность выполнения Makefile

