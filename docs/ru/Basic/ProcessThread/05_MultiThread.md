# 5 Многопоточное программирование

Эта глава будет разделена на две основные части. Первая часть познакомит со сценариями использования потоков и основными концепциями, а также продемонстрирует на примерах кода базовый процесс создания, завершения и очистки потока. Вторая часть покажет на примерах кода, как управлять потоками, вводя концепции и методы использования мьютексов и семафоров через управление доступом к критическим ресурсам и порядком выполнения потоков.

## 5.1 Использование потоков

### 5.1.1 Зачем использовать многопоточность

При написании кода вы когда-нибудь сталкивались со следующими сценариями, в которых было сложно разобраться?

**Сценарий 1**: При написании программы для копирования файлов необходимо одновременно выполнять копирование и отображать прогресс пользователю. Традиционный подход заключается в обновлении переменной после завершения каждой операции копирования, затем преобразовании переменной в прогресс для отображения. При этом происходит последовательность: копирование->вычисление->отображение->копирование->вычисление->отображение... до завершения копирования. Такая архитектура программы крайне неэффективна, поскольку прогресс копирования можно обновить только после завершения одной операции копирования. Если разделить процесс на ветви - одну для решения задачи копирования, другую для вычисления и обновления - эффективность программы значительно повысится.

**Сценарий 2**: Чтение данных в блокирующем режиме при необходимости отправки данных в реальном времени. Например, при передаче данных через последовательный порт или по сети часто требуется двунаправленная связь. Когда чтение данных установлено в блокирующий режим, традиционный однопоточный подход может пройти блокировку только после получения данных, а затем выполнить отправку согласно логике. Когда необходимо реализовать возможность отправки и приема в любое время, это не удовлетворяет бизнес-требованиям. Если разделить процесс на ветви - одну для обработки логики приема данных, другую для решения логики отправки данных - функционал можно реализовать идеально.

На основе описанных выше сценариев многопоточное программирование может идеально решить указанные проблемы.

### 5.1.2 Концепция потока

Поток - это наименьшая единица, которую может планировать операционная система. Обычный процесс имеет только один поток, выполняющий соответствующую логику. С помощью многопоточного программирования один процесс может выполнять несколько различных задач. По сравнению с многопроцессным программированием потоки используют общие ресурсы, то есть каждый поток может обращаться к глобальным переменным, появляющимся в процессе, разделяет с процессом "4 ГБ" адресного пространства памяти, что снижает потребление системных ресурсов. В этой главе рассматриваются потоки POSIX в Linux.

### 5.1.3 Идентификатор потока pthread_t

Для процесса каждый процесс имеет уникальный PID, представляющий этот процесс. Для потока также есть "аналог PID процесса", называемый tid, который по сути является переменной типа pthread_t. Идентификатор потока и идентификатор процесса являются уникальными идентификаторами для представления потока и процесса, но идентификатор потока имеет смысл только в контексте процесса, которому он принадлежит.

```c
Получение идентификатора потока
#include <pthread.h>
pthread_t pthread_self(void);
Успех: возвращает идентификатор потока
```

В программе можно использовать функцию pthread_self для получения идентификатора текущего потока. Пример 1 демонстрирует вывод tid потока.

Тестовый пример 1: (Phtread_txex1.c)

```c
1	#include <pthread.h>
2	#include <stdio.h>
3
4	int main()
5	{
6		pthread_t tid = pthread_self();//Получение tid главного потока
7		printf("tid = %lu\n",(unsigned long)tid);
8       return 0;
9	}
```

Примечание: Поскольку используется интерфейс потоков POSIX, при компиляции необходимо включить библиотеку pthread. При использовании gcc компиляция должна выполняться как gcc xxx.c -lpthread для компиляции многопоточной программы.

Результат компиляции:

![MultiThread_Image001](http://photos.100ask.net/NewHomeSite/MultiThread_Image001.png)

### 5.1.4 Создание потока

```c
Создание потока
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
Успех: возвращает 0
```

В традиционной программе процесс имеет только один поток. Можно создать поток с помощью функции pthread_create.

Первый параметр этой функции - адрес идентификатора потока типа pthread_t, после успешного выполнения функции он будет указывать на идентификатор нового потока; второй параметр представляет атрибуты потока, обычно передается NULL для атрибутов по умолчанию; третий параметр - указатель на функцию с возвращаемым значением void * и параметром void *, после успешного создания потока эта функция обратного вызова автоматически выполнится; четвертый параметр представляет параметр, передаваемый в функцию обработки потока, если не передавать, можно заполнить NULL. Подробное объяснение передачи параметров в поток будет в следующих разделах. Далее приведен простой пример использования этой функции для создания потока.

Тестовый пример 2: (Phtread_txex2.c)

```c
1 	#include <pthread.h>
2 	#include <stdio.h>
3 	#include <unistd.h>
4 	#include <errno.h>
5
6 	void *fun(void *arg)
7 	{
8 		printf("pthread_New = %lu\n",(unsigned long)pthread_self());//Вывод tid потока
9 	}
10
11	int main()
12	{
13
14		pthread_t tid1;
15		int ret = pthread_create(&tid1,NULL,fun,NULL);//Создание потока
16		if(ret != 0){
17			perror("pthread_create");
18			return -1;
19		}
20
21		/*tid_main - ID потока, полученный через pthread_self, tid_new - пространство, на которое указывает tid после успешного выполнения pthread_create*/
22		printf("tid_main = %lu tid_new = %lu \n",(unsigned long)pthread_self(),(unsigned long)tid1);
23
24		/*Из-за случайного порядка выполнения потоков отсутствие sleep может привести к выполнению главного потока первым, завершению процесса и невыполнению дочернего потока*/
25		sleep(1);
26
27		return 0;
28	}
29
```

Результат выполнения:

![MultiThread_Image002](http://photos.100ask.net/NewHomeSite/MultiThread_Image002.png)

С помощью pthread_create действительно можно создать поток. Идентификатор tid в главном потоке после выполнения pthread_create указывает на область идентификатора потока, что соответствует идентификатору потока, выведенному в дочернем потоке через функцию pthread_self.

Особо следует отметить, что когда главный поток завершается вместе с процессом, все созданные потоки также немедленно завершаются и не продолжают выполнение. Кроме того, порядок выполнения созданных потоков является случайным и конкурентным, нельзя гарантировать, какой поток будет выполнен первым. Можно закомментировать функцию sleep в коде выше и наблюдать результат эксперимента.

Результат выполнения после удаления строки 25 из кода выше:

![MultiThread_Image003](http://photos.100ask.net/NewHomeSite/MultiThread_Image003.png)

После выполнения кода 3 раза в 2 случаях процесс завершился, не дойдя до логики дочернего потока, и только в последний раз логика дочернего потока была выполнена перед завершением процесса. Это показывает, что порядок выполнения потоков неконтролируемый, и когда весь процесс завершается, созданные потоки также освобождаются. В последующем содержании будет описано, как управлять выполнением потоков.

### 5.1.5 Передача параметров в поток

Последний параметр pthread_create() имеет тип void *, что означает, что в поток можно передать параметр типа void *. В функции обратного вызова потока можно получить этот параметр. Пример 3 демонстрирует, как передать в поток адрес переменной и значение переменной.

Тестовый пример 3: (Phtread_txex3.c)

```c
1 	#include <pthread.h>
2 	#include <stdio.h>
3 	#include <unistd.h>
4 	#include <errno.h>
5
6 	void *fun1(void *arg)
7 	{
8 		printf("%s:arg = %d Addr = %p\n",__FUNCTION__,*(int *)arg,arg);
9 	}
10
11	void *fun2(void *arg)
12	{
13		printf("%s:arg = %d Addr = %p\n",__FUNCTION__,(int)(long)arg,arg);
14	}
15
16	int main()
17	{
18
19		pthread_t tid1,tid2;
20		int a = 50;
21		int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);//Создание потока с передачей адреса переменной a
22		if(ret != 0){
23			perror("pthread_create");
24			return -1;
25		}
27		ret = pthread_create(&tid2,NULL,fun2,(void *)(long)a);//Создание потока с передачей значения переменной a
28		if(ret != 0){
29			perror("pthread_create");
30			return -1;
31		}
32		sleep(1);
33		printf("%s:a = %d Add = %p \n",__FUNCTION__,a,&a);
34		return 0;
35	}
36
```

Результат выполнения:

![MultiThread_Image004](http://photos.100ask.net/NewHomeSite/MultiThread_Image004.png)

Этот пример демонстрирует, как использовать четвертый параметр функции создания потока для передачи данных в поток, показывая передачу значения через адрес и передачу значения через переменную. В строке 21 примера адрес переменной a сначала берется, затем принудительно преобразуется в тип void и передается в поток. В функции обратного вызова обработки потока универсальный указатель void * сначала преобразуется в int *, затем берется адрес для получения значения переменной по этому адресу - суть в передаче адреса. В строке 27 примера переменная типа int напрямую преобразуется в void * для передачи (для машин с разной разрядностью выравнивание указателей различается, нужно преобразовать int в long, затем в указатель, иначе может появиться предупреждение). В функции обратного вызова обработки потока данные void * напрямую преобразуются в тип int - суть в передаче значения переменной a.

Оба метода выше могут получить нужное значение, но важно понимать их суть: один - передача адреса, другой - передача значения. При изменении переменной после передачи адреса переменная, соответствующая этому адресу, также изменится, но при передаче значения переменной, даже если переменная, на которую указывает указатель, изменится, переданное значение не изменится, так как оно не зависит от указателя. В реальных проектах важно помнить разницу между ними. Подробное объяснение см. в примере 4.

Тестовый пример 4: (Phtread_txex4.c)

```c
1 	#include <pthread.h>
2 	#include <stdio.h>
3 	#include <unistd.h>
4 	#include <errno.h>
5
6 	void *fun1(void *arg)
7 	{
8 		while(1){
9
10			printf("%s:arg = %d Addr = %p\n",__FUNCTION__,*(int *)arg,arg);
11			sleep(1);
12		}
13	}
14
15	void *fun2(void *arg)
16	{
17		while(1){
18
19			printf("%s:arg = %d Addr = %p\n",__FUNCTION__,(int)(long)arg,arg);
20			sleep(1);
21		}
22	}
23
24	int main()
25	{
26
27		pthread_t tid1,tid2;
28		int a = 50;
29		int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);
30		if(ret != 0){
31			perror("pthread_create");
32			return -1;
33		}
34		sleep(1);
35		ret = pthread_create(&tid2,NULL,fun2,(void *)(long)a);
36		if(ret != 0){
37			perror("pthread_create");
38			return -1;
39		}
40		while(1){
41			a++;
42			sleep(1);
43			printf("%s:a = %d Add = %p \n",__FUNCTION__,a,&a);
44		}
45		return 0;
46	}
47
```

Результат выполнения:

![MultiThread_Image005](http://photos.100ask.net/NewHomeSite/MultiThread_Image005.png)

Пример выше объясняет, как передать один параметр в поток. При работе с реальными проектами часто возникает необходимость передачи нескольких параметров. Это можно решить с помощью структуры.

Тестовый пример 5: (Phtread_txex5.c)

```c
1 	#include <pthread.h>
2 	#include <stdio.h>
3 	#include <unistd.h>
4 	#include <string.h>
5 	#include <errno.h>
6
7 	struct Stu{
8 		int Id;
9 		char Name[32];
10		float Mark;
11	};
12
13	void *fun1(void *arg)
14	{
15		struct Stu *tmp = (struct Stu *)arg;
16		printf("%s:Id = %d Name = %s Mark = %.2f\n",__FUNCTION__,tmp->Id,tmp->Name,tmp->Mark);
17
18	}
19
20	int main()
21	{
22
23		pthread_t tid1,tid2;
24		struct Stu stu;
25		stu.Id = 10000;
26		strcpy(stu.Name,"ZhangSan");
27		stu.Mark = 94.6;
28
29		int ret = pthread_create(&tid1,NULL,fun1,(void *)&stu);
30		if(ret != 0){
31			perror("pthread_create");
32			return -1;
33		}
34		printf("%s:Id = %d Name = %s Mark = %.2f\n",__FUNCTION__,stu.Id,stu.Name,stu.Mark);
35		sleep(1);
36		return 0;
37	}
38
```

Результат выполнения:

![MultiThread_Image006](http://photos.100ask.net/NewHomeSite/MultiThread_Image006.png)

### 5.1.6 Завершение и очистка потока

Существует три способа завершения потока: первый - завершение процесса, при котором все потоки процесса также завершаются. Второй - активный выход из потока через функцию pthread_exit. Третий - пассивное завершение другим потоком через функцию pthread_cancel. После завершения потока главный поток может очистить ресурсы потока с помощью функции pthread_join/pthread_tryjoin_np и получить данные, которые должны быть возвращены после завершения потока.

```c
Завершение потока
#include <pthread.h>
void pthread_exit(void *retval);
```

Эта функция служит для завершения потока. При выходе можно передать данные типа void * в главный поток. Если не нужно передавать данные, параметр можно заполнить как NULL.

```c
Очистка ресурсов потока (блокирующая)
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
Успех: возвращает 0
```

Эта функция служит для очистки потока. Состояние по умолчанию - блокирующее, до успешной очистки потока блокировка снимается. Первый параметр - идентификатор tid потока для очистки, второй параметр - для приема данных, переданных потоком после очистки.

```c
Очистка ресурсов потока (неблокирующая)
#define _GNU_SOURCE
#include <pthread.h>
int pthread_tryjoin_np(pthread_t thread, void **retval);
Успех: возвращает 0
```

Эта функция - неблокирующий режим очистки. По возвращаемому значению можно определить, был ли очищен поток. При успешной очистке возвращается 0. Остальные параметры идентичны pthread_join.

```c
Завершение потока (по указанному идентификатору потока)
#include <pthread.h>
int pthread_cancel(pthread_t thread);
Успех: возвращает 0
```

Эта функция принимает tid и принудительно завершает поток, на который указывает этот tid. При успешном выполнении возвращается 0.

Приведенное выше описание кратко представляет API для очистки потоков. Ниже примеры демонстрируют использование этих API.

Тестовый пример 6: (Phtread_txex6.c)

```c
1 	#include <pthread.h>
2 	#include <stdio.h>
3 	#include <unistd.h>
4 	#include <errno.h>
5
6 	void *fun1(void *arg)
7 	{
8 		static int tmp = 0;//Должен быть модификатор static, иначе pthread_join не сможет получить правильное значение
9 		//int tmp = 0;
10		tmp = *(int *)arg;
11		tmp+=100;
12		printf("%s:Addr = %p tmp = %d\n",__FUNCTION__,&tmp,tmp);
13		pthread_exit((void *)&tmp);//Взять адрес переменной tmp, преобразовать в тип void* и передать
14	}
15
16
17	int main()
18	{
19
20		pthread_t tid1;
21		int a = 50;
22		void *Tmp = NULL;//Поскольку второй параметр pthread_join имеет тип void**
23		int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);
24		if(ret != 0){
25			perror("pthread_create");
26			return -1;
27		}
28		pthread_join(tid1,&Tmp);
29		printf("%s:Addr = %p Val = %d\n",__FUNCTION__,Tmp,*(int *)Tmp);
30		return 0;
31	}
32
```

Результат выполнения:

![MultiThread_Image007](http://photos.100ask.net/NewHomeSite/MultiThread_Image007.png)

Пример выше сначала передает переменную в виде адреса в поток через строку 23, в потоке выполняется операция увеличения на 100. При выходе из потока через параметр потока данные типа void * принимаются через pthread_join. В этом примере убрана функция sleep, добавленная ранее, потому что функция pthread_join имеет свойство блокировки - блокировка снимается только после успешной очистки потока, поэтому нет необходимости учитывать ситуацию, когда главный поток достигнет строки 30 и завершит процесс. Особо следует отметить строку 8 примера: когда переменная передается из потока, необходим модификатор static для продления жизненного цикла, иначе невозможно передать правильное значение переменной.

Тестовый пример 7: (Phtread_txex7.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6
7 	void *fun(void *arg)
8 	{
9 		printf("Pthread:%d Come !\n",(int )(long)arg+1);
10		pthread_exit(arg);
11	}
12
13
14	int main()
15	{
16		int ret,i,flag = 0;
17		void *Tmp = NULL;
18		pthread_t tid[3];
19		for(i = 0;i < 3;i++){
20			ret = pthread_create(&tid[i],NULL,fun,(void *)(long)i);
21			if(ret != 0){
22				perror("pthread_create");
23				return -1;
24			}
25		}
26		while(1){//Неблокирующая очистка потоков, при каждой успешной очистке переменная увеличивается, пока все 3 потока не будут очищены
27			for(i = 0;i <3;i++){
28				if(pthread_tryjoin_np(tid[i],&Tmp) == 0){
29					printf("Pthread : %d exit !\n",(int )(long )Tmp+1);
30					flag++;
31				}
32			}
33			if(flag >= 3) break;
34		}
35		return 0;
36	}
37
```

Результат выполнения:

![MultiThread_Image008](http://photos.100ask.net/NewHomeSite/MultiThread_Image008.png)

Пример 7 демонстрирует использование неблокирующего способа очистки потоков, а также показывает ситуацию, когда несколько потоков могут указывать на одну и ту же функцию обратного вызова. Пример 6 через блокирующий способ очистки потоков почти определяет порядок очистки потоков. Если первый очищаемый поток не завершился, он будет заблокирован, что приведет к невозможности своевременной очистки последующих потоков, завершившихся раньше.

С помощью функции pthread_tryjoin_np используется неблокирующая очистка, потоки могут свободно очищаться в порядке их завершения.

Тестовый пример 8: (Phtread_txex8.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6
7 	void *fun1(void *arg)
8 	{
9 		printf("Pthread:1 come!\n");
10		while(1){
11			sleep(1);
12		}
13	}
14
15	void *fun2(void *arg)
16	{
17		printf("Pthread:2 come!\n");
18		pthread_cancel((pthread_t )(long)arg);//Принудительно завершить поток 1
19		pthread_exit(NULL);
20	}
21
22	int main()
23	{
24		int ret,i,flag = 0;
25		void *Tmp = NULL;
26		pthread_t tid[2];
27		ret = pthread_create(&tid[0],NULL,fun1,NULL);
28		if(ret != 0){
29			perror("pthread_create");
30			return -1;
31		}
32		sleep(1);
33		ret = pthread_create(&tid[1],NULL,fun2,(void *)tid[0]);//Передать идентификатор потока 1
34		if(ret != 0){
35			perror("pthread_create");
36			return -1;
37		}
38		while(1){//Неблокирующая очистка потоков, при каждой успешной очистке переменная увеличивается, пока все 2 потока не будут очищены

39			for(i = 0;i <2;i++){
40				if(pthread_tryjoin_np(tid[i],NULL) == 0){
41					printf("Pthread : %d exit !\n",i+1);
42					flag++;
43				}
44			}
45			if(flag >= 2) break;
46		}
47		return 0;
48	}
49
```

Результат выполнения:

![MultiThread_Image009](http://photos.100ask.net/NewHomeSite/MultiThread_Image009.png)

Пример 8 демонстрирует, как активно завершить определенный поток с помощью функции pthread_cancel. Строки 27 и 33 создают потоки, передавая идентификатор первого потока во второй поток в форме параметра. Первый поток выполняет логику бесконечного цикла сна, теоретически он никогда не завершится, кроме как при завершении процесса. Но во втором потоке вызывается функция pthread_cancel, что эквивалентно отправке команды выхода этому потоку, приводя к его завершению, и в конечном итоге его ресурсы очищаются неблокирующим способом. В этом примере важно обратить внимание на функцию sleep в строке 32 - необходимо убедиться, что поток 1 выполняется первым. Поскольку потоки выполняются неупорядоченно, добавлена эта функция сна для управления порядком. В последующих разделах этой главы будет объяснено, как разумно управлять доступом к критическим ресурсам и порядком выполнения потоков с помощью блокировок, семафоров и других средств.

## 5.2 Управление потоками

### 5.2.1 Доступ к критическим ресурсам в многопоточности

Когда потоки в процессе работы обращаются к общим ресурсам, таким как глобальные переменные, может возникнуть явление взаимного "противоречия". Например, поток 1 пытается увеличить переменную, а поток 2 пытается уменьшить переменную. Два потока находятся в конкурентных отношениях, что приводит к постоянному "балансу" переменной. Два потока конкурируют друг с другом: когда поток 1 получает право выполнения, он увеличивает переменную, когда поток 2 получает право выполнения, он уменьшает переменную. Переменная, кажется, всегда колеблется в определенном диапазоне и не может достичь ожидаемого значения, как показано в примере 9.

Тестовый пример 9: (Phtread_txex9.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6
7
8 	int Num = 0;
9
10	void *fun1(void *arg)
11	{
12		while(Num < 3){
13			Num++;
14			printf("%s:Num = %d\n",__FUNCTION__,Num);
15			sleep(1);
16		}
17		pthread_exit(NULL);
18	}
19
20	void *fun2(void *arg)
21	{
22		while(Num > -3){
23			Num--;
24			printf("%s:Num = %d\n",__FUNCTION__,Num);
25			sleep(1);
26		}
27		pthread_exit(NULL);
28	}
29
30	int main()
31	{
32		int ret;
33		pthread_t tid1,tid2;
34		ret = pthread_create(&tid1,NULL,fun1,NULL);
35		if(ret != 0){
36			perror("pthread_create");
37			return -1;
38		}
39		ret = pthread_create(&tid2,NULL,fun2,NULL);
40		if(ret != 0){
41			perror("pthread_create");
42			return -1;
43		}
44		pthread_join(tid1,NULL);
45		pthread_join(tid2,NULL);
46		return 0;
47	}
48
```

Результат выполнения:

![MultiThread_Image010](http://photos.100ask.net/NewHomeSite/MultiThread_Image010.png)

Для решения вышеупомянутой проблемы конкуренции за критические ресурсы в потоках pthread введены мьютексы для управления доступом к критическим ресурсам. Путем блокировки критических ресурсов обеспечивается, что ресурс обрабатывается только одним потоком. После завершения операции происходит разблокировка, и другие потоки могут получить право на операцию.

### 5.2.2 Краткое описание API мьютекса

```c
Инициализация мьютекса
#include <pthread.h>
int pthread_mutex_init(phtread_mutex_t *mutex,
const pthread_mutexattr_t *restrict attr);
Успех: возвращает 0
```

Эта функция служит для инициализации мьютекса. Обычно объявляется глобальная переменная типа pthread_mutex_t для мьютекса, которая инициализируется с помощью этой функции. Первый параметр - адрес этой переменной, второй параметр управляет атрибутами мьютекса, обычно NULL. При успешном выполнении функция возвращает 0, что означает успешную инициализацию мьютекса. Также можно использовать макрос для быстрой инициализации мьютекса:

pthread_mutex_t mutex = PTHREAD_MUTEX_INITALIZER;

```c
Блокировка/разблокировка мьютекса (блокирующая)
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

Функции lock и unlock служат для блокировки и разблокировки соответственно. Достаточно передать уже инициализированную переменную мьютекса pthread_mutex_t, при успехе возвращается 0. Когда один из потоков получает право выполнения и выполняет функцию lock, после успешной блокировки остальные потоки при встрече с функцией lock блокируются, пока поток, получивший ресурс, не выполнит функцию unlock. Затем поток, получивший второе право выполнения, снимает блокировку и также получает lock, что приводит к блокировке остальных потоков до выполнения unlock.

Особо следует отметить, что после получения lock обязательно нужно выполнить unlock после завершения обработки логики, иначе произойдет взаимная блокировка! Это приведет к постоянной блокировке остальных потоков, не позволяя им продолжить выполнение. При использовании мьютексов особенно важно обращать внимание на использование функции pthread_cancel, чтобы предотвратить взаимную блокировку!

```c
Блокировка мьютекса (неблокирующая)
#include <pthread.h>
 int pthread_mutex_trylock(pthread_mutex_t *mutex);
Успех: возвращает 0
```

Эта функция также служит для блокировки потока, но работает в неблокирующем режиме. По возвращаемому значению можно определить, была ли блокировка успешной. Использование идентично блокирующей функции блокировки.

```c
Уничтожение мьютекса
#include <pthread.h>
int pthread_mutex_destory(pthread_mutex_t *mutex);
Успех: возвращает 0
```

Эта функция служит для уничтожения мьютекса. Передав адрес мьютекса, можно завершить уничтожение мьютекса, при успехе возвращается 0.

Тестовый пример 10: (Phtread_txex10.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6
7 	pthread_mutex_t mutex;//Переменная мьютекса, обычно объявляется как глобальная
8
9 	int Num = 0;//Общая критическая переменная
10
11	void *fun1(void *arg)
12	{
13		pthread_mutex_lock(&mutex);//Блокировка, если другой поток получил блокировку, произойдет блокировка
14		while(Num < 3){
15			Num++;
16			printf("%s:Num = %d\n",__FUNCTION__,Num);
17			sleep(1);
18		}
19		pthread_mutex_unlock(&mutex);//Разблокировка
20		pthread_exit(NULL);//Завершение потока, pthread_join очистит ресурсы
21	}
22
23	void *fun2(void *arg)
24	{
25		pthread_mutex_lock(&mutex);//Блокировка, если другой поток получил блокировку, произойдет блокировка
26		while(Num > -3){
27			Num--;
28			printf("%s:Num = %d\n",__FUNCTION__,Num);
29			sleep(1);
30		}
31		pthread_mutex_unlock(&mutex);//Разблокировка
32		pthread_exit(NULL);//Завершение потока, pthread_join очистит ресурсы
33	}
34
35	int main()
36	{
37		int ret;
38		pthread_t tid1,tid2;
39		ret = pthread_mutex_init(&mutex,NULL);//Инициализация мьютекса
40		if(ret != 0){
41			perror("pthread_mutex_init");
42			return -1;
43		}
44		ret = pthread_create(&tid1,NULL,fun1,NULL);//Создание потока 1
45		if(ret != 0){
46			perror("pthread_create");
47			return -1;
48		}
49		ret = pthread_create(&tid2,NULL,fun2,NULL);//Создание потока 2
50		if(ret != 0){
51			perror("pthread_create");
52			return -1;
53		}
54		pthread_join(tid1,NULL);//Блокирующая очистка потока 1
55		pthread_join(tid2,NULL);//Блокирующая очистка потока 2
56		pthread_mutex_destroy(&mutex);//Уничтожение мьютекса
57		return 0;
58	}
59
```

Результат выполнения:

![MultiThread_Image011](http://photos.100ask.net/NewHomeSite/MultiThread_Image011.png)

Пример выше через добавление мьютекса обеспечивает, что критическая переменная в определенный момент времени контролируется только одним потоком, реализуя управление критическими ресурсами. Следует пояснить ситуации блокировки потока внутри и вне цикла. В этом примере операция блокировки выполняется перед входом в цикл while, а операция разблокировки - после завершения цикла. Если поместить блокировку и разблокировку внутрь цикла while, результат выполнения на однопроцессорной машине будет таким же. При выполнении кода на многопроцессорной машине может возникнуть явление "захвата блокировки", что зависит от реализации нижнего уровня операционной системы.

### 5.2.3 Управление порядком выполнения в многопоточности

Решена проблема доступа к критическим ресурсам, но, похоже, невозможно управлять порядком выполнения потоков. Поскольку потоки выполняются неупорядоченно, ранее использовался метод принудительной задержки с помощью sleep для управления порядком выполнения, но этот метод в реальных проектах часто неприемлем. Он может решить только порядок создания потоков, но после создания порядок выполнения снова становится неконтролируемым. Поэтому вводится концепция семафоров для решения порядка выполнения потоков.

Пример 11 продемонстрирует случайность выполнения потоков.

Тестовый пример 11: (Phtread_txex11.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6
7 	void *fun1(void *arg)
8 	{
9 		printf("%s:Pthread Come!\n",__FUNCTION__);
10		pthread_exit(NULL);
11	}
12
13	void *fun2(void *arg)
14	{
15		printf("%s:Pthread Come!\n",__FUNCTION__);
16		pthread_exit(NULL);
17	}
18
19	void *fun3(void *arg)
20	{
21		printf("%s:Pthread Come!\n",__FUNCTION__);
22		pthread_exit(NULL);
23	}
24
25	int main()
26	{
27		int ret;
28		pthread_t tid1,tid2,tid3;
29		ret = pthread_create(&tid1,NULL,fun1,NULL);
30		if(ret != 0){
31			perror("pthread_create");
32			return -1;
33		}
34		ret = pthread_create(&tid2,NULL,fun2,NULL);
35		if(ret != 0){
36			perror("pthread_create");
37			return -1;
38		}
39		ret = pthread_create(&tid3,NULL,fun3,NULL);
40		if(ret != 0){
41			perror("pthread_create");
42			return -1;
43		}
44		pthread_join(tid1,NULL);
45		pthread_join(tid2,NULL);
46		pthread_join(tid3,NULL);
47		return 0;
48	}
49
```

Результат выполнения:

![MultiThread_Image012](http://photos.100ask.net/NewHomeSite/MultiThread_Image012.png)

Из примера выше можно обнаружить, что при многократном выполнении этой функции порядок является неупорядоченным. Конкуренцию между потоками невозможно контролировать. Использование семафоров позволяет сделать порядок потоков контролируемым.

### 5.2.4 Краткое описание API семафора

```c
Инициализация семафора
#include <semaphore.h>
int sem_init(sem_t *sem,int pshared,unsigned int value);
Успех: возвращает 0
```

Эта функция может инициализировать семафор. Первый параметр - адрес типа sem_t, второй параметр: 0 означает управление потоками, иначе - управление процессами, третий параметр представляет начальное значение семафора: 0 означает блокировку, 1 означает выполнение. После завершения инициализации семафора при успешном выполнении возвращается 0.

```c
PV-операции семафора (блокирующие)
#include <pthread.h>
int sem_wait(sem_t *sem);
int sem_post(sem_t *sem);
Успех: возвращает 0
```

Функция sem_wait служит для проверки доступности ресурсов указанного семафора. Если ресурсы недоступны, происходит блокировка ожидания. Если ресурсы доступны, автоматически выполняется операция "sem-1". Так называемая "sem-1" соответствует значению третьего параметра функции инициализации выше. При успешном выполнении возвращается 0.

Функция sem_post освобождает ресурсы указанного семафора, выполняя операцию "sem+1".

С помощью двух функций выше можно выполнить так называемые PV-операции, то есть запрос и освобождение семафора, управляя порядком выполнения потоков.

```c
Запрос ресурса семафора (неблокирующий)
#include <pthread.h>
int sem_trywait(sem_t *sem);
Успех: возвращает 0
```

Как и в случае с мьютексом, эта функция является неблокирующей функцией управления запросом ресурсов семафора. Функциональность идентична sem_wait, единственное отличие в том, что эта функция неблокирующая.

```c
Уничтожение семафора
#include <pthread.h>
int sem_destory(sem_t *sem);
Успех: возвращает 0
```

Эта функция служит для уничтожения семафора. После выполнения запрошенный семафор может быть уничтожен.

Тестовый пример 12: (Phtread_txex12.c)

```c
1 	#define _GNU_SOURCE
2 	#include <pthread.h>
3 	#include <stdio.h>
4 	#include <unistd.h>
5 	#include <errno.h>
6 	#include <semaphore.h>
7
8 	sem_t sem1,sem2,sem3;//Три переменные семафора
9
10	void *fun1(void *arg)
11	{
12		sem_wait(&sem1);//Поскольку sem1 имеет ресурс, блокировки не происходит. После получения sem1-1, следующий раз будет блокировка
13		printf("%s:Pthread Come!\n",__FUNCTION__);
14		sem_post(&sem2);// Дать ресурс sem2
15		pthread_exit(NULL);
16	}
17
18	void *fun2(void *arg)
19	{
20		sem_wait(&sem2);//Поскольку sem2 при инициализации не имеет ресурса, будет блокировка до выполнения строки 14. После разблокировки sem2-1, следующий раз будет блокировка
21		printf("%s:Pthread Come!\n",__FUNCTION__);
22		sem_post(&sem3);// Дать ресурс sem3
23		pthread_exit(NULL);
24	}
25
26	void *fun3(void *arg)
27	{
28		sem_wait(&sem3);//Поскольку sem3 при инициализации не имеет ресурса, будет блокировка до выполнения строки 22. После разблокировки sem3-1, следующий раз будет блокировка
29		printf("%s:Pthread Come!\n",__FUNCTION__);
30		sem_post(&sem1);// Дать ресурс sem1
31		pthread_exit(NULL);
32	}
33
34	int main()
35	{
36		int ret;
37		pthread_t tid1,tid2,tid3;
38		ret = sem_init(&sem1,0,1);  //Инициализация семафора 1 и предоставление ему ресурса
39		if(ret < 0){
40			perror("sem_init");
41			return -1;
42		}
43		ret = sem_init(&sem2,0,0); //Инициализация семафора 2, блокировка
44		if(ret < 0){
45			perror("sem_init");
46			return -1;
47		}
48		ret = sem_init(&sem3,0,0); //Инициализация семафора 3, блокировка
49		if(ret < 0){
50			perror("sem_init");
51			return -1;
52		}
53		ret = pthread_create(&tid1,NULL,fun1,NULL);//Создание потока 1
54		if(ret != 0){
55			perror("pthread_create");
56			return -1;
57		}
58		ret = pthread_create(&tid2,NULL,fun2,NULL);//Создание потока 2
59		if(ret != 0){
60			perror("pthread_create");
61			return -1;
62		}
63		ret = pthread_create(&tid3,NULL,fun3,NULL);//Создание потока 3
64		if(ret != 0){
65			perror("pthread_create");
66			return -1;
67		}
68		/*Очистка ресурсов потоков*/
69		pthread_join(tid1,NULL);
70		pthread_join(tid2,NULL);
71		pthread_join(tid3,NULL);
72
73		/*Уничтожение семафоров*/
74		sem_destroy(&sem1);
75		sem_destroy(&sem2);
76		sem_destroy(&sem3);
77
78		return 0;
79	}
80
```

Результат выполнения:

![MultiThread_Image013](http://photos.100ask.net/NewHomeSite/MultiThread_Image013.png)

Этот пример добавляет управление семафорами, делая порядок выполнения потоков контролируемым. При инициализации семафоров семафору 1 предоставляется ресурс, чтобы он не блокировался функцией sem_wait. После выполнения логики используется функция sem_post для предоставления ресурса, который должен быть выполнен следующим. После выполнения функции sem_wait происходит операция уменьшения sem, что приводит к блокировке следующей конкуренции до освобождения через sem_post.

В примере выше при инициализации семафора 1 в строке 38 ему по умолчанию предоставляется ресурс. При инициализации семафоров 2 и 3 в строках 43 и 48 им не предоставляются ресурсы. Поэтому в функциях обработки потоков каждый поток ожидает ресурсов через функцию sem_wait, происходит блокировка. Поскольку начальное значение семафора 1 имеет ресурс, сначала может быть выполнена логика потока 1. После выполнения функции sem_wait в строке 12 происходит sem1-1, что приводит к блокировке следующего раза для этого потока. Затем выполняется строка 14, через функцию sem_post семафор sem2 получает ресурс, тем самым снимая блокировку и выполняя логику потока 2... и так далее, завершая упорядоченное управление потоками.

## 5.3 Заключение

Процесс создания многопоточности показан на рисунке ниже. Сначала необходимо создать поток. После создания потока потоки конкурируют друг с другом при выполнении, захватывая временные интервалы для выполнения логики потока. При создании потока можно передать параметры через четвертый параметр функции создания потока. При завершении потока также можно передать параметры, которые будут получены функцией очистки потока.

![MultiThread_Image014](http://photos.100ask.net/NewHomeSite/MultiThread_Image014.png)

<center><p>Процесс многопоточного программирования</p></center>

Когда появляется несколько потоков, возникает проблема одновременного обращения к критическим общим ресурсам. При обращении потока к общим ресурсам необходимо защитить поток блокировкой, чтобы предотвратить одновременное изменение переменной другим потоком. После завершения выполнения логики происходит разблокировка, позволяя остальным потокам снова начать конкуренцию. Процесс создания мьютекса показан на рисунке ниже.

![MultiThread_Image015](http://photos.100ask.net/NewHomeSite/MultiThread_Image015.png)

<center><p>Процесс программирования с мьютексом</p></center>

Когда появляется несколько потоков, также возникает проблема неупорядоченного выполнения. Иногда необходимо ограничить порядок выполнения потоков, поэтому вводятся семафоры. Через PV-операции управляется порядок выполнения потоков, как показано на рисунке ниже.

![MultiThread_Image016](http://photos.100ask.net/NewHomeSite/MultiThread_Image016.png)

<center><p>Процесс программирования с семафорами</p></center>
