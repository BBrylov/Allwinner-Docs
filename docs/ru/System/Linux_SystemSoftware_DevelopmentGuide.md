# Разработка Tina-SDK
## 1 Обзор

Цель написания: Данный документ является руководством по разработке на системной платформе Allwinner Tina Linux, предназначенным для помощи инженерам по разработке ПО и инженерам технической поддержки в быстром освоении процессов разработки и отладки системы Tina Linux.

Область применения: Tina Linux v3.5 и выше.


## 2 Материалы по системе Tina

### 2.1 Обзор

Документация, выпускаемая с Tina SDK, предназначена для помощи разработчикам в быстром освоении разработки и отладки. Содержание документации не может охватить все знания и проблемы разработки. Список документов постоянно обновляется.


Tina SDK предоставляет обширную документацию, включая документы по эталонному проектированию оборудования, списки поддержки базовых компонентов, таких как Flash, руководства по использованию инструментов массового производства, документы по разработке и настройке ПО, руководства по разработке чипов и другие материалы.

### 2.2 Список документов

Пожалуйста, сверяйтесь с актуальным списком на платформе обслуживания клиентов Allwinner.

## 3 Обзор системы Tina

### 3.1 Обзор

Система Tina Linux - это пакет разработки ПО, основанный на openwrt-14.07, включающий исходный код ядра Linux, драйверы, инструменты, системное промежуточное ПО и пакеты приложений, используемые при разработке системы. openwrt - это фреймворк автоматической сборки встраиваемой системы Linux с открытым исходным кодом, состоящий из скриптов Makefile и конфигурационных файлов Kconfig. Это позволяет пользователям через конфигурацию menuconfig компилировать полное ПО системы Linux, которое можно напрямую записать на устройство и запустить.

### 3.2 Диаграмма системы


![Рисунок 3-1: Диаграмма системы Tina Linux](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-3-1.jpg)

Диаграмма ПО системы Tina, как показано на рисунке, состоит из четырех уровней снизу вверх: Kernel && Driver, Libraries, System Services, Applications. Содержание каждого уровня следующее:


1. Kernel&&Driver обеспечивает стандартную реализацию ядра Linux. Ядро Linux платформы Tina использует Linux 3.4, linux 3.10, linux 4.4, linux 4.9 и другие версии ядра (разные аппаратные платформы могут использовать разные версии ядра). Обеспечивает безопасность, управление памятью, управление процессами, сетевой стек и другую базовую поддержку; в основном управляет аппаратными ресурсами устройства через ядро Linux, такими как планирование CPU, кэш, память, I/O и т.д.
2. Уровень Libraries соответствует промежуточному уровню обычной встраиваемой системы. Включает различные базовые системные библиотеки и поддержку сторонних библиотек с открытым исходным кодом, предоставляя API-интерфейсы уровню приложений. Настройщики системы и разработчики приложений могут разрабатывать новые приложения на основе API уровня Libraries.
3. Уровень System Services соответствует уровню системных служб, включая управление запуском системы, управление конфигурацией, управление горячим подключением, управление хранением, мультимедийное промежуточное ПО и т.д.
4. Уровень Applications в основном реализует конкретные функции продукта и логику взаимодействия, требует поддержки системных базовых библиотек и сторонних библиотек. Разработчики могут создавать собственные приложения, предоставляющие различные возможности системы конечным пользователям.

### 3.3 Процесс разработки

Система Tina Linux - это SDK, разработанный на основе ядра Linux для различных типов продуктов. На основе этого
SDK можно эффективно реализовать настройку системы и портирование приложений.


![Рисунок 3-2: Процесс разработки системы Tina Linux](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-3-2.jpg)

Как показано на рисунке выше, разработчики могут следовать приведенному процессу разработки для быстрого построения среды разработки системы Tina Linux и компиляции
кода локально. Ниже кратко описан этот процесс:

1. Проверка системных требований: Перед загрузкой кода и компиляцией необходимо убедиться, что локальное устройство разработки соответствует требованиям, включая аппаратные возможности машины, программную систему, цепочку инструментов и т.д. В настоящее время система Tina Linux поддерживает компиляцию только в среде операционной системы Ubuntu и предоставляет поддержку цепочки инструментов только для среды Linux. Другие системы, такие как MacOS, Windows и т.д., пока не поддерживаются.
2. Настройка среды компиляции: На машине разработки необходимо установить различные пакеты ПО и инструменты. Подробности см. в разделе о среде разработки для получения информации о проверенных версиях операционной системы TinaLinux, библиотеках, от которых зависит компиляция, и т.д.
3. Выбор устройства: Перед компиляцией исходного кода разработчикам необходимо сначала экспортировать предопределенные переменные окружения, затем в соответствии с потребностями разработчика выбрать соответствующую аппаратную платформу. Подробности см. в разделе компиляции.
4. Настройка системы: Разработчики могут в соответствии с используемой аппаратной платой и определением продукта настроить U-Boot, Kernel и Openwrt. См. описание соответствующих руководств по разработке и конфигурации в последующих разделах.
5. Компиляция и упаковка: После выбора устройства и настройки системы выполните команду компиляции, включая полную или модульную компиляцию, а также очистку компиляции. Далее сгенерированные двоичные файлы boot/ядра, корневую файловую систему упакуйте в прошивку в определенном формате. Подробности см. в разделе компиляции и упаковки.
6. Запись и запуск: После генерации файла образа будет описано, как записать образ и запустить его на аппаратном устройстве. Дополнительные сведения см. в разделе записи системы.
## 4 Среда разработки Tina

### 4.1 Обзор

В процессе разработки встраиваемых продуктов обычно есть два ключевых этапа: компиляция исходного кода и запись прошивки. Компиляция исходного кода требует предварительной подготовки

среды компиляции, а для записи прошивки требуется специальный инструмент записи, предоставляемый производителем. В этой главе в основном описывается, как настроить среду для реализации компиляции и записи Tinasdk.

### 4.2 Настройка среды компиляции

Типичная среда встраиваемой разработки включает локальный хост разработки и целевую аппаратную плату.

- Локальный хост разработки выступает в качестве сервера компиляции, должен предоставлять среду операционной системы Linux, устанавливать среду кросс-компиляции, обеспечивать обновление и загрузку кода, услуги кросс-компиляции кода для разработки ПО.
- Локальный хост разработки подключается к целевой аппаратной плате через последовательный порт или USB, может записывать скомпилированный файл образа на целевую аппаратную плату и отлаживать систему или приложения.

#### 4.2.1 Конфигурация хоста разработки

Tina Linux SDK разрабатывался и тестировался на ubuntu14.04, поэтому мы **рекомендуем использовать Ubuntu 14.04** в качестве среды хоста для компиляции исходного кода. Другие версии не были специально протестированы и могут требовать соответствующих корректировок пакетов ПО.

#### 4.2.2 Конфигурация пакетов ПО

Перед компиляцией Tina Linux SDK необходимо сначала убедиться, что на сервере компиляции установлены gcc, binutils, bzip2, flex, python, perl, make, ia32-libs, find, grep, diff, unzip, gawk, getopt, subversion, libz-dev, libc headers.

В ubuntu можно напрямую выполнить следующую команду для установки:

```
sudo apt-get install build-essential subversion git-core libncurses5-dev zlib1g-dev gawkflex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip ia32-libslib32z1 lib32z1-dev lib32stdc++6 libstdc++6 -y
```

ubuntu 16.04 и выше, выполните следующую команду для установки пакетов ПО:

```
sudo apt-get install build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip lib32z1 lib32z1-dev lib32stdc++ libstdc++6 -y libc6:i386 libstdc++6:i386 lib32ncurses5 lib32z
```



## 5 Получение системы Tina

### 5.1 Обзор

### 5.2 Получение SDK

Allwinner Tina Linux SDK публикуется через сервер кода Allwinner. Клиентам необходимо обратиться к бизнес/технической поддержке для получения прав доступа к загрузке SDK. При подаче заявки необходимо одновременно предоставить открытый ключ SSH для авторизации аутентификации на сервере. После получения авторизации можно синхронизировать код.

### 5.3 Структура SDK

Tina Linux SDK в основном состоит из системы сборки, инструментов конфигурации, цепочки инструментов, инструментов хоста, приложений для целевого устройства, документации, скриптов, ядра linux, bootloader. Ниже описаны составные компоненты в порядке директорий.

```
Tina-SDK/
    ├── build
    ├── config
    ├── Config.in
    ├── device
    ├── dl
    ├── docs
    ├── lichee
    ├── Makefile
    ├── out
    ├── package
    ├── prebuilt
    ├── rules.mk
    ├── scripts
    ├── target
    ├── tmp
    ├── toolchain
    └── tools
```

#### 5.3.1 Директория build

Директория build содержит файлы системы сборки Tina Linux. Структура этой директории в основном состоит из серии mk-файлов, написанных на основе спецификации Makefile. Основные функции:

1. Проверка соответствия текущей среды компиляции требованиям сборки Tina Linux.
2. Генерация правил компиляции пакетов хоста.
3. Генерация правил компиляции цепочки инструментов.
4. Генерация правил компиляции целевых пакетов.
5. Генерация правил компиляции ядра linux.
6. Генерация правил создания системной прошивки.

```
build/
    ├── autotools.mk
    ├── aw-upgrade.mk
    ├── board.mk
    ├── cmake.mk
    ├── config.mk
    ├── debug.mk
    ├── depends.mk
    ├── device.mk
    ├── device_table.txt
    ├── download.mk
    ├── dumpvar.mk
    ├── envsetup.sh
```

#### 5.3.2 Директория config

Директория config в основном содержит интерфейс меню конфигурации Tina Linux и некоторые фиксированные конфигурационные элементы. Меню конфигурации написано на основе спецификации mconf ядра.

```
config/
    ├── Config-build.in
    ├── Config-devel.in
    ├── Config-images.in
    ├── Config-kernel.in
    └── top_config.in
```

#### 5.3.3 Директория devices

Директория devices используется для хранения конфигурационных файлов решений, включая конфигурацию ядра, конфигурацию env, конфигурацию таблицы разделов, sys_config.fex,
board.dts и т.д.

Эти конфигурации в старых версиях сохранялись в директории target, в новых версиях перенесены в директорию device.

Обратите внимание, что defconfig по-прежнему сохраняется в директории target.

```
device/
    └── config
        ├── chips
        ├── common
        └── rootfs_tar
```

Команда быстрого перехода: cconfigs

#### 5.3.4 Директория docs

Директория docs в основном содержит документацию для разработки, написанную в формате markdown.

Эта директория больше не обновляется, пожалуйста, сверяйтесь с системной документацией на платформе обслуживания клиентов Allwinner.

```
docs/
    ├── build.md
    ├── config.md
    ├── init-scripts.md
    ├── Makefile
    ├── network.md
    ├── tina.md
    ├── wireless.md
    └── working.md
```

#### 5.3.5 Директория lichee

Директория lichee в основном содержит код bootloader, ядра, arisc, dsp и т.д.

```
lichee/
    ├── bootloader
    │ ├── uboot_2011_sunxi_spl
    │ └── uboot_2014_sunxi_spl
    ├── brandy
    │ ├── u-boot-2011.09
    │ └── u-boot-2014.07
    ├── brandy-2.0
    │ ├── spl
    │ ├── tools
    │ └── u-boot-2018
    ├── linux-3.4
    ├── linux-3.10
    ├── linux-4.4
    ├── linux-4.9
    ├── arisc
```

Команды быстрого перехода: ckernel, cboot, cboot0, carisc.

#### 5.3.6 Директория package

Директория package хранит исходный код и правила компиляции пакетов ПО для целевой машины. Директории организованы по функциям целевых пакетов ПО.

```
package/
    ├── allwinner
    ├── base-files
    ├── devel
    ├── dragonst
    ├── firmware
    ├── kernel
    ├── ......
    └── utils
```

#### 5.3.7 Директория prebuilt

Директория prebuild содержит предварительно скомпилированные кросс-компиляторы. Структура директории следующая.

```
prebuilt/
    └── gcc
        └── linux-x86
            ├── aarch64
            │   ├── toolchain-sunxi-musl
            │   └── toolchain-sunxi-glibc
            ├── arm
            │   ├── toolchain-sunxi-arm9-glibc
            │   ├── toolchain-sunxi-arm9-musl
            │   ├── toolchain-sunxi-glibc
            │   ├── toolchain-sunxi-musl
            └── host
            └── host-toolchain.txt
```

#### 5.3.8 Директория scripts

Директория scripts используется для хранения скриптов, связанных со сборкой и компиляцией.

```
scripts/
    ├── arm-magic.sh
    ├── brcmImage.pl
    ├── bundle-libraries.sh
    ├── checkpatch.pl
    ├── clang-gcc-wrapper
    ├── cleanfile
    ├── clean-package.sh
    ├── cleanpatch
    ├── ......
```

#### 5.3.9 Директория target

Директория target используется для хранения конфигураций, связанных с целевой платой, а также спецификаций генерации sdk и toolchain.


```
target/
    ├── allwinner
    ├── Config.in
    ├── imagebuilder
    ├── Makefile
    ├── sdk
    └── toolchain
```

Команда быстрого перехода: cdevice.

#### 5.3.10 Директория toolchain

Директория toolchain содержит конфигурацию и правила сборки кросс-цепочки инструментов.

```
toolchain/
    ├── binutils
    ├── Config.in
    ├── fortify-headers
    ├── gcc
    ├── gdb
    ├── glibc
    ├── info.mk
    ├── insight
    ├── kernel-headers
    ├── Makefile
    ├── musl
    └── wrapper
```

#### 5.3.11 Директория tools

Директория tools используется для хранения правил компиляции инструментов хоста.

```
tools/
    ├── autoconf
    ├── automake
    ├── aw_tools
    ├── b43-tools
    ├── ......
```

#### 5.3.12 Директория out

Директория out используется для хранения временных файлов, связанных с компиляцией, и итоговых файлов образа. Эта директория автоматически генерируется после компиляции, например, компиляция решения
r328s2-perf1.

```
out/
    ├── r328s2-perf
    └── host
```

Директория host используется для хранения инструментов хоста и некоторых файлов, связанных с разработкой.

Директория r328s2-perf1 - это директория, соответствующая решению. Структура директории решения следующая:

```
out/r328s2-perf
    ├── boot.img
    ├── compile_dir
    ├── image
    ├── md5sums
    ├── packages
    ├── r328s2-perf1-boot.img
    ├── r328s2-perf1-uImage
    ├── r328s2-perf1-zImage
    ├── rootfs.img
    ├── sha256sums
    ├── staging_dir
    └── tina_r328s2-perf1_uart0.img
```

- boot.img - это данные, в конечном итоге записываемые в раздел boot системы, может быть в формате boot.img или uImage.
- rootfs.img - это данные, в конечном итоге записываемые в раздел rootfs системы. Этот раздел по умолчанию в формате squashfs.
- r328s2-perf1-zImage - образ ядра в формате zImage, используется для дальнейшей генерации uImage.
- r328s2-perf1-uImage - образ ядра в формате uImage. Если настроен формат uImage, будет скопирован в boot.img.
- r328s2-perf1-boot.img - образ ядра в формате boot.img. Если настроен формат boot.img, будет скопирован в boot.img
- compile_dir - директория временных файлов компиляции sdk для host, target и toolchain, содержит исходный код различных пакетов ПО.
- staging_dir - директория, в которой sdk сохраняет результаты каждой директории в процессе компиляции.
- директория packages сохраняет итоговые сгенерированные пакеты ipk.
- tina_r328s2-perf1_uart0.img - итоговый пакет прошивки (образ системы), информация последовательного порта выводится через последовательный порт
- При использовании pack -d сгенерированный пакет прошивки будет xxx_card0.img, информация последовательного порта перенаправляется на выход гнезда TF-карты.

Команда быстрого перехода: cout.

### 5.4 Обновление SDK

Обновление SDK делится на два типа: один тип публикуется в виде патчей на портале, после публикации система уведомляет разработчиков по электронной почте; другой тип - это периодическая (полугодовая или ежеквартальная) итерация малых версий, патчи объединяются в SDK, после публикации разработчики уведомляются системным письмом. Можно обновить на основе чистого пакета SDK с помощью команды repo sync.

### 5.5 Обратная связь о проблемах

Allwinner предоставляет платформу обслуживания клиентов Allwinner (https://open.allwinnertech.com) для регистрации проблем клиентов и статуса их решения. Это удобно для отслеживания обеими сторонами и делает обработку проблем более эффективной. Последующие проблемы SDK

, технические вопросы, технические консультации и т.д. можно отправлять в эту систему. Служба технической поддержки Allwinner своевременно распределит, обработает и отследит проблемы.

Примечание: Для входа в систему требуется подтвердить учетную запись с Allwinner.

## 6 Компиляция и упаковка Tina

### 6.1 Обзор

### 6.2 Компиляция системы

```
(1) source build/envsetup.sh
(2) lunch
(3) make [-jN]
(4) pack [-d]

Где,
Шаг (1) устанавливает среду компиляции, экспортирует переменные компиляции.
Шаг (2) предлагает выбрать решение, которое вы хотите скомпилировать.
Шаг (3) параметр N - количество параллельных процессов компиляции, зависит от количества ядер процессора сервера компиляции, например, для 4-ядерного ПК можно "make -j4"
Шаг (4) упаковка прошивки, параметр -d делает информацию последовательного порта сгенерированного пакета прошивки переключенной на выход гнезда TF-карты.
После завершения компиляции образ системы будет упакован в директории out/<board>/
```

### 6.3 Компиляция boot

| Команда | Действительная директория команды | Действие |
| :----- | :------------- | :--------------- |
| mboot  | любая директория tina | Компиляция boot0 и uboot |
| mboot0 | любая директория tina | Компиляция boot0 |
| muboot | любая директория tina | Компиляция uboot |

### 6.4 Компиляция ядра

| Команда | Действительная директория команды | Действие |
| :------ | :------------- | :------- |
| mkernel | любая директория tina | Компиляция ядра |

### 6.5 Компиляция arisc

arisc - это название среды кода cpus на платформе AW. Основная функция - управление низкоуровневыми операциями, такими как спящий режим, выключение и т.д. Включает
драйверы, библиотеки и цепочку инструментов, необходимые для работы cpus. При компиляции генерируется scp.bin, который затем упаковывается в образ Tina. Bootloader
загружает его в домен cpus для выполнения при запуске.

Tina предоставляет следующие команды перехода и компиляции, связанные с arisc


| Команда | Действительная директория команды | Действие |
| :------ | :------------- | :--------------------- |
| carisc  | любая директория tina | Переход в директорию проекта кода cpus |
| mkarisc | любая директория tina | Компиляция кода cpus |

В Tina есть два способа компиляции кода arisc, как показано ниже:

Первый способ: перейти в путь кода arisc и использовать make для компиляции

Репозиторий кода arisc имеет независимую цепочку инструментов и систему сборки, поэтому компиляцию кода arisc также можно выполнить, перейдя cd в соответствующий путь
и выполнив команду make. Но обратите внимание, что в этом случае необходимо вручную скопировать сгенерированный файл scp.bin в путь файла bin
SDK, перезаписав соответствующий файл (обычно путь - tina/device/config/chips/${название платформы}/bin).

Операции следующие:

```
step1
Используйте команду carisc или cd для перехода в среду кода arisc, обычно tina/lichee/arisc/ar100s.

step2
Создайте необходимую конфигурацию. В arch/configs/ находится множество файлов конфигурации defconfig по умолчанию, можно выбрать в соответствии с моделью AXP, например, make sun50iw10p1_axp803_defconfig. Эта операция создаст .config в корневой директории arisc.

step3
Изменение конфигурации по умолчанию можно выполнить с помощью make menuconfig. Эта операция создаст меню конфигурации, выберите конфигурацию по необходимости. Эта операция изменит .config. Если нужно повторно использовать конфигурацию по умолчанию, повторно выполните step2.

step4
Используйте команду make для компиляции

step5
Скопируйте scp.bin в директорию bin Tina, т.е. директорию, в которую можно перейти с помощью cbin. Например, /tina/device/config/chips/r818/binstep6

Если нужно очистить проект, можно использовать make clean

step7
Если нужно отправить изменение конфигурации defconfig, можно использовать команду make savedefconfig. Эта команда создаст defconfig в корневой директории arisc на основе .config. Скопируйте defconfig в arch/configs/ и перезапишите соответствующий файл конфигурации.
```

Примечание:

Как правило, функции, выполняемые arisc, достаточно низкоуровневые, в основном связаны с операциями, такими как спящий режим, выключение и т.д., требования к стабильности высоки. Мы не
рекомендуем клиентам самостоятельно изменять какие-либо связанные конфигурации и код. Если необходимо, пожалуйста, свяжитесь с нашей компанией или выполните достаточное тестирование стабильности.

Второй способ: использование команды mkarisc

Как описано в вышеуказанном методе, для решения проблемы необходимости ручного копирования после компиляции arisc, Tina предоставляет эту быструю команду
mkarisc. Следует отметить: в настоящее время поддерживается только компиляция кода arisc для R818, MR813.


Операции следующие, довольно просты

```
step1
Настройте среду tina, например, soure build/envsetup.sh, lunch и т.д.

step2
Используйте mkarisc для компиляции или напрямую скомпилируйте Tina. При компиляции Tina также автоматически вызовется команда mkarisc.
```

Примечание:

При использовании команды mkarisc для компиляции автоматически считывается board.dts для получения модели AXP, затем используется соответствующий файл конфигурации по умолчанию
для компиляции. Когда в board.dts указано использование "x-powers,axp803", команда mkarsic будет использовать конфигурационный файл sun50iw10p1_axp803_defconfig в среде проекта arisc
для компиляции. В этом случае, если вам нужно изменить конфигурацию arisc,
можно только сначала изменить этот файл конфигурации, а затем скомпилировать. Кроме этого, другие способы изменения конфигурации не принимаются.

### 6.6 Компиляция прошивки E907 (гетерогенное AMP ядро платформы V85x)

E907 - это название AMP CPU платформы V85x. Его основные функции - предоставление дополнительных вычислительных мощностей общего назначения, помощь Linux в реализации быстрого запуска
и т.д. Включает драйверы, библиотеки и цепочку инструментов, необходимые для работы E907. При компиляции генерируется riscv.fex, упаковывается в образ Tina,
загружается bootloader на ядро RISC-V для выполнения при запуске.

В Tina SDK компиляция кода E907 RISCV следующая:

Репозиторий кода E907 RISCV имеет независимую цепочку инструментов и систему сборки, поэтому компиляцию прошивки E907 также можно выполнить, перейдя
в соответствующий путь и выполнив команды. Но обратите внимание, что в этом случае необходимо вручную скопировать сгенерированный файл melis30.elf в путь файла bin
SDK, перезаписав соответствующий файл (обычно путь - device/config/chips/${название платформы
}/configs/default/riscv.fex).

Операции следующие:

```
step1
Используйте команду cd для перехода в среду кода e907, обычно rtos-dev/lichee/melis-v3.0/source

step2
source melis-env.sh

step3
lunch v853-e907-ver1-board

step4
make menuconfig

step5
make -j

step6
Если нужно уменьшить объем хранения, можно удалить отладочную информацию, выполнив в директории melis source: riscv64-unknown-elf-strip ekernel/melis30.elf

step7
Скопируйте и переименуйте в riscv.fex, заменив riscv.fex в директории tina/device/config/chips/v853/configs/default

cp ekernel/melis30.elf /home/xxx/tina/device/config/chips/v853/configs/default/riscv.fex

step8
Выполните команду упаковки pack в директории системы Tina
```

### 6.7 Перекомпиляция приложения

Пожалуйста, убедитесь, что была выполнена компиляция прошивки хотя бы один раз, чтобы убедиться, что основа SDK скомпилирована, только тогда можно отдельно перекомпилировать пакеты приложений. Сценарий использования перекомпиляции пакетов приложений обычно следующий: изменено только приложение, не хочется перезаписывать прошивку, необходимо только установить установочный пакет приложения. Пожалуйста, убедитесь, что перед компиляцией загружена среда tina:

```
$ source build/envsetup.sh
$ lunch
```

#### 6.7.1 Метод один

Когда вы находитесь в директории пакета приложения (включая поддиректории), можно выполнить

```
$ mm [-B]
=> параметр B сначала очистит временные файлы этого приложения, затем скомпилирует
```

Пример: Предположим, путь к пакету ПО: tina/package/utils/rwcheck, тогда:

```
$ cd tina/package/utils/rwcheck
$ mm -B
```

Скомпилированный установочный пакет приложения сохраняется в:

```
tina/out/<решение>/packages/base
```

#### 6.7.2 Метод два

Когда вы находитесь в корневой директории tina, можно выполнить:

```
$ make <путь к пакету приложения>/clean, ==>очистить временные файлы пакета приложения
$ make <путь к пакету приложения>/install, ==>скомпилировать пакет ПО
или
$ make <путь к пакету приложения>/{clean,install}, ==>сначала очистить временные файлы, затем скомпилировать
```

Пример: Предположим, путь к пакету ПО: tina/package/utils/rwcheck, тогда:

```
$ cd tina
$ make package/utils/rwcheck/{clean,install}
```

### 6.8 Другие команды


| Команда | Действительная директория команды | Действие |
| :----------- | :--------------------------------------------------------- | :--- |
| make | корневая директория tina Компиляция всего sdk | |
| make | menuconfig корневая директория tina Запуск интерфейса конфигурации пакетов ПО | |
| make | kernel_menuconfig корневая директория tina Запуск интерфейса конфигурации ядра | |
| mkarisc | любая директория tina Компиляция исходного кода cpus, выбор соответствующей конфигурации по умолчанию в соответствии с моделью AXP | |
| printfconfig | любая директория tina Печать текущей конфигурации SDK | |
| croot | любая директория tina Быстрое переключение в корневую директорию tina | |
| cconfigs | любая директория tina Быстрое переключение в директорию конфигурации bsp решения | |
| cdevice | любая директория tina Быстрое переключение в директорию конфигурации решения | |
| carisc | любая директория tina Быстрое переключение в директорию кода cpus | |
| cgeneric | любая директория tina Быстрое переключение в директорию generic решения | |
| cout | любая директория tina Быстрое переключение в выходную директорию решения | |
| cboot | любая директория tina Быстрое переключение в директорию bootloader | |
| cgrep | любая директория tina Поиск строки в файлах c/c++/h | |
| minstall | path/to/package/ корневая директория tina Компиляция и установка пакета ПО | |
| mclean | path/to/package/ корневая директория tina Очистка пакета ПО | |
| mm [-B] | директория пакета ПО Компиляция пакета ПО, -B означает сначала очистить перед компиляцией | |
| pack | корневая директория tina Упаковка прошивки | |
| m | любая директория tina Быстрая команда make, компиляция всего sdk | |
| p | любая директория tina Быстрая команда pack, упаковка прошивки | |


## 7 Запись системы Tina

### 7.1 Обзор

В этом разделе в основном описывается процесс записи и запуска построенного файла образа (image) на аппаратном устройстве.

Инструменты записи в SDK больше не обновляются и будут удалены в будущем. Пожалуйста, предпочтительно скачивайте последние инструменты записи с платформы обслуживания клиентов Allwinner.

Инструменты для Windows все интегрированы в APST. Скачайте и установите APST. Все инструменты APST поставляются с документацией.

### 7.2 Инструменты записи

Несколько инструментов записи образов, предоставляемых Tina, описаны в таблице. Пользователи могут выбрать подходящий способ записи.


| Инструмент | Операционная система | Описание |
| :------------ | :------- | :------------------------------- |
| PhoenixSuit | windows | Инструмент обновления по разделам и полного обновления прошивки |
| PhoenixCard | windows | Инструмент создания прошивки для карты |
| PhoenixUSBpro | windows | Инструмент массового обновления, поддерживает запись USB один к 8 |
| LiveSuit | ubuntu | Инструмент обновления прошивки |

Для ubuntu:

- 64-битный хост использует LiveSuitV306_For_Linux64.zip.
- 32-битный хост использует LiveSuitV306_For_Linux32.zip.

Конкретные инструменты записи и инструкции по использованию, пожалуйста, скачайте с платформы обслуживания клиентов Allwinner.

### 7.3 Вход в режим записи

Устройство должно войти в режим записи. В следующих случаях устройство войдет в режим записи:

1. BROM не может прочитать boot0, например, только что замененная флеш-память не содержит данных или при включении питания флеш-память замкнута, блокируя связь.
2. В последовательном порту нажать 2 для входа в запись. То есть, в окне вывода инструмента последовательного порта, удерживая клавишу '2' на клавиатуре, непрерывно выводя символ '2', включить питание. boot0 обнаружит этот символ и перейдет в режим записи.
3. В консоли uboot выполнить efex.
4. В консоли linux выполнить reboot efex.
5. Когда доступен adb, можно использовать adb shell reboot efex или нажать кнопку "Немедленная запись" в инструменте записи.
6. Когда полностью настроены fel_key_max и fel_key_min в [fel_key], нажмите клавишу со значением в диапазоне, затем включите питание.
7. Когда на плате есть кнопка FEL, нажмите и удерживайте кнопку FEL при включении питания.
8. Создайте специальную загрузочную карту, загрузитесь с карты, затем войдите в режим записи.
## 8 Настройка и разработка Tina uboot

### 8.1 Обзор

В этом разделе кратко описаны базовая конфигурация uboot, урезание функций, компиляция и упаковка, использование общих команд, чтобы помочь клиентам понять фреймворк uboot платформы Tina
и предоставить основу для настройки и разработки boot.

В настоящее время Tina SDK имеет три версии uboot: uboot-2011, uboot-2014, uboot-2018, которые используются на разных аппаратных платформах. Клиентам, получившим SDK, необходимо сверить информацию о версии в соответствии с разрабатываемой аппаратной платформой.

### 8.2 Путь к коду

```
TinaSDK/
├── brandy
│   ├── ...
│   ├── u-boot-2011
│   └── u-boot-2014
├── brandy-2.0
│   ├── ...
│   └── u-boot-2018
```

### 8.3 Функции uboot

В TinaSDK bootloader/uboot выполняется до запуска ядра, может инициализировать аппаратные устройства, устанавливать карту отображения пространства памяти,
тем самым приводя программно-аппаратную среду системы в подходящее состояние, подготавливая правильную среду для окончательного вызова ядра linux.
На системной платформе Tina, помимо обязательной функции загрузки системы, uboot также предоставляет другие функции, такие как запись, обновление и т.д.

- Загрузка ядра может загружать образ ядра с носителя данных (nand/mmc/spinor) в указанное место DRAM и запускать его.
- Массовое производство и обновление включают массовое производство с карты, массовое производство USB, запись приватных данных, обновление прошивки.
- Управление питанием включает логику управления при входе в режим зарядки и экран отображения при зарядке.
- Информация при загрузке при загрузке может отображать изображение логотипа запуска (формат BMP).
- Функция Fastboot реализует стандартные команды fastboot, позволяет использовать fastboot для прошивки.


### 8.4 Конфигурация uboot

На примере uboot-2018, различные функции можно включить или отключить через defconfig или меню конфигурации menuconfig.
Конкретные методы конфигурации следующие:

#### 8.4.1 Способ defconfig

##### 8.4.1.1 Шаги конфигурации defconfig

1. vim /TinaSDK/lichee/brandy2.0/u-boot-2018/configs/sun8iw18p1_defconfig (если это решение spinor, откройте sun8iw18p1_nor_defconfig)
2. После открытия sun8iw18p1_defconfig или sun8iw18p1_nor_defconfig, удалите или добавьте "#" перед соответствующим определением макроса, чтобы включить или отключить соответствующую функцию.


![Рисунок 8-1: Конфигурация defconfig](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-1.jpg)

Как показано на рисунке выше, достаточно убрать # перед CONFIG_SUNXI_NAND, чтобы поддерживать функциональность NAND. Включение и отключение других определений макросов аналогично.

##### 8.4.1.2 Введение в макросы конфигурации defconfig

Ниже приведено введение в базовые определения макросов в sun8iw18p1_defconfig/sun8iw18p1_nor_defconfig:


![Рисунок 8-2: Введение в базовые определения макросов defconfig](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-2.jpg)

#### 8.4.2 Способ menuconfig

Метод конфигурации через menuconfig следующий:

```
cd /TinaSDK/lichee/brandy2.0/u-boot-2018/
make ARCH=arm menuconfig или make ARCH=arm64 menuconfig

Примечание: arm для 32-битной платформы, arm64 для 64-битной платформы.
```

После выполнения вышеуказанных команд появится меню конфигурации menuconfig, как показано на рисунке ниже. В этот момент можно настроить функции различных модулей.
Метод конфигурации описан в окне меню конфигурации menuconfig.


![Рисунок 8-3: Меню конфигурации menuconfig](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-3.jpg)

### 8.5 Компиляция uboot

#### 8.5.1 Метод один

В директории tina можно скомпилировать uboot.

```
source build/envsetup.sh(см. примечание 1)
lunch (см. примечание 2)
muboot(см. примечание 3)
Примечания:
1 Загрузка переменных окружения и команд, предоставляемых tina.
2 Введите номер, выберите решение.
3 Компиляция uboot. После завершения компиляции автоматически обновляется двоичный файл uboot в TinaSDK/target/allwinner/$(BOARD)-common/bin/.
```

#### 8.5.2 Метод два

```
source build/envsetup.sh(см. примечание 1)
lunch (см. примечание 2)
cboot(см. примечание 3)
make XXX_config(см. примечание 4)
make -j

Примечания:
3 Переход в директорию исходного кода Uboot.
4 Выбор конфигурации решения. Если используется norflash, выполните make XXX_nor_config.
5 Выполнение компиляции uboot.
```

### 8.6 Конфигурация uboot

#### 8.6.1 Конфигурация sys_config

sys_config.fex - это важный файл для конфигурации параметров различных модулей, предоставляющий большое удобство для изменения и обновления важных параметров каждого модуля. Путь к его документу:

```
TinaSDK/target/allwinner/$(BOARD)/configs/sys_config.fex
TinaSDK/device/config/chips/$(CHIP)/configs/$(BOARD)/sys_config.fex
```

##### 8.6.1.1 Введение в структуру sys_config.fex

sys_config.fes в основном состоит из главных ключей и подключей. Главный ключ - это главный идентификатор определенной функции или модуля, заключенный в []. Подключи - это элементы конфигурации параметров этой функции или модуля. Как показано на рисунке ниже, dram_para - это главный ключ, dram_clk, dram_type
и dram_zp - подключи.

![Рисунок 8-4: Базовая структура sysconfig.fex](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-4.jpg)


##### 8.6.1.2 Примеры конфигурации sys_config.fex

[platform]: элементы конфигурации, связанные с платформой.

![Рисунок 8-5: Конфигурация platform](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-5.jpg)

Например, debug_mode =1 означает включение режима отладки uboot. После включения в логе будут выводиться соответствующие отладочные сообщения
. next_work=2 означает следующее действие системы после завершения записи (0x1 означает нормальный запуск, 0x2 означает перезапуск,
0x3 означает выключение). Другие конфигурации можно посмотреть в подсказках перед [platform].

[target]: элементы конфигурации функций, связанных с целевой платформой

![Рисунок 8-6: Конфигурация target](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-6.jpg)

На рисунке выше можно настроить частоту cpu через конфигурацию boot_clock.

[uart_para]: элемент конфигурации последовательного порта. Элемент конфигурации uart_para - это важная конфигурация, используемая при отладке вывода последовательного порта uboot


![Рисунок 8-7: Конфигурация uart_para](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-7.jpg)


uart_debug_port=0 на рисунке выше означает использование uart0. uart_debug_tx/uart_debug_rx настроенные выводы GPIO (PA04/PA05) необходимо настроить в соответствии с GPIO DATASHEET.

##### 8.6.1.3 Процесс анализа sys_config.fex

В uboot2014/2018 sys_config.fex в конечном итоге преобразуется в dtb (device tree binary, способ конфигурации ядра linux). dtb в конечном итоге упаковывается и записывается во флеш-память. В процессе загрузки этот файл загружается в память. Ранее настроенные в sys_config.fex параметры преобразованы в узлы dtb. В конце концов будет вызвана функция fdt_getprop_32() для анализа узлов в dtb.

#### 8.6.2 Конфигурация переменных окружения

Переменные окружения uboot - это пары ключ-значение. Интерфейсы операций: getenv(), setenv(), saveenv(). Форма переменных окружения:


```
boot_normal=sunxi_flash read 40007800 boot;boota 4000780\
boot_recovery=sunxi_flash read 40007800 recovery;boota 40007800\
boot_fastboot= fastboot
```

##### 8.6.2.1 Роль переменных окружения

Можно определить некоторую информацию о параметрах или последовательности команд в переменных окружения. Определив последовательность команд UBOOT в переменных окружения,

можно комбинировать различные функциональные модули UBOOT в порядке для выполнения, тем самым завершая какую-то важную функцию.

Например, если выполнить последовательность команд, соответствующую упомянутой выше переменной окружения boot_normal, Uboot сначала вызовет
команду sunxi_flash для загрузки ядра из раздела boot носителя данных в позицию 0x40007800 DRAM; затем вызовет
команду boota для завершения загрузки ядра.

Способ вызова переменных окружения при запуске uboot показан на рисунке ниже:


![Рисунок 8-8: Способ вызова переменных окружения при запуске uboot](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-8.jpg)


##### 8.6.2.2 Введение в примеры конфигурации переменных окружения

В TinaSDK файл конфигурации переменных окружения сохраняется в TinaSDK/target/allwinner/$(BOARD)/configs/env.cfg
. При использовании пользователи могут увидеть файлы env-4.4.cfg, env-4.9.cfg и т.д. Суффикс env-xxx с цифрами означает конфигурацию для разных версий ядра. После открытия содержимое примера следующее:

- bootdelay=0, изменение значения переменной окружения bootdelay (т.е. время задержки обратного отсчета в логе при загрузке boot). Для удобства отладки значение bootdelay обычно не должно быть равно 0, чтобы после включения питания устройства нажатие любой клавиши могло войти в состояние shell-команд uboot.
- boot_normal=sunxi_flash read 40007800 boot;boota 4000780, установка команды запуска ядра, т.е. чтение раздела boot в адрес памяти 0x40007800, затем запуск ядра с адреса памяти 0x40007800.
- Setargs_nand=setenv bootargs earlyprintk=${earlyprink}....... , установка переменных окружения, связанных с ядром. Эта переменная будет выведена в логе при запуске ядра, т.е. cmdline, как показано на рисунке ниже:


![Рисунок 8-9: kernel cmdline](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-8-9.jpg)


- loglevel=8, установка уровня вывода лога ядра.


#### 8.6.3 Конфигурация разделов sys_partition.fex

Файл конфигурации разделов - это файл планирования разделов диска. В процессе записи данные каждого раздела будут записаны во флеш-память в соответствии с этим файлом конфигурации разделов.

В TinaSDK путь к файлу конфигурации разделов TinaSDK/target/allwinner/$(BOARD)/configs/sys_partition.fex. В некоторых решениях можно увидеть два файла конфигурации разделов: sys_partition.fex, sys_partition_nor.fex. Если упаковывается не nor прошивка Tina, используется файл конфигурации sys_partition_linux.fex. Если упаковывается nor прошивка, используется sys_partition_nor.fex.

##### 8.6.3.1 Введение в конфигурацию разделов sys_partition.fex

Атрибуты раздела включают название, размер раздела, загружаемый файл и пользовательские атрибуты. Ниже приведены атрибуты раздела, описанные в файле:

- name, название раздела определяется пользователем. При определении раздела пользователь может изменить это на желаемую строку, но длина не может превышать 16 байт.
- size, определяет размер этого раздела в единицах секторов (1 сектор=512 байт. Как показано на рисунке выше, разделу env выделено 32768 секторов, т.е. 32768*512/1024/1024 = 16M). Обратите внимание, что для выравнивания байтов размер выделенных секторов должен делиться на 128.
- downloadfile, путь и название загружаемого файла. Можно использовать относительный путь, относительно расположения файла image.cfg. Также можно использовать абсолютный путь.
- user_type, атрибут, предоставляемый для использования операционной системой. В настоящее время каждая операционная система при чтении раздела будет судить по пользовательским атрибутам, принадлежит ли текущий раздел ей, и только тогда выполнит операцию. Цель такого дизайна - избежать ситуации, когда при одновременном существовании нескольких систем операционная система A выполнит неправомерные операции чтения и записи в системный раздел операционной системы B, что приведет к невозможности нормальной работы операционной системы B.


Более подробные объяснения см. в "Руководстве по разработке управления хранением TinaLinux".


## 9 Настройка и разработка Tina kernel

### 9.1 Обзор

В этом разделе кратко описаны базовая конфигурация kernel, урезание функций, использование общих команд, чтобы помочь клиентам понять ядро linux платформы Tina
и предоставить основу для настройки и разработки ядра.

В настоящее время Tina SDK имеет 4 версии linux kernel: linux-3.4, linux-3.10, linux-4.4, linux-
4.9, которые используются на разных аппаратных платформах. Клиентам, получившим SDK, необходимо сверить информацию о ядре в соответствии с разрабатываемой аппаратной платформой.

### 9.2 Путь к коду

```
TinaSDK/
    ├── ...
    ├── linux-3.10
    ├── linux-3.4
    ├── linux-4.4
    └── linux-4.9
```

### 9.3 Документация по разработке модулей

Подробности см. в документации по разработке BSP. Директория документации включает инструкции по использованию и разработке общих модулей ядра.

### 9.4 Конфигурация ядра

При настройке продуктов клиентам обычно необходимо изменить конфигурацию ядра linux. В TinaSDK способ открытия конфигурации ядра следующий:

```
croot
make kernel_menuconfig
```

После выполнения в консоли shell появится меню конфигурации. Как показано на рисунке ниже:


![Рисунок 9-1: Меню конфигурации ядра TinaLinux](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-9-1.jpg)
## 10 Настройка и разработка системы Tina

### 10.1 Переключение Tina procd-init и busybox-init

tina по умолчанию использует procd-init:

```
Конфигурация через make menuconfig:
1.System init выберите procd-init

2.Последовательно выберите следующее
Base system --->
    <*>block-mount
    <*>busybox................................ Core utilities for embedded Linux --->
        Init Utilities --->
            [ ] init здесь не выбирать
        Coreutils --->
            [*] head
        Miscellaneous Utilities --->
            [*] strings
    <*> uci
    <*> logd

3.Изменение env.cfg
init=/sbin/init
```

Конфигурация метода автозапуска busybox-init следующая:

```
Конфигурация через make menuconfig:
1.System init выберите busy-init

2.Последовательно выберите следующее
Base system --->
    <*>busybox................................ Core utilities for embedded Linux --->
    Init Utilities --->
    [* ] init здесь выбрать

3.Изменение env.cfg
    init=/init
    rdinit=/rdinit
```

## 10.2 Портирование приложений

В Tina Linux SDK директория пакета ПО обычно содержит следующие две директории и один файл:

```
package/<категория>/<название пакета>/Makefile
package/<категория>/<название пакета>/patches/ [опционально]
package/<категория>/<название пакета>/files/ [опционально]
Где,
patches сохраняет файлы патчей, перед компиляцией автоматически применятся все патчи к исходному коду
files сохраняет исходный код пакета ПО, при компиляции соответствующий исходный код перезапишет исходные файлы в исходном коде
Makefile файл правил компиляции,
```

### 10.2.1 Пример Makefile

Функция этого Makefile - **процесс подготовки, компиляции и установки исходного кода ПО, предоставление интерфейса для идентификации и управления пакетами ПО Tina Linux**. Логика компиляции ПО определяется собственным Makefile ПО, теоретически не имеет существенной связи с этим Makefile (этот Makefile только выполняет команду make и соответствующие параметры).

![Рисунок 10-2-1](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-10-2-1.jpg)

Примечания:

```
1.Если это ПО с открытым исходным кодом, рекомендуется, чтобы версия пакета ПО совпадала с версией загруженного пакета ПО.
2.Переменные, начинающиеся с PKG, в основном сообщают системе сборки, откуда загружать пакет ПО.
3.md5sum используется для проверки корректности загруженного пакета ПО. Если корректно, при компиляции этого ПО в PKG_BUILD_DIR можно найти исходный код этого пакета ПО.
4.Package/<name>: <name> используется для указания имени этого Package, это имя будет отображаться в системе конфигурации.
5.Используйте имя пакета зависимости <name> для указания зависимостей. Если это пакет расширения, добавьте "+" впереди. Если это зависимость версии ядра, используйте @LINUX_2_<minor version>.
6.Если это значение равно 1, этот пакет не появится в меню конфигурации, но будет скомпилирован как фиксированный, опционально.
7.В ПО с открытым исходным кодом обычно используется для генерации Makefile, параметры можно передать через CONFIGURE_VARS.
8.В ПО с открытым исходным кодом обычно эквивалентно выполнению make, можно использовать два параметра: MAKE_FLAGS и MAKE_VARS.
9.Встроенные ключевые слова следующие:
    INSTALL_DIR эквивалентно install -d m0755
    INSTALL_BIN эквивалентно install -m0755
    INSTALL_DATA эквивалентно install -m0644
    INSTALL_CONF эквивалентно install -m0600
10.Все части define этого Makefile - это определения для параметров этого макроса. Верхний уровень Makefile компилируется через вызов этого макроса.
```

### 10.2.2 Настройка автозапуска

В Tina Linux поддерживаются два формата скриптов инициализации: один - это скрипт инициализации в стиле busybox или sysV,
другой - скрипт инициализации в стиле procd. Обычно мы называем **приложения, запускаемые скриптами инициализации, службами**.

Скрипты инициализации организованы на языке программирования shell-скриптов. Знания shell-скриптов не будут здесь раскрыты как базовые знания. Обычно
исходный код скриптов инициализации сохраняется в директории files ПО с суффиксом ".init", например:

```
tina/package/system/fstools/files/fstab.init
```

В install Makefile устанавливается скрипт инициализации в /etc/init.d на устройстве, например:

```
define Package/block-mount/install
$(INSTALL_DIR) $(1)/etc/init.d/
$(INSTALL_BIN) ./files/fstab.init $(1)/etc/init.d/fstab
endef
```

#### 10.2.2.1 Вызов скрипта автозапуска

- При ручном вызове при запуске будет слишком много логов, и информация лога уже собирается демоном logd, что неудобно для отладки скрипта инициализации. В этом случае можно отлаживать через ручной вызов из командной строки на устройстве, например:

```
root@TinaLinux: /# /etc/init.d/fstab start
```

#### 10.2.2.2 Скрипт формата sysV

Скрипт инициализации в стиле sysV сохраняется в директории /etc/init.d/ на устройстве для реализации автозапуска при загрузке. Ниже приведен пример скрипта инициализации с минимальным содержимым для объяснения. Суть в реализации функций start/stop:


```
#!/bin/sh /etc/rc.common
# Example script
# Copyright (C) 2007 OpenWrt.org
START=10
STOP=15
DEPEND=xxxx
start() {
#commands to launch application
}
stop() {
#commands to kill application
}
Примечание:
START=10, указывает приоритет запуска при загрузке (последовательность) [чем меньше значение, тем раньше запуск], диапазон значений 0-99.
STOP=15, указывает приоритет остановки при выключении (последовательность) [чем меньше значение, тем раньше остановка], диапазон значений 0-99.
DEPEND=xxxx, указывает, что скрипты инициализации будут выполняться параллельно, через эту конфигурацию обеспечивается зависимость выполнения.
```

| Название | Атрибут | Функция |
| :------ | :------- | :----------- |
| start | обязательна к реализации | Запуск службы |
| stop | обязательна к реализации | Остановка службы |
| reload | опционально к реализации | Перезапуск службы |
| enable | опционально к реализации | Перезагрузка службы |
| disable | опционально к реализации | Отключение службы |


В shell можно использовать следующие команды для управления соответствующими службами.

```
$ root@TinaLinux:/# /etc/init.d/exmple restart|start|stop|reload|enable|disable
```

#### 10.2.2.3 Скрипт формата procd

Ниже приведен пример скрипта инициализации для объяснения. Основное - реализация функции start_service:

```
#!/bin/sh /etc/rc.common
USE_PROCD=1
PROG=xxxx
START=10
STOP=15
DEPEND=xxxx
start_service() {
procd_open_instance
procd_set_param command $PROG -f
......
procd_close_instance
}
```

Подробное введение см. на: https://wiki.openwrt.org/inbox/procd-init-scripts.

## 10.3 Отладка приложений

Новый добавленный пакет ПО по умолчанию настроен как отключенный. В этом случае необходимо вручную включить пакет ПО. Через выполнение
make menuconfig в корневой директории tina войдите в интерфейс конфигурации пакетов ПО:

![Рисунок 10-1: Главный интерфейс конфигурации приложений](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-10-1.jpg)

Путь к пакету ПО связан с определением в Makefile пакета ПО. На примере fstools, в Makefile определено
как:

```
define Package/fstools
    SECTION:=base
    CATEGORY:=Base system
    DEPENDS:=+ubox +USE_GLIBC:librt +NAND_SUPPORT:ubi-utils
    TITLE:=OpenWrt filesystem tools
    MENU:=1
endef
```

В этом случае достаточно войти в Basy system в интерфейсе menuconfig, чтобы найти пакет ПО fstools.

![Рисунок 10-2: Интерфейс расположения пакета ПО](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_System_software_development_Guide-10-2.jpg)

Значение префикса:

```
[*] или<*> : скомпилировать в SDK
[ ] или< > : не включать
```

Поддерживаемые операции:

```
Y или y: выбрать для включения
N или n: отменить выбор
```

## 10.4 Компиляция приложений

См. раздел перекомпиляции приложений.

## 10.5 Установка приложений

1. Получение установочного пакета

Установочный пакет обычно находится в директории:


```
tina/out/<решение>/packages/base
```

Формат названия установочного пакета:

```
<название приложения>_<версия приложения>-<релизная версия приложения>_sunxi.ipk
```

2. Установка пакета приложения

Через adb отправьте установочный пакет на устройство:

```
$ adb push <путь к установочному пакету> <путь на устройстве>
```

Установка пакета приложения:

```
$ opkg install <путь к установочному пакету>
```

## 10.6 Разделы и монтирование

- Разделы обновления

| Раздел | Функция |
| :----------- | :----------------------------------------------------------- |
| раздел boot | Хранит образ ядра |
| раздел rootfs | Раздел образа базовой системы, включает /lib, /bin, /etc и т.д. |
| раздел recovery | Хранит образ системы восстановления, только для решений с большой емкостью, подробности см. в документации OTA |
| раздел extend | Хранит образ системы восстановления и часть usr rootfs, только для решений с малой емкостью, подробности см. в документации OTA |


- Разделы без обновления

| Раздел | Функция |
| :------------ | :--------------------------------- |
| раздел private | Раздел хранения серийного номера SN |
| раздел misc | Раздел состояния системы, состояния прошивки |
| раздел UDISK | Раздел данных пользователя, обычно монтируется в /mnt/UDISK |
| раздел overlayfs | Хранит данные наложения overlayfs |

- Точки монтирования по умолчанию

| Раздел | Точка монтирования | Примечание |
| :--------------------------- | :---------- | :-------------------- |
| /dev/by-name/boot | /boot | |
| /dev/by-name/boot-res | /boot-res | |
| /dev/by-name/UDISK | /mnt/UDISK | Раздел данных пользователя |
| /dev/mmcblk0 или /dev/mmcblk0p1 | /mnt/SDCARD | Точка монтирования TF-карты |
| /dev/by-name/rootfs_data | /overlay | Хранит данные наложения overlayfs |
