## 2 MiniGUI

### 2.1 Описание MiniGUI

В настоящее время в Tina интегрирована базовая библиотека MiniGUI 3.2 и её компоненты. В таблице ниже перечислены связанные с MiniGUI пакеты:

**Таблица 2-1: Описание пакетов MiniGUI**


| Название пакета       | Описание                                  |
| :-------------------- | :---------------------------------------- |
| cell-phone-ux-demo    | Приложение пользовательского интерфейса MiniGUI для мобильных телефонов |
| libminigui-gpl        | Базовая библиотека MiniGUI                |
| minigui-res-be        | Библиотека ресурсов MiniGUI               |
| mg-samples            | Примеры приложений MiniGUI                |
| libmdolphin           | Базовая библиотека браузера MiniGUI       |
| mdolphin-release-home | Приложение браузера MiniGUI               |
| mdolphin-release-tv   | Приложение браузера MiniGUI               |
| mdolphin-samples      | Приложение браузера MiniGUI               |
| libmg3d               | Компонент 3D интерфейса MiniGUI           |
| libmgeff              | Фреймворк анимации MiniGUI                |
| libmgi                | Компонент метода ввода MiniGUI            |
| libmgncs              | Новый набор элементов управления MiniGUI  |
| libmgp                | Компонент функции печати MiniGUI          |
| libmgplus             | Улучшенный интерфейс графического рисования MiniGUI |
| libmgutils            | Шаблоны диалоговых окон MiniGUI           |


**Таблица 2-2: Приложения на базе MiniGUI**

| Название пакета    | Описание                                                         |
| :----------------- | :--------------------------------------------------------------- |
| multimedia-test    | Демо тестирования мультимедиа, включает предпросмотр с камеры, фотосъёмку, запись видео, воспроизведение аудио, видео и просмотр изображений |
| r11-board          | Демо умной стиральной машины, включает эффекты прокрутки интерфейса, элементы выбора и другие общие функции |
| smart-music-player | Демо умного музыкального плеера, включает реализацию прокручиваемого списка, адаптирован для R328 и R329 |


Ниже представлен скриншот приложения multimedia-test:


![Рисунок 2-1: Скриншот главной страницы multimedia-test](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_Graphics_system_development_Guide-image2.jpg)


При нажатии на значки SD-карты и USB-накопителя можно отформатировать SD-карту и USB-накопитель для корректного формата, необходимого при фотосъёмке и записи. Синие значки SD-карты и USB-накопителя указывают на правильное монтирование устройств, серые — на неправильное монтирование. При одновременном монтировании SD-карты и USB-накопителя по умолчанию используется SD-карта. Нажмите на соответствующий значок для входа в соответствующий функциональный интерфейс.

Ниже представлен скриншот приложения r11-board:


![Рисунок 2-2: Скриншот главной страницы r11-board](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_Graphics_system_development_Guide-image3.jpg)


Три страницы на главной можно переключать влево и вправо для перехода к следующей странице. Нажмите на разные изображения стирки для входа в конкретный функциональный интерфейс стирки.


![Рисунок 2-3: Скриншот функциональной страницы r11-board](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_Graphics_system_development_Guide-image4.jpg)


Нажатие на кнопки "Стирка", "Полоскание" и "Отжим" в нижней части открывает прокручиваемый список для выбора различных параметров. При нажатии на кнопку "Функция +" воспроизводится анимация вращения.

Ниже представлен скриншот приложения smart-music-player:



![Рисунок 2-4: Скриншот smart-music-player 1](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_Graphics_system_development_Guide-image5.jpg)



![Рисунок 2-5: Скриншот smart-music-player 2](https://cdn.staticaly.com/gh/DongshanPI/Docs-Photos@master/Tina-Sdk/OpenRemoved_Tina_Linux_Graphics_system_development_Guide-image6.jpg)


### 2.2 Конфигурация MiniGUI

```
source build/envsetup.sh
lunch Название_платформы_XXX
make menuconfig
```

```
Gui --->
    Minigui --->
        <*> libminigui-gpl --->
            [*] Enabel truetype font support (поддержка векторных шрифтов TTF)
            [*] Enabel tslib support for MiniGUI (поддержка сенсорного экрана)
            [ ] Enabel g2d support for MiniGUI (поддержка аппаратного ускорения G2D, требуется движок отображения sunxifb, в настоящее время поддерживается только на R528/D1)
            [ ] Enabel g2drotate support for MiniGUI (поддержка поворота G2D, требуется движок отображения sunxifb, в настоящее время поддерживается только на R528/D1)
            [ ] Enabel sunxifb support for MiniGUI (движок отображения, аналогичный fbcon, при длине framebuffer больше 3 переключается на циклический буфер)
            [ ] Enabel sunxifbion support for MiniGUI (движок отображения, выделение отображаемого буфера через libuapi)
            [ ] Enabel coortrans cw support for MiniGUI (поворот UI на 90 градусов)
            [ ] Enabel reduce size for MiniGUI (удаление ненужных модулей)
        -*- minigui-res-be
        <*> mg-samples
```

Некоторые примеры программ MiniGUI требуют компиляции базовой библиотеки MiniGUI в многопроцессном режиме, поэтому необходимо выполнить следующую конфигурацию:

```
Gui --->
    Minigui --->
        <*> libminigui-gpl --->
            Preferred Minigui Run Mode (ths) ---> proc
```

Несколько отличительных особенностей:

1. В настоящее время в Tina интегрирована версия MiniGUI 3.2, которая может корректно работать как на 64-битных, так и на 32-битных машинах.
2. Если не используется сенсорный экран, необходимо настроить мышь. Для корректного отображения курсора мыши необходимо изменить следующий Makefile:

```
tina/package/minigui/libminigui-gpl/Makefile
```

Измените --enable-cursor=no на yes, чтобы использовать мышь.

Параметры конфигурации MiniGUI для платформы V853

```
source build/envsetup.sh
lunch выберите v853_perf1-tina
make menuconfig
```

```
CONFIG_PACKAGE_eyesee-minigui:
eyesee-minigui is a GUILib for eyesee project.
Symbol: PACKAGE_eyesee-minigui [=y]
Type : tristate
Prompt: eyesee-minigui............................. eyesee-minigui for Tina Linux
```

Путь к коду: external/minigui/

### 2.3 Использование MiniGUI

После успешной прошивки прошивки для использования MiniGUI на целевом устройстве необходимо выполнить следующие шаги:

1. При использовании сенсорного экрана необходимо выполнить калибровку сенсорного экрана.
2. Настроить файл MiniGUI.cfg.

#### 2.3.1 Калибровка сенсорного экрана

Емкостный экран не требует калибровки. Если касание на емкостном экране неточное, необходимо удалить файл /etc/pointercal.

Для резистивного экрана сначала убедитесь, что драйвер сенсорного экрана работает корректно и создан узел сенсорного экрана, например /dev/input/event1. Можно выполнить следующую команду и коснуться экрана, чтобы проверить вывод в последовательный порт.

```
cat /dev/input/event
```

На целевом устройстве установите следующие переменные:


```
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONFFILE=/etc/ts.conf
export TSLIB_PLUGINDIR=/usr/lib/ts
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb
// TSLIB_TSDEVICE настраивается в соответствии с созданным узлом сенсорного экрана
export TSLIB_TSDEVICE=/dev/input/event
ts_calibrate
```

Обратите внимание, что TSLIB_TSDEVICE должен быть созданным узлом сенсорного экрана. Следуйте подсказкам на экране и коснитесь для завершения калибровки. После завершения калибровки создается файл /etc/pointercal. Сохраните этот файл калибровки, чтобы не калибровать каждое устройство.

#### 2.3.2 Конфигурация MiniGUI.cfg

Файл /usr/local/etc/MiniGUI.cfg на целевом устройстве:

```
vim usr/local/etc/MiniGUI.cfg
```

Настройте движки ial и gal для MiniGUI. Использование файла конфигурации следующее:

```
[system]
// Движок GAL и параметры по умолчанию
gal_engine=fbcon
// defaultmode устанавливает размер отображения
defaultmode=800x480-32bpp

[fbcon]
// defaultmode устанавливает размер отображения
defaultmode=800x480-32bpp

[sunxifb]
defaultmode=800x480-32bpp
// flipbuffer=1 заменяет предыдущий export MG_DOUBLEBUFFER=1
flipbuffer=1
// cacheflag=1 включает кэш fb, делая копирование буфера быстрее. На R328/R329 fb не имеет функции кэша, необходимо установить 0
cacheflag=1
// rotate управляет углом поворота, действует после включения поворота G2D. При угле поворота 0 и 180 градусов defaultmode не нужно изменять
// При угле поворота 90 и 270 градусов defaultmode для system и sunxifb нужно изменить на 480x800-32bpp
rotate=0
```

При использовании сенсорного экрана обратите внимание, что mdev необходимо настроить на созданный узел сенсорного экрана. Конфигурация движка ввода следующая:

```
// Движок IAL
ial_engine=tslib
mdev=/dev/input/event1
mtype=none
```

При использовании мыши конфигурация движка ввода следующая:

```
// Движок IAL
ial_engine=console
mdev=/dev/input/mouse0
mtype=IMPS
```

### 2.4 Оптимизация MiniGUI

#### 2.4.1 Двойная буферизация

Цель двойной буферизации — в основном предотвратить разрыв или мерцание изображения.

1. Измените ядро для включения двойного буфера.

Измените файл tina/lichee/linux-3.4/drivers/video/sunxi/disp2/disp/dev_disp.c

Примечание: Для платформы V853 путь к коду: lichee/linux-4.9/drivers/video/fbdev/sunxi/disp2/disp/dev_disp.c

```
//fb0, обратите внимание, что при значении 3 или более при использовании движка sunxifb переключается на циклический буфер, что может повысить частоту кадров при быстрой прокрутке
init_para->buffer_num[0] = 2;
```

2. Перед выполнением программы MiniGUI импортируйте переменную окружения.

```
export MG_DOUBLEBUFFER=1
```

Обратите внимание, что импортировать эту переменную окружения необходимо только при использовании движка fbcon. Для движка sunxifb это указывается полем flipbuffer.

После выполнения шагов 1 и 2 MiniGUI внутренне будет использовать двойную буферизацию, решая проблему мерцания при переключении интерфейса.

3. Также предоставляется функция, которая позволяет на уровне приложения управлять использованием двойного буфера, например, включить двойную буферизацию перед открытием интерфейса и остановить использование двойной буферизации после открытия интерфейса.

При загрузке framebuffer не имеет кэша. При запуске программы minigui, если выполнена команда export MG_DOUBLEBUFFER=1 или установлено flipbuffer=1 и cacheflag=1, framebuffer переключится на режим с кэшем, при смене страницы по умолчанию кэш будет сбрасываться.


Таблица 2-3: Описание функции DoubleBufferEnable

| Функция                   | Описание                                                  |
| :------------------------ | :-------------------------------------------------------- |
| DoubleBufferEnable(FALSE) | framebuffer переключится на режим без кэша, поэтому не нужно сбрасывать кэш       |
| DoubleBufferEnable(TRUE)  | framebuffer переключится на режим с кэшем, при смене страницы по умолчанию кэш будет сбрасываться |

DoubleBufferEnable необходимо вызывать после выполнения export MG_DOUBLEBUFFER=1 или установки flipbuffer=1. DoubleBufferEnable возвращает 0 при успешном вызове. Если возвращается -1, это означает, что вызов не удался, возможно, произошла ошибка при отключении кэша или при mmap framebuffer. В этом случае приложение должно повторно вызвать этот интерфейс, иначе отображение будет некорректным или произойдет ошибка.


#### 2.4.2 Прочее

1. Смена скина клавиатуры, см. документ «Смена скина клавиатуры MiniGUI».
2. Обновление словаря метода ввода, см. документ «Обновление словаря метода ввода MiniGUI».
3. Поворот текста, см. документ «Создание шрифтовой библиотеки TTF с поворотом MiniGUI и вертикальное отображение текста».
4. Портирование MiniGUI на Ubuntu, см. документ «Портирование Minigui 3.2 на Ubuntu 64-бит».
5. Видео в маленьком окне, см. документ «Воспроизведение видео в маленьком окне minigui_per_view».
