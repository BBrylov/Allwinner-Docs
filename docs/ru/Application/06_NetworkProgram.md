# **6 Сетевое программирование**

## **6.1** **Введение в сетевое программирование**

Чтобы написать программы, взаимодействующие через компьютерную сеть, сначала нужно определить протокол (protocol), по которому эти программы будут общаться. Прежде чем проектировать детали протокола, сначала нужно определить, какая программа инициирует связь и когда генерируется ответ.

Например, обычно считается, что программа веб-сервера - это долго работающая программа (демон daemon), которая отправляет сетевые сообщения только в ответ на запросы из сети. Другая сторона протокола - это веб-клиент, например какой-либо браузер, связь с серверным процессом всегда инициируется клиентским процессом. Большинство сетевых приложений организованы по разделению на клиент (client) и сервер (server).



### **6.1.1** **Пятиуровневый стек протоколов Интернета**

Чтобы обеспечить структуру для проектирования сетевых протоколов, разработчики сетей организуют протоколы и сетевое оборудование и программное обеспечение, реализующее эти протоколы, послойно (layer).

Слоистость обеспечивает структурированный способ обсуждения системных компонентов. Модульность упрощает обновление системных компонентов.

Стек протоколов - это совокупность всех протоколов всех уровней.

![NetworkProgram_Image001](http://photos.100ask.net/NewHomeSite/NetworkProgram_Image001.png)

<center><p>Пятиуровневый стек протоколов Интернета</p></center>

Прикладной уровень: Прикладной уровень - это место, где находятся сетевые приложения и их протоколы прикладного уровня.

Транспортный уровень: Транспортный уровень Интернета передает сообщения прикладного уровня между конечными точками приложений.

Сетевой уровень: Сетевой уровень Интернета отвечает за перемещение сетевых пакетов, называемых датаграммами (datagram), от одного хоста к другому.

Канальный уровень: Сетевой уровень Интернета маршрутизирует датаграммы через серию маршрутизаторов между источником и пунктом назначения.

Физический уровень: Хотя задача канального уровня - переместить весь кадр от одного сетевого элемента к соседнему сетевому элементу, задача физического уровня - переместить каждый бит этого кадра от одного узла к следующему узлу.

### 6.1.2 Распространенные протоколы транспортного и прикладного уровней

Мы сосредоточимся на прикладном уровне и транспортном уровне, которые тесно связаны с программированием прикладного уровня.

Прикладной уровень:

Прикладной уровень Интернета содержит множество протоколов, например HTTP, SMTP и FTP. Мы видим некоторые сетевые функции, например преобразование дружественных для человека имен конечных систем, таких как www.baidu.com, в 32-битные сетевые адреса, также выполняется с помощью конкретного протокола прикладного уровня, а именно системы доменных имен (DNS).

Протоколы прикладного уровня распределены по нескольким конечным системам, приложение в одной конечной системе использует протокол для обмена информационными пакетами с приложением в другой конечной системе.

Транспортный уровень:

В Интернете существует два транспортных протокола, а именно TCP и UDP, использование любого из них может передавать сообщения прикладного уровня. При написании приложений конкретный выбор транспортного протокола должен определяться в зависимости от фактической ситуации (это будет подробно объяснено позже).



## **6.2** **Сравнение TCP/UDP в сетевом программировании**

### 6.2.1 Различия между TCP и UDP в принципе

TCP предоставляет своим приложениям сервис с установлением соединения. Этот сервис включает гарантированную доставку сообщений прикладного уровня в пункт назначения и контроль потока (то есть соответствие скорости отправителя/получателя). Этот сервис включает разделение сообщений прикладного уровня на короткие сообщения и предоставляет механизм контроля перегрузки, поэтому источник подавляет свою скорость передачи при перегрузке сети.

Протокол UDP предоставляет своим приложениям сервис без установления соединения. Это сервис, который не предоставляет ненужных услуг, без надежности, без контроля потока и без контроля перегрузки.

### 6.2.2 Почему существует протокол UDP

Если TCP предоставляет надежный сервис передачи данных, а UDP не может его предоставить, то всегда ли TCP является предпочтительным? Ответ отрицательный, потому что многие приложения больше подходят для UDP, по следующим причинам:

a. Более точный контроль над тем, когда и какие данные отправлять.

При использовании UDP, как только процесс приложения передает данные UDP, UDP немедленно передаст их на сетевой уровень. В то время как TCP имеет механизм повторной передачи, независимо от того, сколько времени требуется для надежной доставки. Но приложения реального времени обычно не хотят чрезмерной задержки в передаче сегментов и могут допустить потерю части данных.

b. Не требуется установление соединения, что не вносит задержку при установлении соединения.

c. Без состояния соединения, может поддерживать больше активных клиентов.

d. Меньшие накладные расходы заголовка пакета.

### 6.2.3 Примерная диаграмма взаимодействия сетевой связи TCP/UDP

Ниже мы соответственно нарисуем примерные диаграммы взаимодействия клиента и сервера при использовании протокола TCP и протокола UDP.

![NetworkProgram_Image002](http://photos.100ask.net/NewHomeSite/NetworkProgram_Image002.png)

<center><p>Потоковый режим TCP с установлением соединения</p></center>

![NetworkProgram_Image003](http://photos.100ask.net/NewHomeSite/NetworkProgram_Image003.png)

<center><p>Режим пользовательских датаграмм UDP</p></center>



## **6.3** **Введение в основные функции сетевого программирования**

Заголовочные файлы для всех функций ниже:

```c
#include <sys/types.h>
#include <sys/socket.h>
```

### 6.3.1 Функция socket

```c
int socket(int domain, int type,int protocol);
```

Эта функция используется для создания сокета.

**domain** - это семейство протоколов связи, используемое хостом, на котором работает сетевая программа (AF_UNIX и AF_INET и т.д.).

AF_UNIX может использоваться только для межпроцессного взаимодействия в одной системе Unix, а AF_INET предназначен для Интернета и поэтому позволяет удаленное взаимодействие.

**type** - это протокол связи, используемый сетевой программой (SOCK_STREAM, SOCK_DGRAM и т.д.).

SOCK_STREAM указывает, что используется протокол TCP, который обеспечивает упорядоченный, надежный, двунаправленный, ориентированный на соединение битовый поток.

SOCK_DGRAM указывает, что используется протокол UDP, который обеспечивает только ненадежную связь без установления соединения.

Что касается **protocol**, поскольку type уже указан, это место обычно можно заменить на 0.

Эта функция возвращает файловый дескриптор при успешном выполнении, возвращает -1 при сбое, errno можно проверить для получения подробной информации об ошибке.



### 6.3.2 Функция bind

```c
int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
```

Эта функция используется для привязки адреса к сокету. На одном компьютере может быть несколько IP-адресов и портов, к какому IP и порту привязать этот сокет - это нужно сделать с помощью функции bind.

**sockfd** - это файловый дескриптор, возвращенный вызовом функции socket.

**my_addr** - это указатель на sockaddr.

**addrlen** - это длина структуры sockaddr.

Определение **sockaddr**:

```c
struct sockaddr{
unisgned short  as_family;
char sa_data[14];                  // Эти 14 байтов содержат IP и порт, но неявно
};
```

Однако из-за совместимости системы мы обычно используем другую структуру (struct sockaddr_in) в качестве замены.

Определение **sockaddr_in**: Структуры **sockaddr** и **sockaddr_in** имеют совершенно одинаковый размер,

```c
struct sockaddr_in{
unsigned short          sin_family;
unsigned short          sin_port;          // 2 байта   представляет порт
struct in_addr          sin_addr;          // 4 байта   представляет IP-адрес
unsigned char           sin_zero[8];       // 8 байтов   не используется  2+4+8=14 байтов, так же как и у структуры выше
}
```

Если используется Интернет, sin_family обычно устанавливается в AF_INET.

sin_addr - это тоже структура, sin_addr.s_addr установленный в INADDR_ANY означает возможность взаимодействия со всеми IP-адресами хоста, то есть мониторинг всех IP-адресов.

sin_port - это порт для прослушивания. Нужно использовать htons(SERVER_PORT) для преобразования номера порта в сетевой порядок байтов.

bind связывает локальный порт с файловым дескриптором, возвращенным socket.

Возвращает 0 при успехе, возвращает -1 в случае сбоя, как и socket.



### 6.3.3 Функция listen

```c
int listen(int sockfd,int backlog);
```

Эта функция объявляет, что сервер может принимать запросы на соединение.

**sockfd** - это файловый дескриптор после bind.

**backlog** устанавливает максимальную длину очереди запросов. Когда несколько клиентских программ подключаются к серверу, используется это для указания допустимой длины очереди.

Функция listen превращает файловый дескриптор bind в прослушивающий сокет.

Возвращает 0 при успехе, возвращает -1 в случае сбоя, как и socket.



### 6.3.4 Функция accept

```c
int accept(int sockfd, struct sockaddr *addr,int *addrlen);
```

Сервер использует эту функцию для получения запроса на соединение и установления соединения.

**sockfd** - это файловый дескриптор после listen.

**addr**, **addrlen** используются для заполнения клиентской программой, серверная сторона просто передает указатели. bind, listen и accept - это функции, используемые на стороне сервера.

При вызове accept программа на стороне сервера будет блокироваться до тех пор, пока клиентская программа не установит соединение.

При успехе accept возвращает финальный файловый дескриптор на стороне сервера, в это время сторона сервера может записывать информацию в этот дескриптор, при сбое возвращает -1.

(Можно считать, что этот дескриптор - это символ этого клиента, после этого прием и отправка производятся через операции с этим дескриптором)



Вопрос: Как преобразовать IP-адрес клиента в привычную нам форму?

Ответ: inet_ntoa(sockaddr.sin_addr)   преобразует этот sin_addr в строку формата ascii



### 6.3.5 Функция connect

Для соединения TCP здесь будет трехстороннее рукопожатие

Для соединения UDP здесь псевдосоединение, цель только в том, чтобы получить данные IP-адреса

```c
int connect(int sockfd, struct sockaddr * serv_addr,int addrlen);
```

Можно использовать connect для установления соединения, адрес, указанный в connect, - это адрес сервера, с которым вы хотите взаимодействовать.

**sockfd** - это файловый дескриптор, возвращенный функцией socket, файловый дескриптор клиента.

**serv_addr** хранит информацию о соединении с сервером, где sin_add - это адрес сервера.

**addrlen** - это длина serv_addr.

Функция connect используется клиентом для соединения с сервером

Возвращает 0 при успехе, sockfd - это файловый дескриптор для взаимодействия с сервером (клиент), возвращает -1 при сбое.



### 6.3.6 Функция send

```c
ssize_t send(int sockfd, const void \*buf, size_t len, int flags);
```

**sockfd** указывает дескриптор сокета отправляющей стороны;

**buf** указывает на буфер, содержащий данные, которые приложение хочет отправить;

**len** указывает фактическое количество байтов данных для отправки;

**flags** обычно устанавливается в 0.

Как клиентское, так и серверное приложение используют функцию send для отправки данных другой стороне TCP-соединения



### 6.3.7 Функция recv

【Будет спать при отсутствии данных】

```c
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

**sockfd** указывает дескриптор сокета принимающей стороны;

**buf** указывает на буфер, этот буфер используется для хранения данных, полученных функцией recv;

**len** указывает длину buf, то есть максимальное количество байтов данных, которые можно получить;

**flags** обычно устанавливается в 0.

Как клиентское, так и серверное приложение используют функцию recv для получения данных от другой стороны TCP-соединения.

Возвращаемое значение: Обычно блокируется, при наличии данных возвращает фактически полученное количество данных

if(iRecvLen <= 0)  // означает ошибку

### 6.3.8 Функция recvfrom (UDP)

【Будет спать при отсутствии данных】

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,

				struct sockaddr *src_addr, socklen_t *addrlen);
```

recvfrom обычно используется для сокетов【без установления соединения】, потому что эта функция может получить адрес отправителя.

**src_addr** - это переменная типа struct sockaddr, эта переменная сохраняет IP-адрес и номер порта исходной машины.

**addrlen** обычно устанавливается в sizeof (struct sockaddr).



### 6.3.9 Функция sendto (UDP)

```c
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,

			   const struct sockaddr *dest_addr, socklen_t addrlen);
```

sendto похожа на send, разница в том, что sendto позволяет указать адрес назначения на сокете без установления соединения.

**dest_addr** представляет информацию об IP-адресе и номере порта целевой машины,

**addrlen** часто присваивается sizeof (struct sockaddr). Обратите внимание, что это не передача адреса.

Функция **sendto** также возвращает длину фактически отправленных данных в байтах или возвращает -1 при ошибке отправки.



### 6.3.10 Функция close

```c
close(iSocketClient);
```



### 6.3.11 Вспомогательные функции

```c
#include <arpa/inet.h>

// Преобразует целочисленный номер порта типа short в тип sin_port сетевого порта в sockaddr_in
// Преобразует порядок байтов хоста в сетевой порядок байтов
uint16_t htons(uint16_t hostshort);
```



```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

// Преобразует структуру IP-адреса в строку формата ascii
char *inet_ntoa(struct in_addr in);

$ ./a.out 226.000.000.037      # Последний байт в восьмеричной системе
226.0.0.31
$ ./a.out 0x7f.1               # Первый байт в шестнадцатеричной системе
127.0.0.1

// Параметр 1: cp - это строка IP-адреса в формате 192.168.1.1
// Параметр 2: inp - это IP-адрес в формате struct in_addr, то есть
int inet_aton(const char *cp, struct in_addr *inp);

```



## 6.4 Простой пример программирования TCP

Сервер сначала выполняет операции инициализации: вызывает функцию socket для создания сокета, функцию bind для привязки этого сокета к общедоступному адресу сервера, функцию listen для превращения этого сокета в прослушивающий сокет, затем вызывает функцию accept для ожидания запросов от клиента. Через некоторое время клиент запускается, вызывает socket для создания сокета, затем вызывает функцию connect для установления соединения с сервером. После установления соединения клиент и сервер взаимодействуют путем чтения и записи в сокет.



### 6.**4.1** Код на стороне сервера

Справка: TCP/server_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/types.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9#include <signal.h>
10
11#define SERVER_PORT 8180
12#define C_QUEUE     10
13
14/************************************************************
15*Описание функции: Прием данных клиента с порта 8180
16*Входные параметры: нет
17*Выходные параметры: Вывод IP клиента и полученного сообщения
18*Возвращаемое значение: нет
19*Дата изменения		Версия		Автор		Содержание изменения
20*2020/05/13		v1.0.0		zonghzha	reat
21*************************************************************/
22
23int main(int argc, char **argv)
24{
25    char buf[512];
26    int len;
27    int duty_socket;
28    int customer_socket;
29    struct sockaddr_in socket_server_addr;
30    struct sockaddr_in socket_client_addr;
31    int ret;
32    int addr_len;
33
34    signal(SIGCHLD, SIG_IGN);
35
36	  /* Сторона сервера начинает создавать дескриптор socket */
37    duty_socket = socket(AF_INET, SOCK_STREAM, 0);
38    if (duty_socket == -1)
39    {
40        printf("socket error");
41        return -1;
42    }
43
44	  /* Сторона сервера заполняет структуру sockaddr_in */
45    socket_server_addr.sin_family   = AF_INET;
46	  /* Преобразование номера порта в сетевой порядок байтов */
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48	  /* Прием данных со всех сетевых интерфейсов хоста */
49    socket_server_addr.sin_addr.s_addr  = INADDR_ANY;
50    memset(socket_server_addr.sin_zero, 0, 8);
51
52	  /* Привязка дескриптора sockfd */
53    ret = bind(duty_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
54    if (ret == -1)
55    {
56        printf("bind error!\n");
57        return -1;
58    }
59    ret = listen(duty_socket, C_QUEUE);
60    if (ret == -1)
61    {
62        printf("listen error!\n");
63        return -1;
64    }
65
66    while (1)
67    {
68        addr_len = sizeof(struct sockaddr);
69		  /* Сервер блокируется, пока клиентская программа не установит соединение */
70        customer_socket = accept(duty_socket, (struct sockaddr *)&socket_client_addr, &addr_len);
71        if (customer_socket != -1)
72        {
73			  /*Функция inet_ntoa преобразует 32-битный IPv4 адрес в соответствующую точечно-десятичную строку*/
74            printf("Get connect from %s\n", inet_ntoa(socket_client_addr.sin_addr));
75        }
76        if (!fork())
77        {
78            while (1)
79            {
80                memset(buf, 512, 0);
81				  /*Прием данных*/
82                len = recv(customer_socket, buf, sizeof(buf), 0);
83                buf[len] = '\0';
84                if (len <= 0)
85                {
86                    close(customer_socket);
87                    return -1;
88                }
89                else
90                {
91                    printf("Get connect from %s, Msg is %s\n", inet_ntoa(socket_client_addr.sin_addr), buf);
92                }
93            }
94        }
95    }
96
97    close(duty_socket);
98    return 0;
99}
```

### 6.4.2 Код на стороне клиента

Справка: TCP/client_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/types.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9
10#define SERVER_PORT 8180
11/************************************************************
12*Описание функции: Отправка данных на порт 8180 указанного IP
13*Входные параметры: IP-адрес сервера в точечно-десятичной нотации
14*Выходные параметры: нет
15*Возвращаемое значение: нет
16*Дата изменения		Версия		Автор		Содержание изменения
17*2020/05/13		v1.0.0		zonghzha	creat
18*************************************************************/
19
20int main(int argc, char **argv)
21{
22    unsigned char buf[512];
23    int len;
24    struct sockaddr_in socket_server_addr;
25    int ret;
26    int addr_len;
27    int client_socket;
28
29
30    if (argc != 2)
31    {
32        printf("Usage:\n");
33        printf("%s <server_ip>\n", argv[0]);
34        return -1;
35    }
36
37    /* Клиентская программа начинает создавать дескриптор sockfd */
38    client_socket = socket(AF_INET, SOCK_STREAM, 0);
39    if (client_socket == -1)
40    {
41        printf("socket error");
42        return -1;
43    }
44
45	  /* Клиентская программа заполняет данные сервера */
46    socket_server_addr.sin_family   = AF_INET;
47	  /*Преобразование порядка байтов хоста в сетевой порядок байтов*/
48    socket_server_addr.sin_port     = htons(SERVER_PORT);
49    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
50    {
51        printf("invalid server ip\n");
52        return -1;
53    }
54    memset(socket_server_addr.sin_zero, 0, 8);
55    /* Клиентская программа инициирует запрос на соединение */
56    ret = connect(client_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
57    if (ret == -1)
58    {
59        printf("connect error!\n");
60        return -1;
61    }
62

63
64    while (1)
65    {
66        if (fgets(buf, sizeof(buf), stdin))
67        {
68            len = send(client_socket, buf, strlen(buf), 0);
69            if (len <= 0)
70            {
71                close(client_socket);
72                return -1;
73            }
74        }
75    }
76
77    close(client_socket);
78    return 0;
79}
```

### 6.4.3 Файл Makefile

```c
all:server client
server:server.c
	gcc $^ -o $@
client:client.c
	gcc $^ -o $@
clean:
	rm server client -f

(Примечание: Командные операторы должны начинаться с клавиши "Tab".)
```



### 6.4.4 Выполнение

Сторона сервера:

```c
./server
```

Сторона клиента:

```c
./client 127.0.0.1
```

Ввод на стороне клиента:

```c
good night
```

Отображение на стороне сервера:

```c
Get connect from 127.0.0.1
Get connect from 127.0.0.1, Msg is good night
```



## 6.5 Простой пример программирования UDP

UDP-сервер сначала выполняет операции инициализации: вызывает функцию socket для создания сокета датаграммного типа, функцию bind для привязки этого сокета к общедоступному адресу сервера. Затем вызывает функцию recvfrom для приема датаграмм UDP-клиента. UDP-клиент сначала вызывает функцию socket для создания сокета датаграмм, затем вызывает функцию sendto для отправки датаграмм серверу. После завершения связи клиент вызывает close для закрытия UDP-сокета, сервер продолжает использовать этот UDP-сокет для приема датаграмм от других клиентов.

### 6.**5.1** Код на стороне сервера

Справка UDP/server_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4//#include <sys/type.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9#include <signal.h>
10
11/*Порт сервера 8180*/
12#define SERVER_PORT 8180
13
14/************************************************************
15*Описание функции: Прием данных клиента с порта 8180
16*Входные параметры: нет
17*Выходные параметры: Вывод IP клиента и полученного сообщения
18*Возвращаемое значение: нет
19*Дата изменения			Версия			Автор			Содержание изменения
20*2020/05/13			v1.0.0			zonghzha		creat
21*************************************************************/
22
23
24int main(int argc, char **argv)
25{
26    unsigned char buf[512];
27    int len;
28    int duty_socket;
29    int customer_socket;
30    struct sockaddr_in socket_server_addr;
31    struct sockaddr_in socket_client_addr;
32    int ret;
33    int addr_len;
34
35	  /* Создание сокета датаграмм */
36    duty_socket = socket(AF_INET, SOCK_DGRAM, 0);
37    if (duty_socket == -1)
38    {
39        printf("socket error");
40        return -1;
41    }
42
43	  /* Сторона сервера заполняет структуру sockaddr_in */
44    socket_server_addr.sin_family   = AF_INET;
45    socket_server_addr.sin_port     = htons(SERVER_PORT);
46    socket_server_addr.sin_addr.s_addr  = INADDR_ANY;
47    memset(socket_server_addr.sin_zero, 0, 8);
48
49	  /*Привязка сокета*/
50    ret = bind(duty_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
51    if (ret == -1)
52    {
53        printf("bind error!\n");
54        return -1;
55    }
56

57
58    while (1)
59    {
60        addr_len = sizeof(struct sockaddr);
61		  /* Прием датаграммы клиента, возвращается количество полученных байтов */
62        len = recvfrom(duty_socket, buf, sizeof(buf), 0, (struct sockaddr *)&socket_client_addr, &addr_len);
63        if (len > 0)
64        {
65            buf[len] = '\0';
66            printf("Get Msg from %s : %s\n", inet_ntoa(socket_client_addr.sin_addr), buf);
67        }
68
69    }
70
71    close(duty_socket);
72    return 0;
73}
74

```

### **6.5.2** **Код на стороне клиента**

#### 6.**5.2.1** Клиентская программа 1

Справка UDP/client_line_1.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/socket.h>
5#include <netinet/in.h>
6#include <arpa/inet.h>
7#include <unistd.h>
8
9#define SERVER_PORT 8180
10
11/************************************************************
12*Описание функции: Отправка данных на порт 8180 указанного IP
13*Входные параметры: IP-адрес сервера в точечно-десятичной нотации
14*Выходные параметры: нет
15*Возвращаемое значение: нет
16*Дата изменения			Версия			Автор			Содержание изменения
17*2020/05/13			v1.0.0			zonghzha		creat
18*************************************************************/
19
20int main(int argc, char **argv)
21{
22    unsigned char buf[512];
23    int len;
24    struct sockaddr_in socket_server_addr;
25    int ret;
26    int addr_len;
27    int client_socket;
28

29
30    if (argc != 2)
31    {
32        printf("Usage:\n");
33        printf("%s <server_ip>\n", argv[0]);
34        return -1;
35    }
36
37    /*Создание сокета*/
38    client_socket = socket(AF_INET, SOCK_DGRAM, 0);
39    if (client_socket == -1)
40    {
41        printf("socket error");
42        return -1;
43    }
44
45	  /* Заполнение данных сервера */
46    socket_server_addr.sin_family   = AF_INET;
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
49    {
50        printf("invalid server ip\n");
51        return -1;
52    }
53    memset(socket_server_addr.sin_zero, 0, 8);
54

55

56

57
58    while (1)
59    {
60        if (fgets(buf, sizeof(buf), stdin))
61        {
62 //           len = send(client_socket, buf, strlen(buf), 0);
63			  /*Отправка датаграммы серверу*/
64            addr_len = sizeof(struct sockaddr);
65            len = sendto(client_socket, buf, sizeof(buf), 0, (struct sockaddr *)&socket_server_addr, addr_len);
66            if (len <= 0)
67            {
68                close(client_socket);
69                return -1;
70            }
71        }
72    }
73
74    close(client_socket);
75    return 0;
76}
77

```

Вопрос: Нельзя ли использовать функцию connect при написании программы сетевого взаимодействия по протоколу UDP?

Ответ: Можно.

#### 6.**5.2.2** **Клиентская программа 2**

Справка UDP/client_line_2.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/socket.h>
5#include <netinet/in.h>
6#include <arpa/inet.h>
7#include <unistd.h>
8
9/*Порт сервера 8180*/
10#define SERVER_PORT 8180
11
12/************************************************************
13*Описание функции: Отправка данных на порт 8180 указанного IP
14*Входные параметры: IP-адрес сервера в точечно-десятичной нотации
15*Выходные параметры: нет
16*Возвращаемое значение: нет
17*Дата изменения			Версия			Автор			Содержание изменения
18*2020/05/13			v1.0.0			zonghzha		creat
19*************************************************************/
20
21int main(int argc, char **argv)
22{
23    unsigned char buf[512];
24    int len;
25    struct sockaddr_in socket_server_addr;
26    int ret;
27    int addr_len;
28    int client_socket;
29

30
31    if (argc != 2)
32    {
33        printf("Usage:\n");
34        printf("%s <server_ip>\n", argv[0]);
35        return -1;
36    }
37
38    /*Создание сокета датаграмм*/
39    client_socket = socket(AF_INET, SOCK_DGRAM, 0);
40    if (client_socket == -1)
41    {
42        printf("socket error");
43        return -1;
44    }
45
46    socket_server_addr.sin_family   = AF_INET;
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
49    {
50        printf("invalid server ip\n");
51        return -1;
52    }
53    memset(socket_server_addr.sin_zero, 0, 8);
54
55    ret = connect(client_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
56    if (ret == -1)
57    {
58        printf("connect error!\n");
59        return -1;
60    }
61

62
63    while (1)
64    {
65        if (fgets(buf, sizeof(buf), stdin))
66        {
67            len = send(client_socket, buf, strlen(buf), 0);
68            if (len <= 0)
69            {
70                close(client_socket);
71                return -1;
72            }
73        }
74    }
75
76    close(client_socket);
77    return 0;
78}
79

```

В клиентском коде 2 функция connect на самом деле не устанавливает соединение на уровне протокола, она только указывает адрес и номер порта сервера.

Поскольку в connect указаны адрес и номер порта сервера, последующий send может отправлять напрямую, не указывая адрес и номер порта повторно.

### 6.5.3 Файл Makefile

```c
all:server client_1 client_2
server:server.c
	gcc $^ -o $@
client_1:client_1.c
	gcc $^ -o $@
client_2:client_2.c
	gcc $^ -o $@
clean:
	rm server client_1 client_2 -f

(Примечание: Командные операторы должны начинаться с клавиши "Tab".)
```

### 6.5.4 Выполнение

Выполнение на стороне сервера:

```c
./server
```

Выполнение на стороне клиента:

```c
./client_1 127.0.0.1
```

Ввод на стороне клиента:

```c
good night
```

Отображение на стороне сервера:

```c
Get Msg from 127.0.0.1 : good night
```
