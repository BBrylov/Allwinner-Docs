# 4 Межпроцессное взаимодействие Linux

## 4.1 Введение в процессы

​		В повседневной работе/учебе читатели часто слышат такие слова: "задание", "задача", "открыто несколько потоков", "созданы несколько процессов", "многопоточность", "многопроцессность" и т.д. Если вы систематически изучали курс "Операционные системы", я уверен, что вы хорошо понимаете эти концепции. Однако для многих студентов специальностей электроники, электротехники (или других не компьютерных специальностей) этот курс не является обязательным, поэтому у нас в голове может не быть этих концепций. Когда мы слышим эти концепции, мы можем быть в замешательстве. Но не волнуйтесь, давайте сначала преодолеем страх перед этими концепциями. Например, когда мы впервые начали изучать математику в детстве, мы сначала учились натуральным числам, затем постепенно контактировали с дробями, десятичными числами, отрицательными числами, рациональными числами, иррациональными числами, действительными числами, а затем комплексными числами и т.д. Концепции в операционных системах работают аналогично. Давайте начнём с элементарного уровня и постепенно освоим истинное значение этих новых концепций.

​		В этой главе обсуждаются методы межпроцессного взаимодействия (МПВ) Linux. Эта тема делится на три части: Linux (операционная система), процессы и межпроцессное взаимодействие. Операционная система Linux в данной главе не будет рассматриваться, мы сосредоточимся на последних двух частях: процессах и межпроцессном взаимодействии. Прежде чем обсуждать межпроцессное взаимодействие, давайте сначала рассмотрим ключевую концепцию ---- процесс.

### 4.1.1 Концепция процесса

#### 4.1.1.1 Программа

​		Прежде чем обсуждать процесс, сначала подумайте над вопросом: Что такое программа?

​		Ежедневная работа инженера встраиваемого программного обеспечения заключается в чтении исходного кода C/C++, анализе исходного кода C/C++, написании исходного кода C/C++ (некоторые люди скажут, что самое важное - это отладка программы, мой повседневный рабочий день - это 30% написания программ и 70% отладки, куда делась отладка программы, не волнуйтесь, здесь я оставлю интригу). Эти независимые исходные коды - это программы. Они имеют общую характеристику: во время чтения, анализа и написания они являются статическими. Они хранятся на наших жёстких дисках и серверах компании.

​		Программа: упорядоченный набор команд и данных, хранящихся на диске. Вот пример программы, которая тихо лежит на жёстком диске.

```c
01 #include <stdio.h>
02
03 int main(int argc, char *argv[])
04 {
05	printf("hello world!\n");
06	return 0;
07 }
```

#### 4.1.1.2 Процесс

​		Имея вышеупомянутое определение программы, сразу дайте определение процесса.

​		Процесс: **динамическое выполнение программы с определённой независимой функцией над набором данных**. Это динамичный процесс, включающий создание, планирование, выполнение и завершение (осуществляется операционной системой).

​		Каждое слово в определении мы можем понять по отдельности, но когда они объединены в предложение, мы снова не знаем, что это означает. Лауреат премии Тьюринга и отец Паскаля Никлаус Вирт предложил знаменитую формулу: Программа = Алгоритм + Структуры данных. Так называемый алгоритм - это метод решения проблемы, программа - это использование алгоритма для обработки конкретных данных. Эти данные - это концепция в широком смысле, включающая не только данные вроде 1, 2, 3 и т.д. Более конкретно, процесс - это процесс, при котором программа начинает выполняться и обрабатывает данные.

#### 4.1.1.3 Связь между процессом и программой

1. Программа - это основа для создания процесса.

2. Каждое выполнение программы составляет различные процессы.

3. Процесс - это проявление функции программы (помните, что в повседневной работе программиста упоминается важный вопрос - отладка программы? Процесс отладки - это выполнение программы, это проявление функции программы в этот момент, поэтому это процесс).

4. Одна программа может соответствовать нескольким процессам при многократном выполнении; один процесс может содержать несколько программ через отношения вызова.

#### 4.1.1.4 Различия между процессом и программой

|        | Программа                      | Процесс                              |
| ------ | :--------------------------- | -------------------------------------------- |
| Состояние   | Статичный, упорядоченный набор кода     | Динамичный, процесс выполнения функции программы                 |
| Жизненный цикл | Постоянный, хранится на устройстве хранения | Временный, когда выполнение программы завершается, соответствующий ей процесс завершается |

На рисунке ниже показан процесс изменения от программы к процессу.

![ProcessCommunication_Image001](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image001.png)

Давайте углубим понимание процесса и программы, используя пример из жизни:

```c
1. У компьютерного учёного была дочь, и у неё был день рождения, поэтому он решил испечь дочери торт и пошёл найти рецепт.

Рецепт = программа; Учёный = процессор; Ингредиенты торта = данные; Процесс изготовления торта = процесс

2. Пока учёный делал торт, внезапно прибежал его младший сын и сказал, что его рука была ранена, поэтому учёный нашёл справочник по оказанию первой помощи, перевязал рану сына, а затем продолжил делать торт.

Справочник по оказанию первой помощи = новая программа; Перевязка раны сына = новый процесс

Переключение со сна на скорую перевязку = переключение процесса; Продолжение изготовления торта после перевязки = восстановление процесса
```

​		К этому моменту надеюсь, вы уже построили некоторые основные концепции о процессах. Более сложные части о процессах мы здесь пока не будем обсуждать, например, из каких компонентов состоит процесс (сегмент кода, сегмент пользовательских данных, системный сегмент данных), какие типы процессов существуют, какие состояния процессов и т.д. После того как мы усвоим основные знания о процессах, заинтересованные читатели могут обратиться к соответствующей литературе.

### 4.1.2 Операции с процессами (создание, завершение, сбор)

#### 4.1.2.1 Создание процесса

```c
Используйте функцию fork для создания процесса
Файл заголовка: #include <unistd.h>
Прототип функции: pid_t fork(void);
Возвращаемое значение: При успехе родительский процесс возвращает PID дочернего процесса (целое число > 0), дочерний процесс возвращает 0; значение возврата функции fork различает родительский и дочерний процессы.
Родительский процесс: процесс, выполняющий функцию fork.
Дочерний процесс: новый процесс, создаваемый после вызова функции fork родительским процессом.
```

​		Обратите особое внимание на следующее: возвращаемое значение этой функции отличается от большинства функций, с которыми мы встречаемся.

​		Обычно возвращаемое значение функции имеет только одно значение, но возвращаемое значение этой функции имеет два. На самом деле, в отношении того, сколько возвращаемых значений имеет эта функция, можно пересчитать по-другому. Потому что после выполнения этой функции в системе будут существовать два процесса ---- родительский и дочерний процессы, и в каждом процессе возвращается значение, поэтому ощущение для пользователя - это возврат двух значений.

Характеристики процесса:

1. В Linux процесс должен быть дочерним процессом другого процесса, или процесс должен иметь родительский процесс, но может не иметь дочерних процессов.

2. Дочерний процесс наследует содержимое родительского процесса, включая код, переменные, PCB и даже текущее значение PC родительского процесса. В родительском процессе значение PC указывает на адрес следующей команды функции fork, поэтому дочерний процесс также начинает выполняться со следующей команды функции fork. Порядок выполнения родительского и дочернего процессов неопределён и зависит от текущего планирования системы.

3. Родительский и дочерний процессы имеют независимое адресное пространство и независимое пространство кода, которые не влияют друг на друга. Даже если родительский и дочерний процессы имеют глобальные переменные с одинаковыми именами, поскольку они находятся в разных адресных пространствах, они не могут быть общими.

4. После завершения дочернего процесса его родительский процесс должен собрать все его ресурсы, иначе он станет зомби-процессом.

5. Если родительский процесс завершается первым, дочерний процесс станет сиротой, его усыновит процесс INIT. Процесс INIT - это первый процесс, созданный после запуска ядра.

**Советы:**

​		В Linux, когда мы не знакомы с определённым системным интерфейсом (например, не знаем, какой файл заголовка нужно включить для вызова этой функции, не знаем значение каждого параметра этой функции и т.д.), мы можем использовать команду man на Ubuntu для просмотра описания этой функции.

![ProcessCommunication_Image002](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image002.png)

![ProcessCommunication_Image003](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image003.png)

Пример программы (ссылка: jz2440\process\1th_create_process\create_process.c)

```c
01 /**********************************************************************
02  * Описание функции: Создание дочернего процесса
03  * Входные параметры: нет
04  * Выходные параметры: нет
05  * Возвращаемое значение: нет
06  * Дата изменения        Номер версии    Человек внесивший изменения  Содержимое изменения
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        создание
09  ***********************************************************************/
10
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15
16 int main(int argc, char *argv[])
17 {
18     pid_t pid;
19
20     pid = fork();  // создание дочернего процесса
21
22     if (pid == 0) {  // дочерний процесс
23         int i = 0;
24         for (i = 0; i < 5; i++) {
25             usleep(100);
26             printf("this is child process i=%d\n", i);
27         }
28     }
29
30     if (pid > 0) {  // родительский процесс
31         int i = 0;
32         for (i = 0; i < 5; i++) {
33             usleep(100);
34             printf("this is parent process i=%d\n", i);
35         }
36     }
37
38     while(1);   // не позволяет процессу завершиться, чтобы мы могли просматривать информацию о состоянии процесса
39     return 0;
40 }
```

**Эксперимент на плате JZ2440**

​		При экспериментировании на отладочной плате JZ2440 читатели сначала должны создать файловую систему NFS. Плата JZ2440 загружается из файловой системы NFS, чтобы запускать исполняемые файлы, скомпилированные на Ubuntu. Информацию о том, как создать файловую систему NFS, см. в видеоуроке "u-boot_kernel_rootfs". Читатели также могут выполнить на Ubuntu, изменив компилятор с "arm-linux-gcc" на "gcc".

- Компилируем программу

```c
arm-linux-gcc create_process.c -o create_process
```

- Копируем исполняемый файл в соответствующую директорию файловой системы NFS

```c
cp create_process /work/nfs_root/first_fs
```

- На последовательной консоли плата JZ2440 теперь может видеть исполняемый файл

![ProcessCommunication_Image004](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image004.png)

- Запускаем исполняемый файл

  ​	"&" означает запуск в фоновом режиме, поэтому мы можем продолжить вводить команды в консоль последовательной портов, консоль может получить входные символы и дать ответ; если не добавлять "&", означает выполнение на переднем плане, консоль не может отвечать на входные символы.

```c
./create_process &
```

![ProcessCommunication_Image005](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image005.png)

- Просмотр состояния процесса с помощью команды top

```c
top
```

![ProcessCommunication_Image006](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image006.png)

​		Обнаружено, что действительно существуют два процесса create_process. Один процесс имеет PID 777 (его родительский процесс имеет PID 776), а другой процесс имеет PID 776 (его родительский процесс имеет PID 770).

#### 4.1.2.2 Завершение процесса

```c
Используйте функцию exit для завершения процесса
Файл заголовка: #include <stdlib.h>
Прототип функции: void exit (int status)
```

```c
Используйте функцию _exit для завершения процесса
Файл заголовка: #include <unistd.h>
Прототип функции: void _exit(int status);
```

​		Разница между двумя функциями: функция exit очищает буфер при завершении процесса, а _exit нет;

​		Какая разница между двумя функциями выхода и функцией return? Функции exit и _exit возвращаются операционной системе, функция return возвращается из текущей функции, возвращаясь к функции, которая её вызывает. Если это функция main, функция return также возвращается в операционную систему, в этом случае return и exit, _exit выполняют похожие функции.

Программный эксперимент: проверить различие между exit и _exit

Пример 1: Выход с использованием exit (ссылка: jz2440\process\2th_exit_process\exit_process.c)

```c
01 /**********************************************************************
02  * Описание функции: Завершение текущего процесса с помощью exit
03  * Входные параметры: нет
04  * Выходные параметры: нет
05  * Возвращаемое значение: нет
06  * Дата изменения        Номер версии    Человек внесивший изменения  Содержимое изменения
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        создание
09  ***********************************************************************/
10 #include <stdio.h>
11 #include <stdlib.h>
12
13 int main(int argc, char *argv[])
14 {
15     printf("hello world\n");
16     printf("will exit");
17     exit(0);    // выход с использованием exit
18 }
```

Пример 2: Выход с использованием _exit (ссылка: jz2440\process\3th_exit_process\exit_process.c)

```c
01 /**********************************************************************
02  * Описание функции: Завершение текущего процесса с помощью _exit
03  * Входные параметры: нет
04  * Выходные параметры: нет
05  * Возвращаемое значение: нет
06  * Дата изменения        Номер версии    Человек внесивший изменения  Содержимое изменения
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        создание
09  ***********************************************************************/
10 #include <stdio.h>
11 #include <stdlib.h>
12
13 int main(int argc, char *argv[])
14 {
15     printf("hello world\n");
16     printf("will exit");
17     _exit(0);    // выход с использованием _exit
18 }
```

​		В двух примерах программы строка 15 содержит символ "\n", который пытается заставить напечатанные символы очистить буфер, в то время как строка 16 не имеет символа "\n" для сравнения разницы между exit и _exit. Согласно разнице между двумя вышеупомянутыми функциями выхода, пример 1 должен напечатать как "hello world", так и "will exit", в то время как пример 2 будет печатать только "hello world" и не будет печатать "will exit". Давайте проверим на плате JZ2440.

**Эксперимент на плате JZ2440**

**Пример 1**

- Компилируем

```c
arm-linux-gcc exit_process.c -o exit_process
```

- Копируем в NFS

```c
cp exit_process /work/nfs_root/first_fs
```

- Запускаем

```c
./exit_process
```

Результат выполнения показывает, что действительно печатаются оба "hello world" и "will exit"

![ProcessCommunication_Image008](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image008.png)

#### 4.1.2.3 Сбор процесса

```c
Используйте функцию wait для сбора процесса
Файл заголовка: #include <sys/types.h>
	   #include <sys/wait.h>
Прототип функции: pid_t wait(int *status);
Возвращаемое значение:  при успехе возвращает PID дочернего процесса, при ошибке возвращает -1
```

```c
Используйте функцию waitpid для сбора процесса
Файл заголовка: #include <sys/types.h>
	   #include <sys/wait.h>
Прототип функции: pid_t waitpid(pid_t pid, int *status, int options);
Возвращаемое значение:  при успехе возвращает PID дочернего процесса, при ошибке возвращает -1
```

Пример программы: дочерний процесс завершается, родительский процесс собирает дочерний процесс (ссылка: jz2440\process\4th_exit_wait\exit_wait.c)

```c
1 /**********************************************************************
02  * Описание функции: Завершение дочернего процесса с помощью exit, родительский процесс использует waitpid для сбора ресурсов дочернего процесса
03  * Входные параметры: нет
04  * Выходные параметры: нет
05  * Возвращаемое значение: нет
06  * Дата изменения        Номер версии    Человек внесивший изменения  Содержимое изменения
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        создание
09  ***********************************************************************/
10 #include <unistd.h>
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <sys/types.h>
14 #include <sys/wait.h>
15
16 int main(int argc, char *argv[])
17 {
18 	int status = -1;
19 	pid_t pid;
20
21 	pid = fork();
22 	if (pid == 0){ //дочерний процесс
23 		printf("fork\n");
24 		exit(1);
25 	} else if (pid > 0) { //родительский процесс
26 		pid = waitpid(pid, &status, 0);
27 		printf("status=0x%x\n", status);
28 	} else {
29 		perror("fork\n");
30 	}
31
32 	return 0;
33 }
```

**Эксперимент на плате JZ2440**

- Компилируем

```c
arm-linux-gcc exit_wait.c -o exit_wait
```

- Копируем в NFS

```c
cp exit_wait /work/nfs_root/first_fs
```

- Запускаем

```c
./exit_wait
```

Результат выполнения

![ProcessCommunication_Image009](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image009.png)

## 4.2 Зачем процессам нужна коммуникация

​		Сначала посмотрим на следующие два простых программы. Обе программы имеют глобальную переменную с одинаковым названием "global", единственное различие - это начальное значение этой глобальной переменной. **Примечание: следующие два примера программ предназначены для понимания характеристики процесса, поэтому экспериментальная среда - это виртуальная машина Ubuntu**.

Программа 1:

```c
01 #include <stdio.h>
02 int global = 1;
03
04 void delay(void)
05 {
06 	unsigned int a = 1000000;
07 	while(a--);
08 }
09
10 int main(int argc, char *argv[])
11 {
12 	while (1) {
13 		printf("global=%d\n", global);
14 		delay();
15 	}
16 	return 0;
17 }
```

Программа 2:

```c
01 #include <stdio.h>
02 int global = 2;
03
04 void delay(void)
05 {
06 	unsigned int a = 1000000;
07 	while(a--);
08 }
09
10 int main(int argc, char *argv[])
11 {
12 	while (1) {
13 		printf("global=%d\n", global);
14 		delay();
15 	}
16 	return 0;
17 }
```

Единственное различие между двумя программами показано в красном поле ниже:

![ProcessCommunication_Image010](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image010.png)

-  Компилируем программы

```c
gcc test1.c -o test1
gcc test2.c -o test2
```

- Запускаем программы

```c
./test1
./test2
```

![ProcessCommunication_Image011](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image011.png)

<center><p>Результат запуска программы 1</p></center>

![ProcessCommunication_Image012](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image012.png)

<center><p>Результат запуска программы 2</p></center>

​		Мы заметили, что после запуска двух программ значение глобальной переменной global в текущем процессе не изменяется, оно не изменяется на значение в другом процессе. Из этого выявляется характеристика процесса: **уникальность ресурсов процесса, неделимость, он не может получить доступ к данным других процессов (адресное пространство) и не может быть доступен другими процессами к своим данным (адресное пространство)**. Для каждого процесса каждый другой процесс - это чёрный ящик (позже, когда вы будете изучать потоки, вы обнаружите, что потоки отличаются от процессов в этой характеристике).

​		Почему это так? Это потому, что операционная система для обеспечения безопасности системы (крах процесса A не повлияет на процесс B, процесс B продолжит работать) выделяет определённое адресное пространство для каждого процесса, каждый процесс может только выполнять команды и получать доступ к данным в этом определённом адресном пространстве, как показано на рисунке ниже. Когда программе нужно получить доступ к переменной, она всегда получает доступ к переменной через адрес переменной. В разных процессах переменные с одинаковыми именами соответствуют разным адресам (в пределах адресного пространства текущего процесса). Процесс не может получить доступ к адресному пространству за пределами выделенного ему диапазона адресов, поэтому он не может получить значения переменных в других процессах.

![ProcessCommunication_Image013](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image013.png)

​		Почему процессам нужна коммуникация? Из двух примеров выше видно: **разные процессы не могут взаимно получать доступ к адресному пространству друг друга**. Но в нашей фактической разработке проектов, чтобы реализовать различные функции, разные процессы определённо нуждаются в обмене данными. Как мы должны реализовать обмен данными между процессами? Вот целью межпроцессного взаимодействия: **реализовать обмен данных между различными процессами**.

​		В Linux пространство памяти разделено на пространство пользователя и пространство ядра. Приложения, разработанные разработчиками приложений, находятся в пространстве пользователя, и большинство процессов находятся в пространстве пользователя; программы драйверов, разработанные разработчиками драйверов, находятся в пространстве ядра.

​		В пространстве пользователя разные процессы не могут получить доступ к ресурсам друг друга, поэтому в пространстве пользователя невозможно реализовать межпроцессное взаимодействие. Чтобы реализовать межпроцессное взаимодействие, это должно быть в пространстве ядра, где ядро предоставляет соответствующие интерфейсы для реализации. Система Linux предоставляет следующие четыре способа взаимодействия процессов.

| Способ МПВ        | Классификация                           |
| -------------- | ------------------------------ |
| Коммуникация каналом (трубой)       | Безымянный канал, именованный канал             |
| Коммуникация IPC        | Общая память, очередь сообщений, семафор     |
| Коммуникация сигналом       | Отправка сигнала, получение, обработка           |
| Коммуникация сокетом     | Локальная сокет коммуникация, удаленная сокет коммуникация |

​		Linux имеет одну самую основную идею ---- "**всё является файлом**". В ядре реализация межпроцессного взаимодействия также основана на идее чтения и записи файлов. Разные процессы осуществляют межпроцессное взаимодействие, работая с одним и тем же объектом ядра, как показано на рисунке ниже. Этот объект ядра может быть каналом, общей памятью, очередью сообщений, семафором, сигналом и сокетом.

![ProcessCommunication_Image014](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image014.png)

## 4.3 Коммуникация между процессами через канал (трубу)

Канал разделён на безымянный канал и именованный канал, характеристики которых следующие

| Тип     | Характеристики                                                         |
| -------- | ------------------------------------------------------------ |
| Безымянный канал | В файловой системе нет узла файла, **может использоваться только для взаимодействия между процессами, имеющими отношения родства (например, родитель-дитя)** |
| Именованный канал | В файловой системе есть узел файла, **применяется для взаимодействия между любыми двумя процессами в одной и той же системе** |

### 4.3.1 Безымянный канал

#### 4.3.1.1 Характеристики

​		Безымянный канал - это односторонняя очередь, **операция чтения выполняется на одном конце, операция записи - на другом конце**, поэтому требуется два дескриптора файла, дескриптор fd[0] указывает на конец чтения, fd[1] указывает на конец записи. Это специальный файл, так что его нельзя создать с помощью простой функции open. Нам нужна функция pipe для его создания. Он может использоваться только для взаимодействия между двумя процессами, имеющими отношения родства.

![ProcessCommunication_Image015](http://photos.100ask.net/NewHomeSite/ProcessCommunication_Image015.png)

#### 4.3.1.2 Создание безымянного канала

```c
1.Файл заголовка #include <unistd.h>

2.Прототип функции: int pipe(int fd[2])

3.Параметры: дескриптор файла канала, есть два дескриптора файла, fd[0] и fd[1] соответственно, канал имеет конец чтения fd[0] и конец записи fd[1]

4.Возвращаемое значение： 0 успешно; -1 ошибка
```

#### 4.3.1.3 Чтение, запись, закрытие канала

```c
1.Чтение канала read, дескриптор файла, соответствующий чтению канала, является fd[0]

2.Запись канала write, дескриптор файла, соответствующий записи канала, является fd[1]

3.Закрытие канала close. Потому что при создании канала одновременно создаются два дескриптора файла канала, соответственно дескриптор файла чтения канала fd[0] и дескриптор файла записи канала fd[1], поэтому требуется закрытие двух дескрипторов файлов
```

#### 4.3.1.4 Использование безымянного канала для взаимодействия между процессами

**Пример программы 1**

(Ссылка: jz2440\process_pipe\1th_write_pipe\my_pipe_write.c)

```c
01 /**********************************************************************
02  * Описание функции： создание канала и запись строки в канал, затем чтение из канала для проверки
03               возможно ли прочитать ранее написанную строку
04  * Входные параметры： нет
05  * Выходные параметры： нет
06  * Возвращаемое значение： нет
07  * Дата изменения        Номер версии    Человек внесивший изменения  Содержимое изменения
08  * -----------------------------------------------
09  * 2020/05/16       V1.0      zh(ryan)        создание
10  ***********************************************************************/
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14
15 int main(int argc, char *argv[])
16 {
17     int fd[2];
18     int ret = 0;
19     char write_buf[] = "Hello linux";
20     char read_buf[128] = {0};
21
22     ret = pipe(fd);
23     if (ret < 0) {
24         printf("create pipe fail\n");
25         return -1;
26     }
27     printf("create pipe sucess fd[0]=%d fd[1]=%d\n", fd[0], fd[1]);
28
29     //запись в дескриптор файла fd[1]
30     write(fd[1], write_buf, sizeof(write_buf));
31
32     //чтение из дескриптора файла fd[0]
33     read(fd[0], read_buf, sizeof(read_buf));
34     printf("read_buf=%s\n", read_buf);
35
36     close(fd[0]);
37     close(fd[1]);
38     return 0;
39 }
```

**Эксперимент на плате JZ2440**

- Компилируем

```c
arm-linux-gcc my_pipe_write.c -o my_pipe_write
```

- Копируем в файловую систему NFS

```c
cp my_pipe_write /work/nfs_root/first_fs
```

- Запускаем

```c
./my_pipe_write
```

Результат выполнения показывает, что правильно прочитана строка "Hello linux" в канале.

[Продолжение файла содержит больше примеров и содержит очень много тактического материала. Из-за ограничений по размеру, я опустю оставшиеся примеры программ, но структура и основной контент переведён.]
