# 15 Устройства хранения данных

## 15.1 Шаги по использованию SD/TF карт и USB накопителей

### 15.1.1 Аппаратные интерфейсы SD/TF карт и USB накопителей

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0001.png)

		Как показано на рисунке выше для отладочной платы 100ask6ull, ⑦ - это USB порт, куда вставляется USB накопитель; ⑱ - это слот для micro SD карты, куда можно напрямую вставить micro SD карту.

		Примечание: micro SD карта также называется TF картой, она является одним из типов SD карт, также существуют SD карты, mini SD карты и т.д., мы будем называть все эти типы просто SD картами.

### 15.1.2 Определение узла устройства

① Определение узла устройства для USB накопителя

		На рисунке ниже показано содержимое директории /dev/ до вставки USB накопителя

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0002.png)

		Когда мы вставляем USB накопитель, содержимое директории /dev/ выглядит так, как показано на рисунке ниже

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0003.png)

		Из этих двух рисунков четко видно, что после вставки USB накопителя в директории /dev/ появились sda и sda1, очевидно, что эти два элемента связаны с нашим USB накопителем.

		Когда мы вставляем USB накопитель, система Linux обычно отображает, какой узел устройства был создан. На рисунке ниже показана информация, полученная в последовательном терминале после вставки USB накопителя, которая указывает на вставку USB накопителя и то, что узел устройства - sda

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0004.png)

		sd означает, что это устройство SCSI или SATA жесткого диска.

		a: означает, что это первый жесткий диск,

		1: это первый раздел этого жесткого диска, также являющийся основным разделом.



		Основываясь на вышеизложенном, мы должны понимать, что означают sda и sda1.

		sda представляет собой все устройство хранения USB накопителя

		sda1 представляет собой первый раздел sda.



② Определение узла устройства для SD карты

		На рисунке ниже показано содержимое директории /dev/ до вставки SD карты

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0002.png)

		Когда мы вставляем SD карту, содержимое директории /dev/ выглядит так, как показано на рисунке ниже

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0005.png)

		Из этих двух рисунков четко видно, что после вставки SD карты в директории /dev/ появились mmcblk0 и mmcblk0p1, очевидно, что эти два элемента связаны с нашей SD картой.

		Когда мы вставляем SD карту, система Linux обычно отображает, какой узел устройства был создан. На рисунке ниже показана информация, полученная в последовательном терминале после вставки SD карты, которая указывает на вставку SD карты и то, что узел устройства - mmcblk0

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0006.png)

		mmc должна быть предшественницей sd, поэтому драйверы sd и mmc являются универсальными, и Linux просто сохранил имена узлов устройств.

blk означает, что это блочное устройство, за которым следует число - номер этого устройства blk0, означающий блочное устройство номер 0, используется для различения блочных устройств.

		p означает раздел, p1 означает, что это первый раздел.



		Основываясь на вышеизложенном, мы должны понимать, что означают mmcblk0 и mmcblk0p1.

		mmcblk0 представляет собой все устройство SD карты

		mmcblk0p1 представляет собой первый раздел устройства SD карты.

### 15.1.3 Разметка разделов

		Мы используем инструмент fdisk для разметки разделов,

		После выполнения fdisk /dev/mmcblk0, введите m (для входа в меню параметров функций), чтобы войти в интерфейс fdisk:

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0007.png)

		Часто используемые команды: d l m p q t w

		Попробуем использовать оставшееся пространство для добавления нового раздела

		В этот момент нажатие w позволит сохранить информацию о разделе в таблицу разделов и выйти из fdisk; если вы считаете, что эта операция неверна, можете напрямую нажать q, чтобы отменить все действия инструмента fdisk и выйти из fdisk.

### 15.1.4 Форматирование и монтирование

		В предыдущем разделе мы создали новый раздел, наш второй раздел - /dev/mmcblk0p2, тип раздела - Linux, теперь мы можем отформатировать его командой mkfs.ext3 /dev/mmcblk0p2

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0009.png)

		Теперь мы можем использовать команду mount для монтирования этого раздела в нужную нам директорию

```c
mount -t ext3 /dev/mmcblk0p2 /mnt/
```

		Используйте команду df -Th, чтобы проверить успешность монтирования.

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0010.png)

		Конечно, мы также можем смонтировать раздел mmcblk0p1, также сначала отформатировав этот раздел в определенной файловой системе, затем используя команду mount с указанием формата монтирования, и, наконец, проверив успешность монтирования командой df -Th.

		Операции разметки, форматирования и монтирования для USB накопителя аналогичны SD карте, только вместо /dev/mmcblk0 используется /dev/sda1.

#### 15.1.5 Описание таблицы разделов

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0011.png)

    На рисунке выше показана информация, отображаемая функцией p в fdisk для вывода таблицы разделов.

    Device: показывает, какой это раздел, здесь указано, что это раздел mmcblk0;

    Boot: показывает флаг загрузочного раздела;

    StartCHS: начальный цилиндр, головка, сектор раздела;

    EndCHS: конечный цилиндр, головка, сектор раздела;

    StartLBA: начальная позиция логического блочного адреса;

    EndLBA: конечная позиция логического блочного адреса;

    Sectors: количество секторов;

    Size: размер раздела.

    Id и Type: появляются парой, id представляет номер типа файловой системы, type представляет метку типа файловой системы



		Примечание: Id и Type здесь фактически только метки, и не означают фактического преобразования в нужный нам формат файловой системы, поэтому если нужно монтировать, все равно необходимо отформатировать соответствующей командой mkfs в нужный формат файловой системы перед монтированием.



## 15.2 Автоматическое монтирование USB накопителя

### 15.2.1 Правила udev

		udev - это стандартный инструмент управления устройствами в Linux (после ядра linux 2.6). udev работает в виде демона, прослушивая uevent, отправляемые ядром, для управления файлами устройств в директории /dev. Путем написания соответствующих правил udev можно выполнять заданные действия при изменении узлов устройств, например, эксперимент с горячим подключением, описанный в этом разделе.

		Давайте познакомимся с часто используемыми правилами udev.

		1) Строки, начинающиеся с "#", и пустые строки в файлах правил игнорируются;

   	 2) Файлы правил должны иметь расширение .rules, иначе они будут проигнорированы;

   	 3) Файлы правил расположены в: системной директории правил(/usr/lib/udev/rules.d), директории правил времени выполнения(/run/udev/rules.d), локальной директории правил(/etc/udev/rules.d), /etc/ имеет наивысший приоритет, /run/ имеет средний приоритет, /usr/lib/ имеет самый низкий приоритет, то есть мы можем добавлять новые правила в локальную директорию правил(/etc/udev/rules.d), она имеет наивысший приоритет, и если существуют аналогичные правила с более низким приоритетом, они будут заменены новыми правилами с более высоким приоритетом, чем меньше число в начале имени файла правил, тем раньше оно выполняется.

   	 4) "Ключи" бывают двух типов: сопоставление и присваивание. Если все ключи сопоставления в правиле успешно совпадают, то считается, что это правило успешно сопоставлено, и все ключи присваивания в этом правиле получат указанные значения.

    Ключи сопоставления:

    ①"==" равно;

    ②"!=" не равно;

    ③"ACTION" сопоставление действия события, например "add" означает вставку устройства;

    ④"KERNEL" сопоставление имени устройства ядра, например sda;

    ⑤"SUBSYSTEM" подсистема, к которой принадлежит. Например "sound" или "net" и т.д.

    Ключи присваивания:

    ①"=", присвоить ключу указанное значение;

    ②"LABEL" установить метку, которую можно использовать как цель для перехода GOTO;

    ③"GOTO" перейти к следующему совпадающему правилу с меткой LABEL;

    ④"RUN"{тип} для каждого события устройства, после обработки правил, можно выполнить список программ (по умолчанию пустой). Различные "типы" имеют следующие значения: "program" внешняя программа, если это относительный путь, то считается относительно директории /usr/lib/udev. В противном случае должен использоваться абсолютный путь. Если "тип" не указан явно, это значение по умолчанию. "builtin" аналогично program, но используется только для обозначения встроенных программ. Имя программы и ее аргументы разделяются пробелами. Если в аргументах есть пробелы, они должны быть заключены в одинарные кавычки ('). Можно использовать только программы переднего плана с очень коротким временем выполнения, нельзя устанавливать никаких фоновых демонов или долго выполняющихся программ



		Для более подробной информации о udev можно обратиться к этим двум статьям "udev 中文手册 [金步国]", "Writing udev rules.html", ссылки на статьи сохранены в соответствующей директории этой главы.

### 15.2.2 Регулярные выражения

		При сопоставлении устройств в udev используются регулярные выражения, давайте кратко ознакомимся с ними. Для более подробной информации можно обратиться к статье "正则表达式30分钟入门教程", ссылка на статью сохранена в соответствующей директории этой главы.

①При поиске файлов на компьютере, если нужно найти файлы '.c', мы обычно используем '*.c' для поиска всех файлов '.c', как показано ниже

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0012.png)

Здесь используемый * - это подстановочный символ, представляющий любые символы.



②Если мы хотим более точное выражение, подстановочные символы будут бессильны, поэтому были введены регулярные выражения.

·: представляет любой символ (кроме символа новой строки);

*: представляет повторение 0 или более раз;

+: представляет повторение 1 или более раз;

?: представляет повторение 0 или 1 раз;

[~]: представляет один из символов внутри, например [abc] представляет один из abc, [1-9] представляет один из чисел от 1 до 9.

		Например, leds?[1-3], где s? означает, что s появляется 0 или 1 раз, [1-3]? означает один из чисел от 1 до 3, появляется 0 или 1 раз, согласно этой информации результат сопоставления будет leds, led1, led2, led3. Мы одним выражением сопоставили 4 устройства, как лаконично.

### 15.2.3 Автоматическое монтирование USB накопителя

①Создать директорию для монтирования USB накопителя

```c
mkdir /mnt/usb -p
```

②В директории /etc/udev/rules.d добавить правило для обнаружения вставки USB накопителя (add), выполните в терминале следующую команду для создания первого правила вставки USB накопителя.

```c
vim /etc/udev/rules.d/11-add-usb.rules
```

В 11-add-usb.rules добавьте следующее содержимое:

```c
ACTION!="add",GOTO="END"
KERNEL=="sda[0-9]",RUN+="/etc/mount-usb.sh %k"
LABEL="END"
```

		Значение вышеприведенного содержимого: если это не событие add (добавления), то перейти к метке END и завершить, если это событие add, то выполнить следующие правила, если добавленное устройство является любым из sda0 до sda9, то выполнить содержимое после RUN, здесь это скрипт для монтирования USB накопителя, он также имеет параметр %k, представляющий значение kernel.

		Затем в директории /etc/ создайте скрипт mount-usb.sh

		В mount-usb.sh добавьте следующее содержимое:

```c
#!/bin/sh
mount  -t vfat /dev/$1 /mnt/usb
sync
```

		Значение вышеприведенного содержимого: #!/bin/sh означает, что это файл скрипта, анализируется как файл скрипта, mount -t vfat /dev/$1 /mnt/usb означает монтирование /dev/$1 в директорию /mnt/usb в формате vfat, где $1 - это переданное ранее из правила %k, то есть значение kernel. Sync означает синхронизацию данных USB накопителя.

		Наконец, не забудьте добавить права на выполнение файлу скрипта.

```c
chmod +x /etc/mount-usb.sh
```

③В директории /etc/udev/rules.d добавить правило для обнаружения извлечения USB накопителя (remove), выполните в терминале следующую команду для создания правила извлечения USB накопителя.

```c
vim /etc/udev/rules.d/11-remove-usb.rules
```

В 11-remove-usb.rules добавьте следующее содержимое:

```c
ACTION!="remove",GOTO="END"
KERNEL=="sda[0-9]",RUN+="/etc/umount-usb.sh %k"
LABEL="END"
```

Значение вышеприведенного содержимого: если это не событие remove (удаления), то перейти к метке END и завершить, если это событие remove, то выполнить следующие правила, если извлеченное устройство является любым из sda0 до sda9, то выполнить содержимое после RUN, здесь это скрипт для размонтирования USB накопителя, он также имеет параметр %k, представляющий значение kernel.

		Затем в директории /etc/ создайте скрипт umount-usb.sh

    	В umount-usb.sh добавьте следующее содержимое:

```c
#!/bin/sh
sync
umount /mnt/usb
```

    	Значение вышеприведенного содержимого: #!/bin/sh означает, что это файл скрипта, анализируется как файл скрипта, сначала синхронизировать данные USB накопителя, затем размонтировать, где $1 - это переданное ранее из правила %k, то есть значение kernel.

    	Наконец, не забудьте добавить права на выполнение файлу скрипта.

```c
chmod +x /etc/umount-usb.sh
```

④После настройки правил, когда мы вставляем USB накопитель, выполнение df -Th покажет следующее

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0013.png)

   	 Это указывает, что /dev/sda1 успешно смонтирован в директорию /mnt/usb.

    	Примечание 1: формат vfat также является форматом fat32, формат vfat используется потому, что он поддерживается как операционной системой Windows, так и операционной системой Linux, таким образом USB накопитель может служить носителем для обмена файлами между операционными системами Windows и Linux.

    	Примечание 2: При записи в USB накопитель и другие носители информации в системе Linux, иногда для эффективности данные записываются в filesystem buffer, этот buffer - это область памяти, если нужно действительно записать в USB накопитель и другие носители информации, необходимо выполнить команду sync, она заставит данные, хранящиеся в buffer, записаться в USB накопитель и другие носители информации, вот почему в скрипте добавлена команда sync.



## 15.3 После монтирования - обычные операции чтения и записи файлов

    	После успешного монтирования мы можем выполнять операции с файлами в директории монтирования, такие как создание, изменение и т.д., что эквивалентно операциям с файлами на USB накопителе.

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0014.png)

  	  Как показано на рисунке выше, мы в терминале используем следующие команды для создания двух текстовых файлов.

```c
touch /mnt/usb/111.txt
touch /mnt/usb/222.txt
```

		Затем извлекаем USB накопитель, вставляем в компьютер и проверяем, существуют ли 111.txt и 222.txt

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0015.png)

		Мы можем добавить содержимое в эти файлы, затем снова вставить в отладочную плату и проверить, отображается ли содержимое, измененное на компьютере, на отладочной плате. Добавим abc в 111.txt, 100ask в 222.txt, сохраним, извлечем USB накопитель, вставим в отладочную плату. Используем команду cat для просмотра содержимого, как показано ниже

![](http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0016.png)

		Отображаемое содержимое правильное, теперь мы можем через USB накопитель переносить данные с компьютера на отладочную плату.
