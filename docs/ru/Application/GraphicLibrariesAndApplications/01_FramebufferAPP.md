# 1 Разработка приложений для Framebuffer

## 1.1 Принцип работы LCD Framebuffer

LCD Framebuffer — это область видеопамяти, которая в встраиваемых системах является частью оперативной памяти. Несколько байт в LCD Framebuffer (количество определяется конфигурацией драйвера контроллера LCD) представляют один пиксель на экране LCD, причём существует взаимно-однозначное соответствие для всего экрана. Например, для LCD экрана с разрешением 800×600 имеется 480000 пикселей. Если каждый пиксель представлен 4 байтами, то размер видеопамяти LCD Framebuffer составляет 480000 × 4 = 960000 байт, то есть 1.92 МБ. Таким образом, наша оперативная память выделит как минимум 1.92 МБ пространства для видеопамяти. Конкретный адрес определяется драйвером, приложению нужно только использовать его напрямую, все операции, связанные с аппаратным обеспечением, уже инкапсулированы драйвером.

![FramebufferAPP_Image00001](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00001.png)

Как показано на рисунке выше, нам нужно только заполнить Framebuffer различными значениями, и драйвер вместе с аппаратным контроллером передадут эти данные соответствующим пикселям на экране LCD, отображая различные цвета. Таким образом, нашему приложению нужно работать только с Framebuffer, всё остальное берут на себя драйвер и аппаратное обеспечение.

## 1.2 API интерфейс Framebuffer

### 1.2.1 Системный вызов open

![FramebufferAPP_Image00002](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00002.png)

Заголовочные файлы: #include <sys/types.h>, #include <sys/stat.h>, #include <fcntl.h>

Прототип функции:

- int open(const char *pathname, int flags);
- int open(const char *pathname, int flags, mode_t mode);

Описание функции:

- pathname указывает путь к открываемому файлу;

- Flags указывает режим открытия файла, наиболее часто используются следующие 6 режимов:

  ① O_RDWR — открытие для чтения и записи;

  ② O_RDONLY — открытие только для чтения;

  ③ O_WRONLY — открытие только для записи;

  ④ O_APPEND — если в файле уже есть содержимое, новые данные будут добавлены после существующих;

  ⑤ O_TRUNC — если в файле уже есть содержимое, оригинальное содержимое будет отброшено, файл будет усечён;

  ⑥ O_CREAT — если открываемый файл не существует, создаём его и открываем, обычно используется вместе с O_EXCL: когда файла нет, создаётся файл, если файл существует, возвращается ошибка;

Mode указывает права доступа при создании файла, действителен только когда в flags используется O_CREAT, в противном случае игнорируется.

Возвращаемое значение: при успехе возвращает дескриптор файла, при ошибке возвращает -1.

### 1.2.2 Системный вызов ioctl

![FramebufferAPP_Image00003](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00003.png)

Заголовочный файл: #include <sys/ioctl.h>

Прототип функции:

- int ioctl(int fd, unsigned long request, ...);

Описание функции:

- fd — дескриптор файла;
- request — команда для взаимодействия с драйвером, различные команды управляют выводом нужных нам данных драйвером;
- … — переменные параметры arg, в зависимости от команды request драйвер устройства возвращает выходные данные.

Возвращаемое значение: при успехе возвращает дескриптор файла, при ошибке возвращает -1.

### 1.2.3 Системный вызов mmap

![FramebufferAPP_Image00004](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00004.png)

Заголовочный файл: #include <sys/mman.h>

Прототип функции:

- void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);

Описание функции:

- addr указывает начальный адрес отображаемой памяти, обычно устанавливается в NULL, позволяя системе автоматически выбрать адрес, который возвращается после успешного отображения;

- length указывает, какой объём содержимого файла отображается в память;

- prot указывает способ защиты отображаемой области, может быть комбинацией следующих 4 режимов:

  ① PROT_EXEC — отображаемая область может исполняться

  ② PROT_READ — отображаемая область может читаться и записываться

  ③ PROT_WRITE — отображаемая область может записываться

  ④ PROT_NONE — отображаемая область недоступна

- Flags указывает различные характеристики, влияющие на отображаемую область, часто используются следующие два режима:

  ① MAP_SHARED — данные, записанные в отображаемую область, копируются обратно в файл, исходный файл изменяется.

  ② MAP_PRIVATE — операции с отображаемой областью создают копию отображаемого файла, любые изменения этой области не записываются обратно в исходный файл.

Возвращаемое значение: при успешном отображении возвращает указатель на отображаемую область, при ошибке возвращает -1.

## 1.3 Операции рисования точек на LCD

### 1.3.1 Теоретические основы отображения точечной матрицы на LCD

![FramebufferAPP_Image00005](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00005.png)

Как показано на рисунке выше, когда нам нужно отобразить букву 'A', мы определяем состояние каждого бита точечной матрицы и заполняем цветом, достигая эффекта отображения символа. Где '1' представляет один цвет, а '0' — другой цвет. На рисунке показана точечная матрица 8×16, мы также можем использовать точечные матрицы других размеров, главное иметь эту матрицу, и мы сможем рисовать точки на LCD, достигая эффекта отображения символов.

### 1.3.2 Получение структуры fb_var_screeninfo

Перед использованием точечной матрицы для отображения символов нам нужно сначала получить соответствующую информацию LCD из устройства fb0. На рисунке ниже показана часть содержимого структуры fb_info, которую мы будем использовать.

![FramebufferAPP_Image00006](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00006.png)

С помощью системного вызова ioctl получаем xres (общее количество пикселей по направлению x), yres (общее количество пикселей по направлению y), bits_per_pixel (количество бит на пиксель). Используя эти три ресурса плюс точечную матрицу, мы можем отобразить символ.

Файл программы: show_ascii.c

```c
4718        fd_fb = open("/dev/fb0", O_RDWR);
4719        if (fd_fb < 0)
4720        {
4721            printf("can't open /dev/fb0\n");
4722            return -1;
4723        }
4724        if (ioctl(fd_fb, FBIOGET_VSCREENINFO, &var))
4725        {
4726			printf("can't get var\n");
4727			return -1;
4728		}
```

Сначала открываем устройство LCD (fb0), получаем дескриптор файла, затем через ioctl получаем информацию fb_var_screeninfo и сохраняем в переменной var. В дальнейшем нужно только обращаться к структуре var для получения xres (общее количество пикселей по направлению x), yres (общее количество пикселей по направлению y), bits_per_pixel (количество бит на пиксель) — этих трёх ресурсов fb0.

### 1.3.3 Вычисление переменных на основе fb_var_screeninfo

fb_var_screeninfo уже сохранён в переменной структуры var, теперь обращаемся к переменной структуры var.

Вычисляем количество байт, занимаемых каждой строкой пикселей, на основе xres и bits_per_pixel.

Файл программы: show_ascii.c

```c
4730	line_width  = var.xres * var.bits_per_pixel / 8;
```

Вычисляем количество байт, занимаемых каждым пикселем, на основе bits_per_pixel.

Файл программы: show_ascii.c

```c
4731    pixel_width = var.bits_per_pixel / 8;
```

Вычисляем общее количество байт, занимаемых всеми пикселями, на основе xres, yres, bits_per_pixel.

Файл программы: show_ascii.c

```c
4732    screen_size = var.xres * var.yres * var.bits_per_pixel / 8;
```

### 1.3.4 Использование системного вызова mmap для отображения памяти

Файл программы: show_ascii.c

```c
4733	fbmem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | 			PROT_WRITE, MAP_SHARED, fd_fb, 0);
4734	if (fbmem == (unsigned char *)-1)
4735	{
4736		printf("can't mmap\n");
4737		return -1;
4738	}
4739
4740	/* Очистка экрана: устанавливаем всё в чёрный цвет */
4741	memset(fbmem, 0, screen_size);
```

Вызываем mmap для отображения видеопамяти в память с возможностью чтения и записи (PROT_READ | PROT_WRITE) и обратной записи в память (MAP_SHARED), получая указатель на начало отображённого пространства памяти fbmem. Далее все операции основаны на вычислении различных смещений от этого начального адреса и заполнении значениями цвета.

### 1.3.5 Написание функции рисования точек

Файл программы: show_ascii.c

```c
4641	void lcd_put_pixel(int x, int y, unsigned int color)
```

Функция рисования точек имеет 3 параметра: координата x, координата y, значение цвета пикселя.

Файл программы: show_ascii.c

```c
4643		unsigned char *pen_8 = fbmem+y*line_width+x*pixel_width;
4644		unsigned short *pen_16;
4645		unsigned int *pen_32;
4646
4647		unsigned int red, green, blue;
4648
4649		pen_16 = (unsigned short *)pen_8;
4650		pen_32 = (unsigned int *)pen_8;
```

Здесь параметры функции x и y представляют координаты пикселя, а размер видеопамяти, занимаемый одним пикселем, может быть разным: возможно 1 байт на пиксель, 2 байта на пиксель, 4 байта на пиксель и т.д. Для совместимости с различными ситуациями объявляем 3 указателя: pen_8 указывает на пространство пикселя размером 1 байт, pen_16 указывает на пространство пикселя размером 2 байта, pen_32 указывает на пространство пикселя размером 4 байта.

fbmem — это начальный адрес видеопамяти, возвращённый системным вызовом mmap, на основе fbmem вычисляем адрес памяти для заполнения цветом.

Когда пиксель занимает 1 байт пространства:

Адрес для рисования точки = fbmem + Y × количество байт в строке + x × количество байт на пиксель

Файл программы: show_ascii.c

```c
4652		switch (var.bits_per_pixel)
4653		{
4654			case 8:
4655			{
4656				*pen_8 = color;
4657				break;
4658			}
4659			case 16:
4660			{
4661				/* 565 */
4662				red   = (color >> 16) & 0xff;
4663				green = (color >> 8) & 0xff;
4664				blue  = (color >> 0) & 0xff;
4665				color = ((red >> 3) << 11) | ((green >> 2) << 5) | 						(blue >> 3);
4666				*pen_16 = color;
4667				break;
4668			}
4669			case 32:
4670			{
4671				*pen_32 = color;
4672				break;
4673			}
4674			default:
4675			{
4676				printf("can't surport %dbpp\n", var.bits_per_pixel);
4677				break;
4678			}
4679		}
4680	}

```

В зависимости от фактического значения bits_per_pixel устройства fb0 выбираем соответствующий pen (pen_8, pen_16 или pen_32), затем передаём переменную цвета color в выбранный pen.

## 1.4 Вывод текста на LCD с использованием точечной матрицы

### 1.4.1 Отображение английских букв на LCD

① Находим адрес английской буквы в массиве точечной матрицы, где c представляет английскую букву (значение ASCII).

Файл программы: show_ascii.c

```c
4693		unsigned char *dots = (unsigned char *)&fontdata_8x16[c*16];
```

② На основе полученной точечной матрицы английской буквы последовательно проверяем каждый бит, рисуем точки: '1' означает белый цвет, '0' — чёрный.

![FramebufferAPP_Image00007](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00007.png)

Исходя из рисунка выше, проанализируем, как использовать точечную матрицу для отображения английской буквы на LCD. Поскольку имеется шестнадцать строк, сначала нужен большой цикл на 16 итераций, затем в каждой строке 8 бит, поэтому внутри каждого большого цикла нужен малый цикл на 8 итераций. В малом цикле проверяем состояние рисования точек в одной строке: если это 1, заполняем белым цветом, если 0 — заполняем чёрным. Таким образом, мы можем отобразить английскую букву с чёрным фоном и белым контуром.

Файл программы: show_ascii.c

```c
4697		for (i = 0; i < 16; i++)
4698		{
4699			byte = dots[i];
4700			for (b = 7; b >= 0; b--)
4701			{
4702				if (byte & (1<<b))
4703				{
4704					/* show */
4705					lcd_put_pixel(x+7-b, y+i, 0xffffff); /* белый */
4706				}
4707				else
4708				{
4709					/* hide */
4710					lcd_put_pixel(x+7-b, y+i, 0); /* чёрный */
4711				}
4712			}
4713	}
```

③ Вызываем написанную нами функцию lcd_put_ascii

Файл программы: show_ascii.c

```c
4743 lcd_put_ascii(var.xres/2, var.yres/2, 'A'); /*отображаем букву A размером 8×16 в центре экрана*/
```

④ Компилируем файл show_ascii.c

Команда компиляции: arm-linux-gnueabihf-gcc -o show_ascii show_ascii.c

⑤ Передаём скомпилированный файл show_ascii на отладочную плату и переходим в директорию show_ascii

Выполняем команду: ./show_ascii

Если эксперимент успешен, мы увидим белую букву 'A' в центре экрана.

### 1.4.2 Отображение китайских иероглифов на LCD

![FramebufferAPP_Image00008](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00008.png)

В отличие от отображения английских букв, точечные матрицы китайских иероглифов нужно извлекать из файла шрифтов, они не предоставляются напрямую в виде массива. Поэтому в начале программы нужно открыть файл шрифтов (HZK16), затем найти соответствующую позицию, извлечь точечную матрицу иероглифа и отобразить его так же, как английскую букву, но этот иероглиф размером 16×16.

① Открываем файл шрифтов китайских иероглифов

Файл программы: show_font.c

```c
4760	fd_hzk16 = open("HZK16", O_RDONLY);
```

② Получаем атрибуты файла шрифтов, сохраняем в переменной структуры hzk_stat

Файл программы: show_font.c

```c
4793	if(fstat(fd_hzk16, &hzk_stat))
```

Здесь в основном нужно узнать размер файла, так как он понадобится для mmap далее.

③ Используем системный вызов mmap

Файл программы: show_font.c

```c
4798	hzkmem = (unsigned char *)mmap(NULL , hzk_stat.st_size, 				PROT_READ, MAP_SHARED, fd_hzk16, 0);
```

hzkmem аналогичен fbmem, это также указатель на отображённую память, но он указывает на файл шрифтов, что удобно для последующего вычисления позиции смещения точечной матрицы иероглифа.

④ Используем файл шрифтов для извлечения точечной матрицы и отображения иероглифа

Файл шрифтов HZK16 соответствует стандарту GB2312 и представляет собой библиотеку шрифтов размером 16×16 точек. Кодировка HZK16: для каждого иероглифа требуется 32 байта точечной матрицы. Например, для иероглифа '中', который мы будем отображать, кодировка — D6D0. Неужели это всего 2 байта? Но не говорилось ли о 32 байтах? Кодировка D6D0 — это что-то вроде индексного кода, D6 — код зоны, D0 — код позиции. Сначала нужно найти настоящую зону D6-A1, затем в этой зоне найти настоящую позицию D0-A1 — это и есть начальная позиция точечной матрицы иероглифа '中' (вычитание A1 нужно для совместимости с ascii). В каждой зоне 94 иероглифа.

Файл программы: show_font.c

```c
4734		unsigned int area  = str[0] - 0xA1;
4735		unsigned int where = str[1] - 0xA1;
4736		unsigned char *dots = hzkmem + (area * 94 + where)*32;
```

![FramebufferAPP_Image00009](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00009.png)

На рисунке выше показана схема расположения точечной матрицы иероглифа. Всего шестнадцать строк, поэтому нужен большой цикл на 16 итераций. Учитывая, что в каждой строке два байта, внутри большого цикла добавляем цикл на 2 итерации для различения байтов. Наконец, проверяем каждый бит текущего байта: если '1', рисуем белым, если '0' — чёрным.

Файл программы: show_font.c

```c
4740	for (i = 0; i < 16; i++)
4741			for (j = 0; j < 2; j++)
4742			{
4743				byte = dots[i*2 + j];
4744				for (b = 7; b >=0; b--)
4745				{
4746					if (byte & (1<<b))
4747					{
4748						/* show */
4749						lcd_put_pixel(x+j*8+7-b, y+i, 0xffffff); /* белый */
4750					}
4751					else
4752					{
4753						/* hide */
4754						lcd_put_pixel(x+j*8+7-b, y+i, 0); /* чёрный */
4755					}
4756				}
4757			}
```

⑤ Вызываем написанную нами функцию lcd_put_chinese

Файл программы: show_font.c

```c
4810	printf("chinese code: %02x %02x\n", str[0], str[1]);
4811	lcd_put_chinese(var.xres/2 + 8,  var.yres/2, str);
```

⑥ Компилируем файл show_font.c

Команда компиляции: arm-linux-gnueabihf-gcc -o show_font show_font.c

Примечание: при использовании этой команды файл HZK16 должен находиться в той же директории, что и show_font.c.

⑦ Передаём скомпилированный show_font на отладочную плату и переходим в директорию show_font

Выполняем команду: ./show_font

Если эксперимент успешен, мы увидим в центре экрана белую букву 'A' и китайский иероглиф '中', а в выводе последовательного порта увидим код, соответствующий '中'.

`chinese code: d6 d0`

## 1.5 Настройка окружения для freetype

### 1.5.1 Кросс-компиляция freetype и установка

① Распаковываем исходные файлы freetype

```c
tar xjf freetype-2.4.10.tar.bz2
```

② Переходим в распакованную директорию freetype-2.4.10

```c
cd freetype-2.4.10
```

③ Конфигурируем freetype-2.4.10

```c
./configure --host=arm-linux-gnueabihf --prefix=/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/
```

④ Создаём директорию, чтобы избежать ошибки установки из-за отсутствия директории internal

```c
mkdir /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype/internal -p
```

④ Компилируем

```c
make
```

⑤ Устанавливаем

```c
make install
```

⑥ Перемещаем заголовочные файлы freetype, чтобы избежать необходимости указывать путь к заголовочным файлам при компиляции

```c
mv /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/
```

#### 1.5.2 Перенос библиотек и заголовочных файлов freetype на отладочную плату

Поскольку на отладочной плате 100ask уже есть соответствующие библиотеки и заголовочные файлы freetype, перенос не требуется. Если на отладочной плате нет библиотек и заголовочных файлов freetype, нужно выполнить перенос следующим способом:

Скопировать /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/* в директорию заголовочных файлов отладочной платы

Скопировать /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib/*so* в директорию библиотек отладочной платы

Примечание: для символических ссылок нужно сохранить их атрибуты ссылки (т.е. добавить опцию -d).

## 1.6 Использование freetype

### 1.5.1 Введение в векторные шрифты

При отображении английских букв и китайских иероглифов с помощью точечной матрицы размер фиксирован, при увеличении появляются зубчатые края. Для решения этой проблемы используются векторные шрифты.

Формирование векторного шрифта состоит из трёх этапов: несколько ключевых точек, математические кривые (кривые Безье) и заполнение цветом.

① Предположим, ключевые точки буквы A обозначены жёлтыми кружками на рисунке, определяем ключевые точки.

![FramebufferAPP_Image00010](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00010.png)

② Соединяем ключевые точки математическими кривыми, формируя замкнутую кривую.

![FramebufferAPP_Image00011](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00011.png)

③ Заполняем замкнутое пространство цветом, отображая букву A.

![FramebufferAPP_Image00012](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00012.png)

Если нужно увеличить или уменьшить шрифт, относительное положение ключевых точек не меняется, они увеличиваются или уменьшаются в соответствии с коэффициентом масштабирования, но относительное положение остаётся неизменным, подобно дробям 1/2 и 2/4: пропорция не меняется, но значение увеличилось.

### 1.5.2 Теоретическое введение в Freetype

Библиотека векторных шрифтов Freetype с открытым исходным кодом предоставляет единый интерфейс для доступа к файлам шрифтов различных форматов, реализуя отображение векторных шрифтов. Нам нужно только перенести этот движок шрифтов, вызвать соответствующие API интерфейсы, предоставить ключевые точки шрифта, и библиотека freetype поможет нам реализовать замкнутые кривые, заполнение цветом, достигая цели отображения векторных шрифтов.

Ключевые точки (glyph) хранятся в файлах шрифтов. Windows использует файлы шрифтов в директории FONTS, файлы с расширением TTF — это векторные библиотеки шрифтов. В данном эксперименте используется китайский шрифт SimSun — simsun.ttc.

![FramebufferAPP_Image00013](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00013.png)

Структура файла шрифтов показана на рисунке выше.

Charmaps представляет таблицу отображения символов. Файл шрифтов может поддерживать различные кодировки: GBK, UNICODE, BIG5 или другие. Если файл шрифтов поддерживает кодировку, на основе кодировки через charmap находим соответствующий glyph. Обычно поддерживается код UNICODE.

Имея эту основу, представим процесс отображения текста:

- ① Дан код символа 'A' (0x41), '中' (GBK, UNICODE, BIG5), можно определить его значение кодировки;
- ② На основе значения кодировки через charmap находим соответствующие ключевые точки (glyph) в файле шрифтов;
- ③ Устанавливаем размер шрифта;
- ④ С помощью функций масштабируем ключевые точки (glyph) до установленного размера шрифта;
- ⑤ Преобразуем в точечную растровую матрицу;
- ⑥ Отображаем на LCD.

![FramebufferAPP_Image00014](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00014.png)

Как показано на рисунке выше, см. step1, step2, step3, можно изучить, как использовать библиотеку freetype. Обобщённые шаги следующие:

① Инициализация: FT_InitFreetype

② Загрузка (открытие) шрифта Face: FT_New_Face

③ Установка размера шрифта: FT_Set_Char_Sizes или FT_Set_Pixel_Sizes

④ Выбор charmap: FT_Select_Charmap

⑤ На основе кода символа charcode находим glyph: glyph_index = FT_Get_Char_Index(face, charcode)

⑥ На основе glyph_index извлекаем glyph: FT_Load_Glyph(face, glyph_index)

⑦ Преобразуем в растровое изображение: FT_Render_Glyph

⑧ Перемещение или вращение: FT_Set_Transform

### 1.5.2 Отображение векторного шрифта на LCD

![FramebufferAPP_Image00015](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00015.png)

Мы можем написать программу, опираясь на программу c по указанному пути на рисунке выше.

① Инициализируем библиотеку freetype

Файл программы: freetype_show_font.c

```c
4872	error = FT_Init_FreeType( &library );		/* initialize library */
```

② Используем функцию FT_New_Face из библиотеки freetype для создания объекта файла шрифтов face, сохраняем в &face

Файл программы: freetype_show_font.c

```c
4875    error = FT_New_Face( library, argv[1], 0, &face ); /* create face object */
```

③ Извлекаем из объекта face glyph, то есть набор ключевых точек

Файл программы: freetype_show_font.c

```c
4877    slot = face->glyph;
```

④ Устанавливаем размер пикселя 24×24

Файл программы: freetype_show_font.c

```c
4879    FT_Set_Pixel_Sizes(face, 24, 0);
```

⑤ Определяем координаты

До сих пор мы использовали систему координат LCD для координат x и y, однако в freetype используется декартова система координат, поэтому нужно преобразовать координаты x и y.

![FramebufferAPP_Image00017](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00017.png)

Мы будем отображать иероглиф '繁'. Согласно рисунку выше, сначала вычисляем координаты x и y левого нижнего угла иероглифа '繁' в системе координат lcd, поскольку в декартовой системе координат левый нижний угол является началом координат символа, 'A' находится в центре экрана, то есть (xres/2, yres/2).

- lcd_x = var.xres/2 + 8 + 16; lcd_y = var.yres/2 + 16
- Тогда декартовы координаты: x = lcd_x = var.xres/2 + 8 + 16; y = var.yres - lcd_y = var.yres/2 – 16
- Единица измерения — 1/64 пикселя, поэтому нужно умножить на 64

Файл программы: freetype_show_font.c

```c
4888	pen.x = (var.xres/2 + 8 + 16) * 64;
4889	pen.y = (var.yres/2 - 16) * 64;
4890
4891	/* set transformation */
4892    FT_Set_Transform( face, 0, &pen);
```

⑥ Находим позицию glyph, затем извлекаем и преобразуем в растровое изображение

```c
4895    error = FT_Load_Char( face, chinese_str[0], FT_LOAD_RENDER );
4896	if (error)
4897	{
4898		printf("FT_Load_Char error\n");
4899		return -1;
4900	}
```

![FramebufferAPP_Image00018](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00018.png)

Вызов функции FT_Load_Char заменяет эти 3 шага, показанные на рисунке выше.

Наконец, выводим преобразованное растровое изображение, также написано на основе example1.c

Файл программы: freetype_show_font.c

```c
4902 	  draw_bitmap( &slot->bitmap,
4903         	        slot->bitmap_left,
4904             	    var.yres - slot->bitmap_top);
```

Файл программы: example1.c

![FramebufferAPP_Image00019](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00019.png)

Изменяем 3 места на рисунке выше:

- Width (ширина): для отображения на LCD ширина естественно равна количеству пикселей по направлению x, var.xres;

- Height (высота): для отображения на LCD высота естественно равна количеству пикселей по направлению y, var.yres;

- Заменяем массив image функцией рисования точек lcd_put_pixel из эксперимента с точечной матрицей

  lcd_put_pixel(i, j, bitmap->buffer[q * bitmap->width + p]);

⑥ Компилируем файл программы freetype_show_font.c

Команда компиляции: arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font freetype_show_font.c -lfreetype -lm

⑦ Копируем скомпилированный файл freetype_show_font и файл шрифтов simsun.ttc на отладочную плату. Файл шрифтов simsun.ttc размещаем в директории на уровень выше исполняемого файла freetype_show_font и выполняем следующую команду.

Команда выполнения: ./freetype_show_font ../simsun.ttc

Если эксперимент успешен, мы увидим в центре экрана дополнительный синий иероглиф '繁' по сравнению с предыдущим экспериментом.

### 1.5.3 Вращение векторного шрифта на LCD на определённый угол

После реализации отображения векторного шрифта мы можем добавить функцию вращения шрифта на определённый угол.

На основе второго входного параметра определяем угол вращения, основной код всё ещё основан на example1.c

![FramebufferAPP_Image00020](http://photos.100ask.net/NewHomeSite/FramebufferAPP_Image00020.png)

Согласно рисунку выше, добавляем функцию вращения на угол, угол вращения задаётся вторым параметром команды выполнения.

Файл программы: freetype_show_font_angle.c

```c
		/* use 25 degrees */
4894	angle = ( 1.0 * strtoul(argv[2], NULL, 0) / 360 ) * 3.14159 * 2;

4895	/* set up matrix */
4896	matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
4897	matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
4898	matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
4899	matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
4900
4901    /* set transformation */
4902    FT_Set_Transform( face, &matrix, &pen);
```

Наконец, компилируем и запускаем на отладочной плате

Команда компиляции:

Команда компиляции: arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font_angle freetype_show_font_angle.c -lfreetype -lm

Скомпилированный файл называется freetype_show_font_angle, копируем файл на отладочную плату

В директории, содержащей этот файл, выполняем следующую команду. Для корректного выполнения следующей команды необходимо, чтобы исполняемый файл freetype_show_font находился в этой директории, а файл шрифтов simsun.ttc — на уровень выше:

Команда выполнения: ./freetype_show_font_angle ../simsun.ttc 90

Если эксперимент успешен, мы увидим синий иероглиф '繁' в центре экрана, повёрнутый на 90 градусов.
