# 2 Обработка изображений

Предисловие: все файлы изображений представляют собой двоичные файлы определённого формата. Каждый файл изображения может быть проанализирован путём интерпретации значения каждой группы двоичных данных в файле для получения различной информации, такой как высота изображения, ширина, количество бит на пиксель и т.д. Просто значения двоичных данных различаются в зависимости от формата файла. Мы можем открыть файл изображения с помощью программного обеспечения UltraEdit и просмотреть расположение двоичных данных внутри.

## 2.1 Обработка изображений BMP

### 2.1.1 Анализ формата файла BMP

BMP — это распространённый формат изображений. Файл BMP можно рассматривать как состоящий из 4 частей: заголовок файла растрового изображения (bitmap-file header), информационный заголовок растрового изображения (bitmap-information header), палитра (color palette) и массив байтов, определяющий растровое изображение. В качестве примера рассмотрим простейший файл BMP с 24-битным истинным цветом:

1. Заголовок файла растрового изображения (bitmap-file header)

Эту часть можно рассматривать как структуру, где каждый член представляет атрибут

Заголовок файла растрового изображения состоит из следующей информации:

| Название    | Размер | Значение                                                         |
| :---------- | ------ | :----------------------------------------------------------- |
| bfType      | 2 байта  | Указывает, что это файл формата BMP,<br />содержимое фиксировано: 0x42,0x4D,<br />то есть символы ASCII "B""M" |
| bfSize      | 4 байта  | Размер файла BMP в байтах                                    |
| bfReserved1 | 2 байта  | Зарезервировано                                                         |
| bfReserved2 | 2 байта  | Зарезервировано                                                         |

Открыв файл BMP с помощью UltraEdit, мы можем увидеть следующую информацию:

![ImageProcess_Image001](http://photos.100ask.net/NewHomeSite/ImageProcess_Image001.png)

Это первые 32 байта данных файла BMP. Видно, что первые два байта — 0x42, 0x4D;

Следующие 4 байта последовательно: 0x36, 0xF9, 0x15, 0x00.

В формате BMP данные файла хранятся в режиме little-endian (младший байт в младшем адресе), то есть если данные представлены несколькими байтами, то младшие данные хранятся по младшему адресу, а старшие данные — по старшему адресу. Аналогично существует режим big-endian (старший байт в младшем адресе): если данные представлены несколькими байтами, то младшие данные хранятся по старшему адресу, а старшие данные — по младшему адресу.

Поэтому четыре байта данных 0x36, 0xF9, 0x15, 0x00 следует объединять так: 0x0015F936 (в числах единицы, то есть крайняя правая позиция — это младший разряд), что как раз и есть размер этого файла:

![ImageProcess_Image002](http://photos.100ask.net/NewHomeSite/ImageProcess_Image002.png)

Далее идут 4 зарезервированных байта, данные которых должны быть 0x00.

Наконец, 4 байта смещения, видно, что размер заголовка файла растрового изображения + информационного заголовка растрового изображения + палитры должен быть 0x36.

2. Информационный заголовок растрового изображения (bitmap-information header)

Информационный заголовок растрового изображения также можно рассматривать как структуру, члены которой:

| Название            | Размер | Значение                                                         |
| :-------------- | :----- | :----------------------------------------------------------- |
| biSize          | 4      | Размер всей структуры информационного заголовка растрового изображения                                   |
| biWidth         | 4      | Ширина изображения в пикселях                                         |
| biHeight        | 4      | Высота изображения в пикселях.  Кроме того, знак этого числа<br />может определять направление изображения: если положительное,<br />изображение прямое; если отрицательное, изображение обратное.<br />Разница заключается в способе построения системы координат.<br />Подробнее при написании кода. |
| biPlanes        | 2      | Количество цветовых плоскостей, значение всегда 1                                        |
| biBitCount      | 2      | Количество бит для представления 1 пикселя, значение может<br />быть 1, 4, 8, 16, 24, 32. В нашем примере используется 24-битный<br />истинный цвет |
| biCompression   | 4      | Тип сжатия данных                                               |
| biSizeImage     | 4      | Размер данных изображения в байтах                                   |
| biXPelsPerMeter | 4      | Горизонтальное разрешение в пикселях на метр                                    |
| biYPelsPerMeter | 4      | Вертикальное разрешение в пикселях на метр                                    |
| biClrUsed       | 4      | Количество используемых цветовых индексов в палитре                                         |
| biClrImportant  | 4      | Количество цветовых индексов, важных для изображения,<br />если 0, все важны |

Сопоставляем с исходными данными файла:

![ImageProcess_Image003](http://photos.100ask.net/NewHomeSite/ImageProcess_Image003.png)

0E-11: 00000028h = 40, указывает, что размер этой структуры 40 байт.

12-15: 00000320h = 800, ширина изображения 800 пикселей.

16-19: 00000258h = 600, высота изображения 600 пикселей, что соответствует атрибутам файла. Это положительное число, значит, изображение прямое, данные расположены с началом координат в левом нижнем углу изображения, горизонтально вправо — положительное направление оси X, вертикально вверх — положительное направление оси Y. Если отрицательное, изображение обратное, данные расположены с началом координат в левом верхнем углу изображения, горизонтально вправо — положительное направление оси X, вертикально вниз — положительное направление оси Y.

1A-1B: 0001h, это значение всегда 1.

1C-1D: 0018h = 24, указывает, что каждый пиксель занимает 24 бита, то есть 24-битный истинный цвет

Эта информация соответствует атрибутам файла:

![ImageProcess_Image004](http://photos.100ask.net/NewHomeSite/ImageProcess_Image004.png)

1E-21: 00000000h, BI_RGB, указывает, что изображение не сжато.

22-25: 00000000h, размер изображения, поскольку используется BI_RGB, устанавливается в 0.

26-29: 00000000h, горизонтальное разрешение, по умолчанию.

2A-2D: 00000000h, вертикальное разрешение, по умолчанию.

2E-31: 00000000h, для 24-битного истинного цвета палитры нет, поэтому 0.

32-35: 00000000h, для 24-битного истинного цвета палитры нет, поэтому 0.

3. Палитра (color palette)

У 24-битного истинного цвета палитры нет, для упрощения здесь не рассматриваем.

4. Массив байтов, определяющий растровое изображение

Эта часть — реальные данные изображения. Данные 24-битного истинного цвета расположены циклически по схеме BGR (синий, зелёный, красный) по одному байту на каждый компонент.

###  2.1.2 Реализация кода: анализ файла BMP и преобразование в формат RGB для отображения на LCD

Для отображения файла BMP на LCD отладочной платы нужно обратить внимание на несколько моментов:

1. Формат отображения на LCD отладочной платы — формат RGB, причём существует несколько представлений: может использоваться 2 байта (формат RGB565), может использоваться 3 байта (RGB888), а исходный 24-битный истинный цветной файл BMP расположен в формате BGR, необходимо преобразовать исходные данные изображения.

2. В процессе преобразования адрес видеопамяти LCD фиксирован с началом в левом верхнем углу LCD, а в формате BMP прямое изображение имеет начальный адрес данных в левом нижнем углу изображения. Поэтому при преобразовании данных нужно обратить внимание на преобразование координат.

Код 2.1 реализует преобразование 24-битного истинного цветного изображения BMP в формат RGB

```c
Код 2.1
1.	/**********************************************************************
2.	 * Название функции: IsBmp
3.	 * Описание: определяет, является ли файл файлом BMP
4.	 * Входные параметры: ptFileMap - содержит информацию о файле
5.	 * Выходные параметры: нет
6.	 * Возвращаемое значение: 0 - формат BMP, -1 - не формат BMP
7.	 ***********************************************************************/
8.	int IsBmp(FILE **ppFp, const char *strFileName)
9.	{
10.	    char strCheckHeader[2];
11.	    *ppFp= fopen(strFileName, "rb+");
12.	    if (*ppFp== NULL) {
13.	        return -1;
14.	    }
15.	    if (fread(strCheckHeader, 1, 2, *ppFp) != 2)
16.	        return -1;
17.
18.	    if (strCheckHeader[0] != 0x42 || strCheckHeader[1] != 0x4d)
19.	        return -1;
20.	    else
21.	        return 0;
22.	}
23.
24.
25.
26.	/**********************************************************************
27.	 * Название функции: MapFile
28.	 * Описание: использует функцию mmap для отображения файла в память,
29.	 *           после чего можно напрямую обращаться к файлу через память
30.	 * Входные параметры: PT_PictureData ptData содержит данные изображения
31.	 * Выходные параметры: ptData->iFileSize     : размер файла
32.	 *                        ptData->pucFileData : начальный адрес отображённой памяти
33.	 * Возвращаемое значение: 0      - успех, другое значение - ошибка
34.	 ***********************************************************************/
35.	int MapFile(PT_PictureData ptData)
36.	{
37.	    int iFd;
38.	    struct stat tStat;
39.
40.	    /* Открываем файл */
41.	        iFd = fileno(ptData->ptFp);
42.	    fstat(iFd, &tStat);
43.	    ptData->iFileSize= tStat.st_size;
44.	    ptData->pucFileData= (unsigned char *)mmap(NULL , tStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, iFd, 0);
45.	    if (ptData->pucFileData == (unsigned char *)-1)
46.	    {
47.	        printf("mmap error!\n");
48.	        return -1;
49.	    }
50.	    return 0;
51.	}
52.
53.	/**********************************************************************
54.	 * Название функции: DecodeBmp2Rgb
55.	 * Описание: преобразует файл BMP в формат rgb
56.	 * Входные параметры: strFileName - имя файла
57.	 *                   ptData - содержит информацию об изображении
58.	 * Возвращаемое значение: 0      - успех, другое значение - ошибка
59.	 *                         -1     - файл не формата BMP
60.	 *                         -2     - неподдерживаемый bpp
61.	 *                         -3     - не удалось выделить буфер изображения
62.	 ***********************************************************************/
63.	static int DecodeBmp2Rgb(const char *strFileName, PT_PictureData ptData) {
64.	    int x,y;
65.	    int iPos = 0;
66.	    int iLineWidthAlign;
67.	    BITMAPFILEHEADER *ptBITMAPFILEHEADER;
68.	    BITMAPINFOHEADER *ptBITMAPINFOHEADER;
69.	    unsigned char *aFileHead;
70.	    unsigned char *pucSrc;
71.	    unsigned char *pucDest;
72.	    int iLineBytes;
73.
74.	    /* Определяем, является ли файл файлом BMP */
75.	    if (IsBmp(&ptData->ptFp, strFileName))
76.	        return -1;
77.
78.	    /* Отображаем файл BMP в память */
79.	    MapFile(ptData);
80.
81.
82.	    aFileHead = ptData->pucFileData;
83.
84.	    ptBITMAPFILEHEADER = (BITMAPFILEHEADER *)aFileHead;
85.	    ptBITMAPINFOHEADER = (BITMAPINFOHEADER *)(aFileHead + sizeof(BITMAPFILEHEADER));
86.	    /* Получаем необходимую информацию об изображении */
87.	    ptData->iWidth = ptBITMAPINFOHEADER->biWidth;
88.	    ptData->iHeight = ptBITMAPINFOHEADER->biHeight;
89.	    ptData->iBpp = ptBITMAPINFOHEADER->biBitCount;
90.	        iLineBytes    = ptData->iWidth*ptData->iBpp/8;//количество байт данных в одной строке
91.	    ptData->iBmpDataSize= ptData->iHeight * iLineBytes;//количество байт всего изображения BMP
92.	    /*временно поддерживается только формат 24bpp*/
93.	    if (ptData->iBpp != 24)
94.	    {
95.	        printf("iBMPBpp = %d\n", ptData->iBpp);
96.	        printf("sizeof(BITMAPFILEHEADER) = %d\n", sizeof(BITMAPFILEHEADER));
97.	        return -2;
98.	    }
99.
100.	    /* Выделяем память */
101.	    ptData->pucBmpData = malloc(ptData->iBmpDataSize);
102.	    ptData->pucRgbData = malloc(ptData->iBmpDataSize);
103.
104.	    if (NULL == ptData->pucBmpData||NULL == ptData->pucRgbData)
105.	        return -2;
106.
107.	    /* Читаем данные изображения из файла bmp, 24bpp изображение BMP в формате BGR */
108.	    pucDest = ptData->pucBmpData;
109.	    iLineWidthAlign = (iLineBytes + 3) & ~0x3;   /* Выравнивание по 4 байтам */
110.	    pucSrc = aFileHead + ptBITMAPFILEHEADER->bfOffBits;
111.
112.	    pucSrc = pucSrc + (ptData->iHeight - 1) * iLineWidthAlign;
113.
114.	    /* Для исходных данных в файле bmp начало координат в левом нижнем углу,
115.	       поэтому при копировании данных нужно преобразовывать координаты */
116.	    for (y = 0; y < ptData->iHeight; y++)
117.	    {
118.	        memcpy(pucDest, pucSrc, ptData->iWidth*3);
119.	        pucSrc  -= iLineWidthAlign;
120.	        pucDest += iLineBytes;
121.	    }
122.
123.
124.	    /* Преобразуем полученные данные BGR в данные RGB */
125.	    for (y = 0; y < ptData->iHeight; y++){
126.	        for(x = 0;x<ptData->iWidth*3;x+=3){
127.	            ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+2];
128.	            ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+1];
129.	            ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+0];
130.	        }
131.	    }
132.
133.	    return 0;
134.
135.	}
```

## 2.2 Обработка изображений JPEG

### 2.2.1 Формат файла JPEG и компиляция libjpeg

Изображения JPEG имеют расширение .jpg. Для изображений с одинаковым содержимым и информацией файл формата JPEG намного меньше файла формата BMP, потому что файл JPEG — это файловый формат, полученный после алгоритма сжатия JPEG.

По сравнению с форматом BMP, JPEG из-за алгоритма сжатия более сложен в анализе. Мы можем использовать преимущество открытого исходного кода Linux и применить открытые инструменты для анализа и преобразования файлов jpeg.

Мы можем использовать библиотеку libjpeg для анализа и преобразования файлов jpeg. libjpeg поддерживает архитектуры X86, ARM и другие. libjpeg — это открытый инструмент, поэтому его можно бесплатно скачать в интернете.

Перед использованием libjpeg нам нужно выполнить кросс-компиляцию библиотечных файлов и заголовочных файлов libjpeg и сохранить их в файловой системе отладочной платы. Ниже процесс компиляции libjpeg:

1. Распаковываем и переходим в директорию файла

```c
tar xzf libjpeg-turbo-1.2.1.tar.gz
cd libjpeg-turbo-1.2.1/
```

2. Кросс-компиляция

```c
tar xzf libjpeg-turbo-1.2.1.tar.gz
./configure --prefix=/work/projects/libjpeg-turbo-1.2.1/tmp/ --host=arm-linux
make
make install
```

3. Копируем скомпилированные заголовочные файлы и библиотечные файлы в соответствующие директории кросс-компилятора

```c
cd /work/projects/libjpeg-turbo-1.2.1/tmp/include
cp * /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include
cd /work/projects/libjpeg-turbo-1.2.1/tmp/lib
cp *so* -d /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/lib
```

4. Копируем скомпилированные заголовочные файлы и библиотечные файлы в соответствующие директории файловой системы отладочной платы

```c
cd /work/projects/libjpeg-turbo-1.2.1/tmp/lib
cp *.so* /work/nfs_root/fs_mini_mdev_new/lib/ -d
```

### 2.2.2 Анализ и использование интерфейсных функций libjpeg

Методы использования libjpeg можно найти в инструкции по использованию libjpeg.txt и примере example.c в распакованном пакете. Использование libjpeg кратко резюмируется следующим образом:

**1.** Выделение и инициализация структуры jpeg_compress_struct

```c
cinfo.err = jpeg_std_error(&jerr);
jpeg_create_decompress(&cinfo);
```

**2.** Указание исходного файла

```c
jpeg_stdio_src(&cinfo, infile);
```

Параметр 1 — это структура типа jpeg_compress_struct, выделенная на шаге 1

Параметр 2 — дескриптор файла JPEG, который нужно проанализировать.

**3.** Получение заголовка информации jpg и установка параметров распаковки

```c
jpeg_read_header(&cinfo, TRUE);
```

После вызова этой функции мы можем получить информацию об изображении через члены cinfo, такие как image_width, image_height и т.д. Кроме того, мы можем установить параметры распаковки, задав члены переменных cinfo, такие как scale_num и scale_denom.

**4.** Запуск распаковки

```c
jpeg_start_decompress(&cinfo);
```

После вызова этой функции исходный файл, указанный в cinfo, будет распакован, и распакованные данные будут сохранены в членах переменной структуры cinfo.

**5.** Чтение распакованных данных

```c
jpeg_read_scanlines(&cinfo, buffer, 1);
```

После вызова этой функции можно прочитать данные RGB в buffer, параметр 3 может указывать, сколько строк прочитать

**6.** Завершение чтения

```c
jpeg_finish_decompress(&cinfo);
```

**7.** Освобождение структуры jpeg_compress_struct

```c
jpeg_destroy_decompress(&cinfo);
```

После завершения чтения освобождаем структуру

### 2.2.3 Использование libjpeg для анализа файла JPEG в формат RGB и отображение на LCD

Согласно анализу предыдущего раздела, используя вышеуказанные библиотечные функции, можно проанализировать файл JPEG в формат RGB.

```c
Код 2.2
1.	/**********************************************************************
2.	 * Название функции: IsJpg
3.	 * Описание: определяет, является ли файл файлом Jpg
4.	 * Входные параметры: ptData - содержит информацию об изображении
5.	                    strFileName - имя файла
6.	 * Возвращаемое значение: 0 - не формат JPG, другое - формат JPG
7.	 ***********************************************************************/
8.	static int IsJpg(PT_PictureData ptData, const char *strFileName)
9.	{
10.	    int iRet;
11.
12.	    jpeg_stdio_src(&ptData->tInfo, ptData->ptFp);
13.
14.	    /* Используем jpeg_read_header для получения информации jpeg */
15.	    iRet = jpeg_read_header(&ptData->tInfo, TRUE);
16.
17.	        return (iRet == JPEG_HEADER_OK);
18.	}
19.
20.	/**********************************************************************
21.	 * Название функции: DecodeJpg2Rgb
22.	 * Описание: анализирует файл JPG в формат RGB888
23.	 * Входные параметры: ptData - содержит информацию о файле
24.	 *                             strFileName - имя файла
25.	 * Выходные параметры: PT_PictureData->pucRgbData - содержит данные rgb
26.	 * Возвращаемое значение: 0 - успех, другое - ошибка
27.	 ***********************************************************************/
28.	static int DecodeJpg2Rgb(const char *strFileName, PT_PictureData ptData){
29.	    int iRowSize;
30.	    unsigned char *pucbuffer;
31.	    unsigned char *pucHelp;//вспомогательная переменная копирования
32.
33.	    /* 1.Выделение и инициализация структуры jpeg_compress_struct */
34.	    ptData->tInfo.err = jpeg_std_error(&ptData->tJerr);
35.	    jpeg_create_decompress(&ptData->tInfo);
36.
37.
38.	    /* 2.Указание исходного файла*/
39.	    if ((ptData->ptFp= fopen(strFileName, "rb")) == NULL) {
40.	        fprintf(stderr, "can't open %s\n", strFileName);
41.	        return -1;
42.	    }
43.
44.	    /* 3.Получение заголовка информации jpg и установка параметров распаковки,
45.	       определяем, является ли файл файлом формата JPEG */
46.	    if (!IsJpg(ptData, strFileName)) {
47.	    printf("file is not jpg ...\n");
48.	    return -1;
49.	    }
50.
51.
52.
53.	    /* Размер по умолчанию — исходный размер */
54.	    ptData->tInfo.scale_num = 1;
55.	    ptData->tInfo.scale_denom = 1;
56.	    /* 4. Запуск распаковки: jpeg_start_decompress */
57.	    jpeg_start_decompress(&ptData->tInfo);
58.
59.
60.	    /* После завершения распаковки можно получить информацию об изображении через члены tInfo */
61.	    ptData->iWidth= ptData->tInfo.output_width;
62.	    ptData->iHeight = ptData->tInfo.output_height;
63.	    ptData->iBpp = ptData->tInfo.output_components*8;
64.	    /* Вычисляем длину данных одной строки */
65.	    iRowSize = ptData->iWidth * ptData->tInfo.output_components;
66.	    pucbuffer = malloc(iRowSize);
67.	    ptData->iRgbSize= iRowSize * ptData->iHeight;
68.	    ptData->pucRgbData = malloc(ptData->iRgbSize);
69.
70.	    /* pucHelp указывает на начальный адрес ptData->pucRgbData */
71.	    pucHelp = ptData->pucRgbData;
72.	    /*  5.Циклически вызываем jpeg_read_scanlines для построчного получения распакованных данных */
73.	    while (ptData->tInfo.output_scanline < ptData->tInfo.output_height)
74.	    {
75.	        /* При вызове jpeg_read_scanlines данные сохраняются в pucbuffer */
76.	        jpeg_read_scanlines(&ptData->tInfo, &pucbuffer, 1);
77.	        /* Читаем данные построчно в буфер */
78.	        memcpy(pucHelp,pucbuffer,iRowSize);
79.	        pucHelp  += iRowSize;
80.	    }
81.	    free(pucbuffer);
82.	    /* 6.Завершение чтения */
83.	    jpeg_finish_decompress(&ptData->tInfo);
84.	    /* 7.Освобождение структуры jpeg_compress_struct */
85.	    jpeg_destroy_decompress(&ptData->tInfo);
86.	    return 0;
87.	}
```

## 2.3 Обработка изображений PNG

### 2.3.1 Формат файла PNG и компиляция libpng

Как и формат файла JPEG, PNG также является форматом изображения, использующим алгоритм сжатия. В отличие от JPEG, PNG использует алгоритм сжатия данных без потерь, производный от LZ77. Для формата файла PNG также существует соответствующий открытый инструмент libpng.

Библиотеку libpng можно скачать с официального сайта в виде последнего исходного кода:

http://www.libpng.org/pub/png/libpng.html

Перед использованием libpng нам нужно выполнить кросс-компиляцию библиотечных файлов и заголовочных файлов libpng и сохранить их в файловой системе отладочной платы. Ниже процесс компиляции libpng:

1. Распаковываем и переходим в директорию файла

```c
tar xzf libpng-1.6.37.tar.gz
cd libpng-1.6.37/
```

2. Кросс-компиляция

```c
./configure --prefix=/work/projects/libpng-1.6.37/tmp/ --host=arm-linux
make
make install
```

3. Копируем скомпилированные заголовочные файлы и библиотечные файлы в соответствующие директории кросс-компилятора

```c
cd /work/projects/libpng-1.6.37/tmp/include
cp * /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include
cd /work/projects/libpng-1.6.37/tmp/lib
cp *so* -d /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/lib
```

4. Копируем скомпилированные заголовочные файлы и библиотечные файлы в соответствующие директории файловой системы отладочной платы

```c
cd /work/projects/libpng-1.6.37/tmp/lib
cp *.so* /work/nfs_root/fs_mini_mdev_new/lib/ -d
```

### 2.3.2 Анализ и использование интерфейсных функций libpng

Методы использования libpng можно найти в инструкции по использованию libpng-manual.txt и примере example.c в распакованном пакете. Использование libjpeg кратко резюмируется следующим образом:

1. Выделение и инициализация двух структур, связанных с libpng: png_ptr, info_ptr

   A. png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);

   Параметры 2, 3, 4 — пользовательские функции обработки ошибок, если их нет, заполняем NULL.

   B. info_ptr = png_create_info_struct(png_ptr);

2. Установка точки возврата при ошибке

   setjmp(png_jmpbuf(png_ptr));

   При возникновении ошибки libpng автоматически вернётся к этой точке. В этой точке мы можем выполнить очистку. Если при вызове png_create_read_struct не была установлена пользовательская функция обработки ошибок, этот шаг обязателен.

3. Указание исходного файла

   png_init_io(png_ptr, fp);

   Параметр 1 — структура png_ptr, выделенная на шаге 1, параметр 2 — дескриптор файла PNG, который нужно проанализировать.

4. Получение информации об изображении PNG

   A. Анализ информации о данных изображения

   png_read_png(png_ptr, info_ptr, png_transforms, png_voidp_NULL);

   Эта функция декодирует все данные изображения в структуру данных info_ptr. Формат преобразования определяется параметром png_transforms, который является целочисленным параметром, можно использовать макросы, определённые в библиотеке libpng, для передачи параметра. Этот параметр имеет множество связанных макросов, для подробностей см. анализ соответствующих файлов библиотеки.

   B. Запрос информации об изображении

Кроме того, мы можем получить ширину, высоту, тип цвета и другую информацию png изображения через функции png_get_image_width, png_get_image_height, png_get_color_type и т.д. Больше функций получения информации об изображении можно найти в файле pngget.c.

5. Чтение данных изображения из info_ptr

   Существует два метода чтения информации об изображении PNG:

   A. Одноразовое чтение всех данных в память

   png_read_image(png_ptr, row_pointers);

   Параметр 1 — png_ptr, выделенный на шаге 1, параметр 2 — указатель для хранения данных изображения.

   B. Также можно читать построчно

   row_pointers = png_get_rows(png_ptr, info_ptr);

   Параметры 1 и 2 — png_ptr и info_ptr, выделенные на шаге 1, возвращаемое значение — начальный адрес данных каждой строки.

   Параметр 1 — png_ptr, выделенный на шаге 1, параметр 2 — указатель для хранения данных изображения.

6. Уничтожение памяти

   png_destroy_read_struct(&png_ptr, &info_ptr, 0);

### 2.3.3 Использование libpng для преобразования файла png в формат rgb и отображение на LCD

```c
Код 2.3
1.	/**********************************************************************
2.	 * Название функции: IsnotPng
3.	 * Описание: определяет, является ли файл файлом PNG
4.	 * Входные параметры: ppFp - указатель на дескриптор файла
5.	                    strFileName - имя файла
6.	 * Возвращаемое значение: 0 - формат PNG, другое - не формат PNG
7.	 ***********************************************************************/
8.	int IsnotPng(FILE **ppFp, const char *strFileName)
9.	{
10.	    char strCheckHeader[8];
11.	    *ppFp= fopen(strFileName, "rb");
12.	    if (*ppFp== NULL) {
13.	        return -1;
14.	    }
15.	    /* Читаем первые 8 байт файла PNG, используя библиотечную функцию png_sig_cmp
16.	       можно определить, является ли файл форматом PNG */
17.	    if (fread(strCheckHeader, 1, 8, *ppFp) != 8)
18.	        return -1;
19.	    return png_sig_cmp(strCheckHeader, 0, 8);
20.
21.	}
22.
23.	/**********************************************************************
24.	 * Название функции: DecodePng2Rgb
25.	 * Описание: анализирует файл PNG в формат RGB888
26.	 * Входные параметры: ptData - содержит информацию о файле
27.	 *                             strFileName - имя файла
28.	 * Выходные параметры: PT_PictureData->pucRgbData - содержит данные rgb
29.	 * Возвращаемое значение: 0 - успех, другое - ошибка
30.	 ***********************************************************************/
31.	static int DecodePng2Rgb(const char *strFileName, PT_PictureData ptData)
32.	{
33.	    int i, j;
34.	    int iPos = 0;
35.	    png_bytepp pucPngData;
36.	    /* 0.Определяем, является ли файл файлом PNG */
37.	    if (IsnotPng(&ptData->ptFp, strFileName)) {
38.	        printf("file is not png ...\n");
39.	        return -1;
40.	    }
41.
42.	    /* 1.Выделение и инициализация двух структур, связанных с libpng: png_ptr, info_ptr */
43.	    ptData->ptPngStrPoint  = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
44.	    ptData->ptPngInfoPoint= png_create_info_struct(ptData->ptPngStrPoint);
45.
46.	    /* 2.Установка точки возврата при ошибке */
47.	    setjmp(png_jmpbuf(ptData->ptPngStrPoint));
48.	    rewind(ptData->ptFp); //эквивалентно fseek(fp, 0, SEEK_SET);
49.
50.	    /* 3.Указание исходного файла */
51.	    png_init_io(ptData->ptPngStrPoint, ptData->ptFp);
52.
53.	    /* 4.Получение информации о данных изображения PNG и количества каналов, ширины, высоты и т.д.
54.	      * Использование макроса PNG_TRANSFORM_EXPAND в качестве параметра преобразует
55.	      * изображение PNG в формат BGR888 или ABGR8888 в зависимости от количества каналов*/
56.	    png_read_png(ptData->ptPngStrPoint, ptData->ptPngInfoPoint, PNG_TRANSFORM_EXPAND, 0);
57.	    ptData->iChannels    = png_get_channels(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);
58.	    ptData->iWidth    = png_get_image_width(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);
59.	    ptData->iHeight  = png_get_image_height(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);
60.
61.
62.	    /* 5.Чтение данных изображения из info_ptr */
63.	    pucPngData = png_get_rows(ptData->ptPngStrPoint, ptData->ptPngInfoPoint); //также можно получать построчно png_get_rowbytes();
64.	    if (ptData->iChannels == 4) { //определяем, 24 бита или 32 бита
65.	        ptData->iRawSize= ptData->iWidth * ptData->iHeight*4; //сначала вычисляем пространство для выделения памяти
66.	        ptData->pucRawData= (unsigned char*)malloc(ptData->iRawSize);
67.	        if (NULL == ptData->pucRawData) {
68.	            printf("malloc rgba faile ...\n");
69.	            png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);
70.	            fclose(ptData->ptFp);
71.	            return -1;
72.	        }
73.	        /* Читаем фактические данные RGBA из pucPngData
74.	         * Исходные данные в формате ABGR */
75.	        for (i = 0; i < ptData->iHeight; i++)
76.	            for (j = 0; j < ptData->iWidth * 4; j += 4) {
77.	                    ptData->pucRawData[iPos++] = pucPngData[i][j + 3];
78.	                    ptData->pucRawData[iPos++] = pucPngData[i][j + 2];
79.	                    ptData->pucRawData[iPos++] = pucPngData[i][j + 1];
80.	                    ptData->pucRawData[iPos++] = pucPngData[i][j + 0];
81.	                }
82.
83.	        /* Преобразуем полученные RGBA в формат RGB888 */
84.	        if(RgbaToRgb(ptData)!=0)
85.	            return -1;
86.
87.	    }
88.	    else if (ptData->iChannels == 3 ) { //определяем, 24 бита или 32 бита
89.	        ptData->iRgbSize= ptData->iWidth * ptData->iHeight*3; //сначала вычисляем пространство для выделения памяти
90.	        ptData->pucRgbData = (unsigned char*)malloc(ptData->iRgbSize);
91.	        if (NULL == ptData->pucRgbData) {
92.	            printf("malloc rgba faile ...\n");
93.	            png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);
94.	            fclose(ptData->ptFp);
95.	            return -1;
96.	        }
97.	        /* Читаем фактические данные RGB из pucPngData
98.	          * Исходные данные в формате BGR */
99.	        for (i = 0; i < ptData->iHeight; i ++) {
100.	            for (j = 0; j < ptData->iWidth*3; j += 3) {
101.	                ptData->pucRgbData[iPos++] = pucPngData[i][j+2];
102.	                ptData->pucRgbData[iPos++] = pucPngData[i][j+1];
103.	                ptData->pucRgbData[iPos++] = pucPngData[i][j+0];
104.	            }
105.	        }
106.	        ptData->iBpp = 24;//формат после преобразования — RGB888
107.	    }
108.	    else return -1;
109.
110.
111.	    /* 6:Уничтожение памяти */
112.	    png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);
113.	    fclose(ptData->ptFp);
114.
115.
116.	    return 0;
117.	}
```

## 2.4 Корректировка изображения

### 2.4.1 Масштабирование изображения

#### 2.4.1.1 Краткий анализ алгоритма масштабирования изображения

Существует множество алгоритмов масштабирования изображений, здесь мы ссылаемся на "Алгоритм масштабирования изображения", написанный пользователем интернета "lantianyu520".

Анализ принципа

Для понимания принципа этого алгоритма масштабирования изображения самое важное — понять: для каждого пикселя изображения его пропорция относительно всего изображения до и после масштабирования должна быть одинаковой.

Например:

Возьмём прямоугольник с длиной и шириной 200 и 100 соответственно, увеличим его в два раза, тогда после масштабирования длина и ширина будут 400 и 200.

Для удобства понимания построим декартову систему координат, поместим левый нижний угол этого прямоугольника в точку (0,0), координаты четырёх точек: (0,0), (0,100), (200,0), (200,100).

Предположим, для точки с координатами (40,50) в прямоугольнике отношение координаты x к длине равно 40/200=0.2, отношение координаты y к ширине равно 50/100=0.5, тогда преобразованные координаты Dx, Dy должны удовлетворять: Dx/400 = 0.2; Dy/200 = 0.5, таким образом можно вычислить координаты после масштабирования.

Согласно вышеприведённому анализу, пусть координаты пикселя до масштабирования (Sx,Sy), соответствующие координаты после масштабирования (Dx,Dy), длина и ширина изображения до масштабирования Sw и Sh соответственно, длина и ширина после масштабирования Dw и Dh соответственно, тогда имеем:

Sx/Dx = Sw/Dw, Sy/Dy = Sh/Dh

Следовательно, Sx = Dx × Sw/Dw, Sy = Dy × Sh/Dh,

#### 2.4.1.2 Написание исходного кода: алгоритм масштабирования изображения

Имея два приведённых выше равенства, код алгоритма масштабирования изображения легко понять.

Следующая функция реализует алгоритм масштабирования изображения на основе вышеуказанного принципа:

```c
Код 2.4
1.	/**********************************************************************
2.	 * Название функции: PicZoom
3.	 * Описание: масштабирование изображения методом ближайшего соседа
4.	 *            Обратите внимание, что эта функция выделяет память для хранения масштабированного изображения,
5.	 *            после использования нужно освободить с помощью функции free
6.	 *            Принцип "ближайшего соседа" см. в статье пользователя "lantianyu520"
7.	 *            "Алгоритм масштабирования изображения"
8.	 * Входные параметры: ptPicData - содержит данные изображения до и после масштабирования
9.	 *            fSize    - коэффициент масштабирования
10.	 * Выходные параметры: ptPicData->pucZoomData, содержит данные после масштабирования
11.	 * Возвращаемое значение: 0 - успех, другое значение - ошибка
12.	 ***********************************************************************/
13.	int PicZoom(PT_PictureData ptPicData,float fSize)
14.	{
15.	    ptPicData->iZoomWidth = ptPicData->iWidth * fSize;
16.	    ptPicData->iZoomHeight= ptPicData->iHeight* fSize;
17.	    unsigned long* pdwSrcXTable;
18.	    unsigned long x;
19.	    unsigned long y;
20.	    unsigned long dwSrcY;
21.	    unsigned char *pucDest;
22.	    unsigned char *pucSrc;
23.	    unsigned long dwPixelBytes = ptPicData->iBpp/8;
24.	    ptPicData->pucZoomData= malloc(sizeof(unsigned char) * ptPicData->iZoomWidth*ptPicData->iZoomHeight*ptPicData->iBpp/8);
25.	    pdwSrcXTable = malloc(sizeof(unsigned long) * ptPicData->iZoomWidth);
26.	    if (NULL == pdwSrcXTable){
27.	        printf("malloc error!\n");
28.	        return -1;
29.	    }
30.
31.	    /* Суть этих циклов for — Sx = Dx × Sw/Dw, Sy = Dy × Sh/Dh*/
32.	    for (x = 0; x < ptPicData->iZoomWidth; x++){//генерация таблицы pdwSrcXTable
33.	        /* Первый цикл for соответствует координате x
34.	     * pdwSrcXTable[x] соответствует Sx,
35.	     * x соответствует Dx,
36.	     * ptPicData->iWidth соответствует Sw
37.	     * ptPicData->iZoomWidth соответствует Dw*/
38.	        pdwSrcXTable[x]=(x*ptPicData->iWidth/ptPicData->iZoomWidth);
39.	    }
40.
41.	    for (y = 0; y < ptPicData->iZoomHeight; y++){
42.	    /* Второй цикл соответствует координате y
43.	     * dwSrcY соответствует Sy,
44.	     * y соответствует Dy,
45.	     * ptPicData->iHeight соответствует Sh
46.	     * ptPicData->iZoomHeight соответствует Dh*/
47.	        dwSrcY = (y * ptPicData->iHeight / ptPicData->iZoomHeight);
48.	    /* На основе этих значений вычисляем адрес хранения данных RGB каждого пикселя */
49.	        pucDest = ptPicData->pucZoomData + y*ptPicData->iZoomWidth*3;
50.	        pucSrc  = ptPicData->pucRgbData + dwSrcY*ptPicData->iWidth*3;
51.
52.	    /* Наконец, копируем данные */
53.	        for (x = 0; x <ptPicData->iZoomWidth; x++){
54.	             memcpy(pucDest+x*dwPixelBytes, pucSrc+pdwSrcXTable[x]*dwPixelBytes, dwPixelBytes);
55.	        }
56.	    }
57.
58.	    free(pdwSrcXTable);
59.	    return 0;
60.	}
```

### 2.4.2 Вращение изображения

#### 2.4.2.1 Краткий анализ алгоритма вращения изображения

Принцип алгоритма вращения изображения здесь основан на статье пользователя интернета "Мышление падающих листьев" "Алгоритм вращения изображения и его реализация"

Анализ принципа

Ключевые моменты принципа этого алгоритма вращения два:

1. Исходное изображение имеет декартову систему координат с началом в левом нижнем углу изображения, а вращение обычно происходит относительно центра изображения как точки вращения.

Поэтому для удобства преобразования мы сначала определим две системы координат: одна — система координат с началом в левом нижнем углу изображения, называемая системой координат A, это также система координат исходного изображения. Другая — система координат с началом в центре изображения, называемая системой координат B.

Таким образом, можно понять шаги этого алгоритма вращения: сначала преобразуем координаты системы A в координаты системы B, затем выполняем вращение изображения в системе координат B.

В системе координат B предположим, что точка (x0, y0) находится на расстоянии r от начала координат, линия между точкой и началом координат образует угол b с осью x, угол вращения a, точка после вращения — (x1, y1), как показано на рисунке ниже.

![ImageProcess_Image005](http://photos.100ask.net/NewHomeSite/ImageProcess_Image005.jpeg)

Тогда имеются следующие заключения:

x0=rcosb; y0=rsinb

x1 = rcos(b-a) = rcosbcosa+rsinbsina=x0cosa+y0sina;

y1=rsin(b-a)=rsinbcosa-rcosbsina=-x0sina+y0cosa;

Наконец, поскольку для отображения данных RGB изображения на LCD всё равно нужно получать в системе координат A, нам в конце нужно только преобразовать x1, y1 из системы координат B обратно в координаты системы A.

После вращения длина и ширина изображения изменятся, поэтому нужно вычислить длину и ширину нового изображения.

Из геометрических соотношений известно, что длина и ширина нового изображения — это максимальные значения разности координат диагональных точек после вращения

#### 2.4.2.2 Написание исходного кода: алгоритм вращения изображения

```c
Код 2.5
1.	 #define PI 3.1415926535
2.	//Преобразование градусов в радианы
3.	#define RADIAN(angle) ((angle)*PI/180.0)
4.
5.
6.
7.
8.
9.	typedef struct ConcernCoor {
10.	    int iLTx;// левый верхний x
11.	    int iLTy;//левый верхний y
12.	    int iLBx;//левый нижний x
13.	    int iLBy;//левый нижний y
14.	    int iRTx;//правый верхний x
15.	    int iRTy;//правый верхний y
16.	    int iRBx;// правый нижний x
17.	    int iRBy;// правый нижний y
18.	}T_ConcernCoor, *PT_ConcernCoor;
19.
20.
21.	/**********************************************************************
22.	 * Название функции: max
23.	 * Описание: сравнивает два параметра, возвращает большее значение
24.	 * Входные параметры: x, y типа int
25.	 * Выходные параметры: нет
26.	 * Возвращаемое значение: большее из x, y
27.	 ***********************************************************************/
28.	static int max(int x,int y){
29.	    return x>y?x:y;
30.	}
31.	/**********************************************************************
32.	 * Название функции: PicRotate
33.	 * Описание: вращение изображения
34.	 *            Обратите внимание, что эта функция выделяет память для хранения
35.	 *            масштабированного изображения, после использования нужно освободить с помощью функции free
36.	 *              См. статью пользователя интернета "Мышление падающих листьев"
37.	 *              "Алгоритм вращения изображения и его реализация"
38.	 * Входные параметры: ptPicData - содержит данные пикселей изображения
39.	 *            fAngle    - угол вращения, 0<=angle<=360
40.	 * Выходные параметры: ptPicData->pucRotateData, содержит данные rgb после вращения
41.	 * Возвращаемое значение: 0 - успех, другое значение - ошибка
42.	 ***********************************************************************/
43.	int PicRotate(PT_PictureData ptPicData,float fAngle)
44.	{
45.	    int i ,j;
46.	    T_ConcernCoor tConCor,tRonCor;
47.	    //Количество байт в строке исходного изображения без учёта смещения
48.	    //int iSrcLineSize = bitCount * srcW / 8;
49.	    int iSrcLineSize = ptPicData->iBpp* ptPicData->iZoomWidth / 8;
50.	    int iDesLineSize;
51.	    int iX;//координата x после вращения
52.	    int iY; //координата y после вращения
53.
54.	       /* Преобразуем координаты системы A в координаты системы B,
55.	        * используются для вычисления ширины и высоты изображения после вращения
56.	        * tConCor используется для хранения координат до вращения в системе B
57.	        * tRonCor используется для хранения координат после вращения в системе B*/
58.	       tConCor.iLTx = -ptPicData->iZoomWidth/2; tConCor.iLTy = ptPicData->iZoomHeight/2;
59.	    tConCor.iRTx = ptPicData->iZoomWidth/2; tConCor.iRTy = ptPicData->iZoomHeight/2;
60.	    tConCor.iLBx = -ptPicData->iZoomWidth/2;tConCor.iLBy = -ptPicData->iZoomHeight/2;
61.	    tConCor.iRBx = ptPicData->iZoomWidth/2;tConCor.iRBy = -ptPicData->iZoomHeight/2;
62.
63.
64.	    /* Вычисляем координаты после вращения в системе B */
65.	    double sina = sin(RADIAN(fAngle));
66.	    double cosa = cos(RADIAN(fAngle));
67.	    tRonCor.iLTx =tConCor.iLTx * cosa + tConCor.iLTy * sina;
68.	    tRonCor.iLTy = -tConCor.iLTx * sina + tConCor.iLTy * cosa;
69.	    tRonCor.iRTx =tConCor.iRTx * cosa + tConCor.iRTy * sina;
70.	    tRonCor.iRTy = -tConCor.iRTx * sina + tConCor.iRTy * cosa;
71.	    tRonCor.iLBx = tConCor.iLBx * cosa + tConCor.iLBy * sina;
72.	    tRonCor.iLBy = -tConCor.iLBx * sina + tConCor.iLBy * cosa;
73.	    tRonCor.iRBx = tConCor.iRBx * cosa + tConCor.iRBy * sina;
74.	    tRonCor.iRBy = -tConCor.iRBx * sina + tConCor.iRBy * cosa;
75.
76.
77.	    /* Вычисляем ширину и высоту изображения после вращения */
78.	    ptPicData->iRotateWidth = max(abs(tRonCor.iRBx - tRonCor.iLTx),abs(tRonCor.iRTx - tRonCor.iLBx));
79.	    ptPicData->iRotateHeight = max(abs(tRonCor.iRBy - tRonCor.iLTy),abs(tRonCor.iRTy - tRonCor.iLBy));
80.
81.	    /* Пиксельная информация должна быть выровнена по 3 байтам, иначе данные могут быть ошибочными*/
82.	    iDesLineSize = ((ptPicData->iRotateWidth* ptPicData->iBpp+ 23) / 24) * 3 ;
83.	    /* Выделяем память после вращения, обратите внимание, что здесь нужно использовать
84.	       ширину и высоту после вращения */
85.	    ptPicData->pucRotateData = malloc(iDesLineSize * ptPicData->iRotateHeight);
86.	    if(NULL == ptPicData->pucRotateData){
87.	        printf("malloc error\n");
88.	        return -1;
89.	    }
90.
91.	    /* Через координаты нового изображения вычисляем соответствующие координаты исходного изображения*
92.	      * координаты i,j — это соответствующие координаты x1,y1 в системе B*/
93.	    for (i = 0; i < ptPicData->iRotateHeight; i++){
94.	        for (j = 0; j < ptPicData->iRotateWidth; j++){
95.	            /* Координаты x,y1 системы B через обратную операцию преобразуются в iX,iY,
96.	               эти два значения соответствуют x0,y0 */
97.	            iX = (j - ptPicData->iRotateWidth / 2)*cos(RADIAN(360 - fAngle)) + (-i + ptPicData->iRotateHeight / 2)*sin(RADIAN(360 - fAngle));
98.	            iY = -(j - ptPicData->iRotateWidth / 2)*sin(RADIAN(360 - fAngle)) + (-i + ptPicData->iRotateHeight / 2)*cos(RADIAN(360 - fAngle));
99.	            /*Если эта координата не в пределах исходного изображения, не присваиваем значение*/
100.	            if (iX > ptPicData->iZoomWidth / 2 || iX < -ptPicData->iZoomWidth / 2 || iY > ptPicData->iZoomHeight / 2 || iY < -ptPicData->iZoomHeight / 2){
101.	                continue;
102.	            }
103.	            /* Снова преобразуем координаты x0,y0 системы B в координаты системы A */
104.	            int iXN = iX + ptPicData->iZoomWidth / 2;
105.	         int iYN = abs(iY - ptPicData->iZoomHeight  / 2);
106.	            /* Копирование значения*/
107.	            memcpy(&ptPicData->pucRotateData[i * iDesLineSize + j * 3],&ptPicData->pucZoomData[iYN * iSrcLineSize + iXN * 3],3);
108.	        }
109.	    }
110.	  return 0;
111.	}
```
