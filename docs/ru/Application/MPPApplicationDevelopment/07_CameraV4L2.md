# Программирование камеры V4L2

## 7.1 Введение в V4L2

Video for Linux Two (Video4Linux2), сокращённо V4L2, — это улучшенная версия V4L. V4L2 — это универсальный API интерфейс в ОС Linux для захвата изображений, видео и аудиоданных. При наличии подходящих видеозахватывающих устройств и соответствующих драйверов можно реализовать захват изображений, видео, аудио и другого контента. V4L2 действует как отличный курьер, безопасно и эффективно доставляя данные изображения с видеозахватывающего устройства различным пользователям с разными требованиями.

В Linux всё является файлом, а все внешние устройства рассматриваются как специальный тип файлов, называемый "файл устройства". Видеоустройства не являются исключением и также могут рассматриваться как файлы устройств, к которым можно обращаться как к обычным файлам, осуществляя чтение и запись. Файлы устройств видеокамер, управляемых драйверами V4L2, обычно называются /dev/videoX (где X — любой номер, соответствующий вашему устройству).

V4L2 поддерживает три способа захвата изображений: способ отображения в памяти (mmap), способ прямого чтения (read) и способ указателя пользователя. Способ отображения в памяти обеспечивает более быстрый захват и обычно используется для захвата непрерывных видеоданных, что чаще встречается в практическом применении; способ прямого чтения относительно медленнее, поэтому обычно используется для захвата данных неподвижных изображений; способ с использованием указателя пользователя используется редко, при необходимости вы можете изучить его самостоятельно. Поскольку способ отображения в памяти имеет более широкое применение, в этой статье основное внимание уделяется захвату видео способом отображения в памяти.

## 7.2 Принцип захвата видео V4L2

Перед захватом изображения через V4L2 необходимо выполнить много важных шагов. Один из самых важных — это выделение буфера кадра и отображение выделенного буфера кадра из пространства ядра в пространство пользователя, затем помещение полученного буфера кадра в очередь входа видеозахвата и ожидание поступления видеоданных. Однако как происходит процесс потока, когда видеоданные действительно приходят? Это необходимо понимать.

После начала видеозахвата драйвер начинает захватывать один кадр данных изображения и помещает захваченные данные изображения в первый буфер кадра очереди входа видеозахвата. После завершения захвата одного кадра изображения драйвер переместит этот буфер кадра в очередь выхода видеозахвата в ожидании приложения. Приложение может извлечь буфер кадра из очереди выхода, обработать или сохранить данные изображения, а затем поместить буфер кадра в конец очереди входа видеозахвата. Затем драйвер захватит следующий кадр данных, поместив его во второй буфер. После того как второй буфер заполнится одним кадром данных, драйвер переместит этот буфер в очередь выхода видеозахвата. Приложение извлечёт данные изображения из буфера кадра и снова поместит буфер в конец очереди входа видеозахвата. Таким образом, циклический процесс реализует циклический захват. Процесс показан на диаграмме ниже:

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image1.png)

Чтобы лучше понять этот процесс, мы можем сравнить "обработку данных приложением" с "переработкой арбузов компанией по обработке арбузов" и "захват данных драйвером V4L2" с "сбором арбузов сборщиком арбузов". Заранее "компания по переработке арбузов" подготавливает несколько пустых корзин для "сборщика арбузов". Затем "сборщик арбузов" ждёт, пока "фермер" (устройство захвата изображения, например камера) наполнит пустые корзины. После того как "пустая корзина 1" наполняется "фермером", "сборщик арбузов" перемещает корзину, полную арбузов, в "очередь обработки арбузов" в ожидании "компании по переработке". Когда "компания по переработке" берёт полную корзину арбузов, она кладёт пустую корзину обратно в конец "очереди сбора арбузов", которая была подготовлена "сборщиком арбузов". Когда "фермер" наполняет следующую пустую корзину, "сборщик арбузов" аналогично помещает полную корзину в "очередь обработки арбузов" в ожидании. Таким образом, весь процесс непрерывно повторяется.

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image2.png)

## 7.3 Процесс реализации программы V4L2

Использование V4L2 для видеозахвата обычно разделяется на 5 этапов:

(1) Откройте устройство и установите параметры инициализации. С помощью интерфейса V4L2 установите окно захвата видеоизображения, размер растра захвата и формат;

(2) Запросите буфер кадра изображения и выполните отображение в памяти, отобразив эти буферы кадра из пространства ядра в пространство пользователя, упростив чтение и обработку данных изображения приложением;

(3) Поставьте буферы кадра в очередь и запустите видеозахват;

(4) Драйвер начинает захватывать видеоданные. Приложение извлекает буфер кадра из очереди выхода видеозахвата, обрабатывает его, а затем помещает буфер кадра обратно в очередь входа видеозахвата. Этот процесс повторяется циклически для захвата непрерывных видеоданных;

(5) Освободите ресурсы и остановите захват.

При разработке V4L2 часто используются следующие флаги команд:

(1) VIDIOC_REQBUFS: выделение памяти;

(2) VIDIOC_QUERYBUF: преобразование буфера данных, выделенного в VIDIOC_REQBUFS, в физический адрес;

(3) VIDIOC_QUERYCAP: запрос функциональности драйвера;

(4) VIDIOC_ENUM_FMT: получение видеоформатов, поддерживаемых текущим драйвером;

(5) VIDIOC_S_FMT: установка формата видеозахвата текущего драйвера;

(6) VIDIOC_G_FMT: чтение формата видеозахвата текущего драйвера;

(7) VIDIOC_TRY_FMT: проверка формата отображения текущего драйвера;

(8) VIDIOC_CROPCAP: запрос функции обрезки драйвера;

(9) VIDIOC_S_CROP: установка границ видеосигнала;

(10) VIDIOC_G_CROP: чтение границ видеосигнала;

(11) VIDIOC_QBUF: извлечение данных из буфера;

(12) VIDIOC_DQBUF: возврат данных в очередь буфера;

(13) VIDIOC_STREAMOP: функция начала отображения видео;

(14) VIDIOC_STREAMOFF: функция завершения отображения видео;

(15) VIDIOC_QUERYSTD: проверка стандартов видеоустройства, поддерживаемых текущим устройством, например PAL или NTSC;

Некоторые из этих вызовов ввода-вывода являются обязательными, некоторые — опциональными.

Конкретный процесс показан на диаграмме ниже:

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image3.png)

## 7.4 Пример программы V4L2

Основной код V4L2 находится в файле video2lcd/video/v4l2.c. Далее мы поясним процесс реализации программы V4L2 и важные структуры данных, используемые в процессе, в сочетании с кодом в файле v4l2.c. Код поддерживает оба метода: отображение в памяти и прямое чтение. Поскольку метод отображения в памяти имеет более широкое применение, в этой статье подробно описывается только метод отображения в памяти. Метод прямого чтения аналогичен методу отображения в памяти и может быть изучен самостоятельно.

### 7.4.1 Открытие устройства

Приложение может открыть видеоустройство в режиме блокировки или неблокирующем режиме. Если видеоустройство открывается вызовом в неблокирующем режиме, драйвер вернёт содержимое из буфера (DQBUFF) приложению, даже если информация ещё не была захвачена. Если видеокамера открывается в неблокирующем режиме, просто измените второй параметр функции open в строке 2 кода на O_RDWR | O_NONBLOCK.

```c
70     iFd = open(strDevName, O_RDWR);
71     if (iFd < 0)
72     {
73         DBG_PRINTF("can not open %s\n", strDevName);
74         return -1;
75     }
```

### 7.4.2 Запрос свойств устройства

Запрос свойств устройства требует использования структуры struct v4l2_capability, которая описывает информацию драйвера устройства видеозахвата.

```c
01 struct v4l2_capability
02 {
03     __u8 driver[16];       // имя драйвера
04     __u8 card[32];         // имя устройства
05     __u8 bus_info[32];     // местоположение устройства в системе
06     __u32 version;         // номер версии драйвера
07     __u32 capabilities;    // операции, поддерживаемые устройством
08     __u32 reserved[4];     // зарезервированные поля
09 };
```

Используйте команду VIDIOC_QUERYCAP для запроса, соответствует ли драйвер спецификации. Поскольку V4L2 требует, чтобы все драйверы и устройства поддерживали этот ioctl, можно определить, соответствуют ли текущие устройство и драйвер спецификации V4L2, по успешному выполнению команды VIDIOC_QUERYCAP. Конечно, успешное выполнение этой команды также обеспечивает получение достаточной информации об устройстве, как показано в структуре struct v4l2_capability. Код в строках 86-98 проверяет, является ли текущее устройство устройством захвата, и проверяет, использовать ли отображение в памяти или способ прямого чтения для получения данных изображения.

```c
78     iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);
79     memset(&tV4l2Cap, 0, sizeof(struct v4l2_capability));
80     iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);
81     if (iError) {
82      DBG_PRINTF("Error opening device %s: unable to query device.\n", strDevName);
83      goto err_exit;
84     }
85
86     if (!(tV4l2Cap.capabilities & V4L2_CAP_VIDEO_CAPTURE))
87     {
88      DBG_PRINTF("%s is not a video capture device\n", strDevName);
89         goto err_exit;
90     }
91
92      if (tV4l2Cap.capabilities & V4L2_CAP_STREAMING) {
93          DBG_PRINTF("%s supports streaming i/o\n", strDevName);
94      }
95
96      if (tV4l2Cap.capabilities & V4L2_CAP_READWRITE) {
97          DBG_PRINTF("%s supports read i/o\n", strDevName);
98      }
```

### 7.4.3 Отображение всех поддерживаемых форматов

Отображение всех поддерживаемых форматов требует использования структуры struct v4l2_fmtdesc, которая описывает информацию о форматах, поддерживаемых текущей камерой.

```c
01 struct v4l2_fmtdesc
02 {
03     __u32 index;               // номер формата для запроса, устанавливается приложением
04     enum v4l2_buf_type type;   // тип кадра, устанавливается приложением
05     __u32 flags;               // является ли формат сжатым
06     __u8 description[32];      // название формата
07     __u32 pixelformat;         // поддерживаемый формат
08     __u32 reserved[4];         // зарезервировано
09 };
```

Используйте команду VIDIOC_ENUM_FMT для запроса всех форматов, поддерживаемых текущей камерой. Необходимо установить index в структуре struct v4l2_fmtdesc, начиная с 0; также необходимо установить enum v4l2_buf_type type. Если используется устройство камеры, то enum v4l2_buf_type type должно быть установлено на V4L2_BUF_TYPE_VIDEO_CAPTURE, поскольку камера является устройством CAPTURE. Остальное содержимое структуры будет заполнено драйвером. Параметр __u32 pixelformat понадобится при установке формата кадра изображения.

```c
100     memset(&tFmtDesc, 0, sizeof(tFmtDesc));
101     tFmtDesc.index = 0;
102     tFmtDesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
103     while ((iError = ioctl(iFd, VIDIOC_ENUM_FMT, &tFmtDesc)) == 0) {
104         if (isSupportThisFormat(tFmtDesc.pixelformat))
105         {
106             ptVideoDevice->iPixelFormat = tFmtDesc.pixelformat;
107             break;
108         }
109             tFmtDesc.index++;
110     }
```

### 7.4.4 Установка формата кадра изображения

Установка формата изображения требует использования структуры struct v4l2_format, которая описывает конкретный формат каждого кадра изображения, включая тип кадра и информацию о длине, ширине и других параметрах изображения.

```c
01 struct v4l2_format
02 {
03     enum v4l2_buf_type type;          // тип кадра, устанавливается приложением
04     union fmt
05     {
06         struct v4l2_pix_format pix;   // используется видеоустройством
07         structv 4l2_window win;
08         struct v4l2_vbi_format vbi;
09         struct v4l2_sliced_vbi_format sliced;
10         __u8 raw_data[200];
11     };
12 };
```

Необходимо установить enum v4l2_buf_type type и struct v4l2_pix_format pix в объединении union fmt структуры struct v4l2_format. Поскольку используется устройство камеры, а камера — это устройство CAPTURE, enum v4l2_buf_type type должно быть установлено на V4L2_BUF_TYPE_VIDEO_CAPTURE. struct v4l2_pix_format pix устанавливает длину, ширину и формат одного кадра изображения. Для адаптации вывода ЖК-дисплея длина и ширина устанавливаются в значения, поддерживаемые ЖК-дисплеем, как показано в строках 124-125.

```c
119     /* set format in */
120     GetDispResolution(&iLcdWidth, &iLcdHeigt, &iLcdBpp);
121     memset(&tV4l2Fmt, 0, sizeof(struct v4l2_format));
122     tV4l2Fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
123     tV4l2Fmt.fmt.pix.pixelformat = ptVideoDevice->iPixelFormat;
124     tV4l2Fmt.fmt.pix.width       = iLcdWidth;
125     tV4l2Fmt.fmt.pix.height      = iLcdHeigt;
126     tV4l2Fmt.fmt.pix.field       = V4L2_FIELD_ANY;
127
128     /* Если драйвер обнаружит, что некоторые параметры (например разрешение) невозможно установить,
129      * он отрегулирует эти параметры и вернёт их приложению
130      */
131     iError = ioctl(iFd, VIDIOC_S_FMT, &tV4l2Fmt);
132     if (iError)
133     {
134             DBG_PRINTF("Unable to set format\n");
135         goto err_exit;
136     }
```

### 7.4.5 Запрос буфера

Соответствующая структура показана ниже. Эта структура описывает основную информацию о запрашиваемом буфере.

```c
01 struct v4l2_requestbuffers
02 {
03     __u32 count;                    // количество кадров буфера в буфере
04     enum v4l2_buf_type type;        // формат данных кадра буфера
05     enum v4l2_memorymemory;         // различие между отображением в памяти и способом указателя пользователя
06     __u32 reserved[2];
07 };
```

Запросите буфер с четырьмя кадрами буфера. __u32 count — это количество кадров буфера; enum v4l2_buf_type type, как и раньше, устанавливается на V4L2_BUF_TYPE_VIDEO_CAPTURE; enum v4l2_memorymemory используется для различия между отображением в памяти и способом указателя пользователя. Мы используем метод отображения в памяти, поэтому устанавливаем его на V4L2_MEMORY_MMAP.

```c
140     /* request buffers */
141     memset(&tV4l2ReqBuffs, 0, sizeof(struct v4l2_requestbuffers));
142     tV4l2ReqBuffs.count = NB_BUFFER;
143     tV4l2ReqBuffs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
144     tV4l2ReqBuffs.memory = V4L2_MEMORY_MMAP;
145
146     iError = ioctl(iFd, VIDIOC_REQBUFS, &tV4l2ReqBuffs);
147     if (iError)
148     {
149             DBG_PRINTF("Unable to allocate buffers.\n");
150         goto err_exit;
151     }
```

### 7.4.6 Отображение запрошенных буферов кадра из пространства ядра в пространство пользователя

Соответствующая структура показана ниже. Эта структура представляет основную информацию данных одного кадра изображения, включая номер, длину буфера кадра и адрес буфера кадра и другую информацию.

```c
01 struct v4l2_buffer
02 {
03     __u32 index;                    // номер буфера
04     enum v4l2_buf_type type;        // тип буфера
05     __u32 byteused;                 // количество использованных байт в буфере
06     __u32 flags;                    // различие между MMAP и USERPTR
07     enum v4l2_field field;
08     struct timeval timestamp;       // системное время при получении первого байта
09     struct v4l2_timecode timecode;
10     __u32 sequence;                 // номер в очереди
11     enum v4l2_memory memory;        // способ ввода-вывода, устанавливается приложением
12     union m
13     {
14         __u32 offset;               // адрес буфера кадра, действителен только для MMAP
15         unsigned long userptr;
16     };
17     __u32 length;                   // длина буфера кадра
18     __u32 input;
19     __u32 reserved;
20 };
```

Для отображения буфера кадра из пространства ядра в пространство пользователя необходимо два приёмника данных: длина и адрес буфера кадра. Нам нужно определить структуру самостоятельно. Эта структура находится в файле video2lcd/include/video_manager.h. Здесь iVideoBufMaxLen получает длину буфера кадра, а pucVideBuf получает адрес буфера кадра.

```c
16 struct VideoDevice {
17     int iFd;
18     int iPixelFormat;
19     int iWidth;
20     int iHeight;
21
22     int iVideoBufCnt;
23     int iVideoBufMaxLen;
24     int iVideoBufCurIndex;
25     unsigned char *pucVideBuf[NB_BUFFER];
26
27     /* функции */
28     PT_VideoOpr ptOPr;
29 };
```

Следующий код использует команду VIDIOC_QUERYBUF и функцию mmap для отображения буфера из пространства ядра в пространство пользователя. Использование команды VIDIOC_QUERYBUF требует параметра структуры struct v4l2_buffer. В структуре необходимо установить параметры type, memory и index. Параметры type и memory устанавливаются так же, как раньше, соответственно на V4L2_BUF_TYPE_VIDEO_CAPTURE и V4L2_MEMORY_MMAP. Параметр index представляет номер запрошенного буфера кадра, начиная с 0 и включая все запрошенные буферы кадра.

Прототип функции mmap:

```c
01 void *mmap(void*addr, size_t length, int prot, int flags, int fd, off_t offset);
```

Значения параметров:

1. addr: адрес начала отображения, обычно NULL, позволяя ядру автоматически выбирать адрес;

2. length: длина отображаемого блока памяти;

3. prot: флаг, определяющий, можно ли читать и писать после отображения. Его значение может быть PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE;

4. flags: определяет, может ли это отображение в памяти совместно использоваться другими процессами. Может быть установлено как MAP_SHARED или MAP_PRIVATE;

5. fd: дескриптор файла устройства;

6. offset: определяет адрес памяти после отображения

```c
156         /* map the buffers */
157         for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
158         {
159             memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
160             tV4l2Buf.index = i;
161             tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
162             tV4l2Buf.memory = V4L2_MEMORY_MMAP;
163             iError = ioctl(iFd, VIDIOC_QUERYBUF, &tV4l2Buf);
164             if (iError)
165             {
166                 DBG_PRINTF("Unable to query buffer.\n");
167                 goto err_exit;
168             }
169
170             ptVideoDevice->iVideoBufMaxLen = tV4l2Buf.length;
171             ptVideoDevice->pucVideBuf[i] = mmap(0 /* start anywhere */ ,
172                               tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,
173                               tV4l2Buf.m.offset);
174             if (ptVideoDevice->pucVideBuf[i] == MAP_FAILED)
175             {
176                 DBG_PRINTF("Unable to map buffer\n");
177                 goto err_exit;
178             }
179         }
```

### 7.4.7 Помещение запрошенных буферов кадра в очередь и запуск потока данных

Код в строках 184-194 использует команду VIDIOC_QBUF для последовательного помещения запрошенных буферов кадра в очередь входа буфера кадра в ожидании заполнения их устройством захвата изображения;

```c
181         /* Queue the buffers. */
182         for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
183         {
184             memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
185             tV4l2Buf.index = i;
186             tV4l2Buf.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
187             tV4l2Buf.memory = V4L2_MEMORY_MMAP;
188             iError = ioctl(iFd, VIDIOC_QBUF, &tV4l2Buf);
189             if (iError)
190             {
191                 DBG_PRINTF("Unable to queue buffer.\n");
192                 goto err_exit;
193             }
194         }
```

### 7.4.8 Запуск захвата данных изображения

Запуск захвата данных изображения осуществляется командой VIDIOC_STREAMON. После успешного выполнения этой команды можно ожидать поступления данных изображения.

```c
356 /**********************************************************************
357  * Название функции: V4l2StartDevice
358  * Описание функции: начать захват данных изображения
359  * Входные параметры: ptVideoDevice
360  * Выходные параметры: нет
361  * Возвращаемое значение: нет
362  * Дата изменения          Версия        Модифицировано        Содержимое изменения
363  * -----------------------------------------------
364  * 2020/02/16         V1.0     zhenhua             создано
365  ***********************************************************************/
366 static int V4l2StartDevice(PT_VideoDevice ptVideoDevice)
367 {
368     int iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
369     int iError;
370
371     iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMON, &iType);
372     if (iError)
373     {
374             DBG_PRINTF("Unable to start capture.\n");
375             return -1;
376     }
377     return 0;
378 }
```

### 7.4.9 Извлечение захватанного буфера кадра из очереди, обработка данных изображения и повторное помещение данных кадра в очередь

Мы можем использовать команду VIDIOC_DQBUF для ожидания поступления буфера кадра. Когда буфер кадра помещается в очередь выхода видеозахвата, мы получаем один кадр изображения. После получения изображения мы можем выполнить над ним операции, такие как сохранение, сжатие или вывод на ЖК-дисплей и т.д.

```c
243 /**********************************************************************
244  * Название функции: V4l2GetFrameForStreaming
245  * Описание функции: получить один кадр данных изображения из потока видеоданных
246  * Входные параметры: ptVideoDevice
247              ptVideoBuf
248  * Выходные параметры: нет
249  * Возвращаемое значение: нет
250  * Дата изменения             Версия        Модифицировано        Содержимое изменения
251  * -----------------------------------------------
252  * 2020/02/16         V1.0     zhenhua             создано
253  ***********************************************************************/
254 static int V4l2GetFrameForStreaming(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)
255 {
256     struct pollfd tFds[1];
257     int iRet;
258     struct v4l2_buffer tV4l2Buf;
259
260     /* poll */
261     tFds[0].fd     = ptVideoDevice->iFd;
262     tFds[0].events = POLLIN;
263
264     iRet = poll(tFds, 1, -1);
265     if (iRet <= 0)
266     {
267         DBG_PRINTF("poll error!\n");
268         return -1;
269     }
270
271     /* VIDIOC_DQBUF */
272     memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
273     tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
274     tV4l2Buf.memory = V4L2_MEMORY_MMAP;
275     iRet = ioctl(ptVideoDevice->iFd, VIDIOC_DQBUF, &tV4l2Buf);
276     if (iRet < 0)
277     {
278             DBG_PRINTF("Unable to dequeue buffer.\n");
279             return -1;
280     }
281     ptVideoDevice->iVideoBufCurIndex = tV4l2Buf.index;
282
283     ptVideoBuf->iPixelFormat        = ptVideoDevice->iPixelFormat;
284     ptVideoBuf->tPixelDatas.iWidth  = ptVideoDevice->iWidth;
285     ptVideoBuf->tPixelDatas.iHeight = ptVideoDevice->iHeight;
286     ptVideoBuf->tPixelDatas.iBpp    = (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_YUYV) ? 16 : \
287                                         (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_MJPEG) ? 0 :  \
288                                         (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_RGB565) ? 16 :  \
289                                         0;
290     ptVideoBuf->tPixelDatas.iLineBytes    = ptVideoDevice->iWidth * ptVideoBuf->tPixelDatas.iBpp / 8;
291     ptVideoBuf->tPixelDatas.iTotalBytes   = tV4l2Buf.bytesused;
292     ptVideoBuf->tPixelDatas.aucPixelDatas = ptVideoDevice->pucVideBuf[tV4l2Buf.index];
293     return 0;
294 }
```

После извлечения буфера кадра из очереди выхода буфера кадра и извлечения данных изображения необходимо вернуть буфер кадра в очередь входа видеозахвата. Эта операция также использует команду VIDIOC_QBUF для помещения буфера кадра обратно в очередь входа и продолжения ожидания заполнения.

```c
296 /**********************************************************************
297  * Название функции: V4l2PutFrameForStreaming
298  * Описание функции: вернуть извлеченный буфер кадра в очередь входа изображения
299  * Входные параметры: ptVideoDevice
300              ptVideoBuf
301  * Выходные параметры: нет
302  * Возвращаемое значение: нет
303  * Дата изменения             Версия        Модифицировано        Содержимое изменения
304  * -----------------------------------------------
305  * 2020/02/16         V1.0     zhenhua             создано
306  ***********************************************************************/
307 static int V4l2PutFrameForStreaming(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)
308 {
309     /* VIDIOC_QBUF */
310     struct v4l2_buffer tV4l2Buf;
311     int iError;
312
313     memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
314     tV4l2Buf.index  = ptVideoDevice->iVideoBufCurIndex;
315     tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
316     tV4l2Buf.memory = V4L2_MEMORY_MMAP;
317     iError = ioctl(ptVideoDevice->iFd, VIDIOC_QBUF, &tV4l2Buf);
318     if (iError)
319     {
320         DBG_PRINTF("Unable to queue buffer.\n");
321         return -1;
322     }
323     return 0;
324 }
```

### 7.4.10 Остановка захвата данных изображения

Для остановки захвата данных изображения сначала используйте команду VIDIOC_STREAMOFF для закрытия захвата данных изображения. Также необходимо отменить отображение памяти и закрыть дескриптор файла, чтобы избежать утечки памяти. Код в строках 390-407 показывает команду остановки захвата данных изображения; код в строках 227-241 показывает отмену отображения памяти и закрытие дескриптора файла.

```c
380 /**********************************************************************
381  * Название функции: V4l2StopDevice
382  * Описание функции: остановить захват данных изображения
383  * Входные параметры: ptVideoDevice
384  * Выходные параметры: нет
385  * Возвращаемое значение: нет
386  * Дата изменения             Версия        Модифицировано        Содержимое изменения
387  * -----------------------------------------------
388  * 2020/02/16         V1.0     zhenhua             создано
389  ***********************************************************************/
390 static int V4l2StopDevice(PT_VideoDevice ptVideoDevice)
391 {
392     int iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
393     int iError;
394
395     iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMOFF, &iType);
396     if (iError)
397     {
398             DBG_PRINTF("Unable to stop capture.\n");
399             return -1;
400     }
401     return 0;
402 }
403
404 static int V4l2GetFormat(PT_VideoDevice ptVideoDevice)
405 {
406     return ptVideoDevice->iPixelFormat;
407 }
408
409
410 217 /**********************************************************************
411 218  * Название функции: V4l2ExitDevice
412 219  * Описание функции: выход из устройства захвата, отмена отображения буфера кадра и закрытие дескриптора
413 220  * Входные параметры: ptVideoDevice
414 221  * Выходные параметры: нет
415 222  * Возвращаемое значение: нет
416 223  * Дата изменения             Версия        Модифицировано        Содержимое изменения
417 224  * -----------------------------------------------
418 225  * 2020/02/16         V1.0     zhenhua             создано
419 226  ***********************************************************************/
420 227 static int V4l2ExitDevice(PT_VideoDevice ptVideoDevice)
421 228 {
422 229     int i;
423 230     for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
424 231     {
425 232         if (ptVideoDevice->pucVideBuf[i])
426 233         {
427 234             munmap(ptVideoDevice->pucVideBuf[i], ptVideoDevice->iVideoBufMaxLen);
428 235             ptVideoDevice->pucVideBuf[i] = NULL;
429 236         }
430 237     }
431 238
432 239     close(ptVideoDevice->iFd);
433 240     return 0;
434 241 }
```
