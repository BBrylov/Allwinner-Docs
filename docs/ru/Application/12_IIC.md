# 12 Программирование I2C

I2C (Inter-Integrated Circuit BUS) — это сокращение от I2C BUS, на русском языке означает интегральная схема шины — это один из наиболее широко используемых интерфейсов сегодня. В связи с иммунной системой, эта шина была разработана PHILIPS, предшественником NXP.

## 12.1 Протокол I2C

### **12.1.1** **Обзор**

I2C — это последовательная шина связи с архитектурой типа "ведущий-ведомый", первоначально разработанная для подключения низкоскоростных периферийных устройств в системах на материнских платах, встроенных системах или мобильных телефонах. Она используется в основном в приложениях с малым объемом данных и имеет характеристики короткой дистанции передачи и того, что в любой момент времени может быть только один мастер. Строго говоря, I2C представляет собой комбинацию аппаратного и программного обеспечения, поэтому мы представим шину, разделив её на физический и протокольный уровни.

Структура шины I2C показана на следующей диаграмме:

![](http://photos.100ask.net/NewHomeSite/IIC_Image001.png)

При передаче данных нам нужно отправлять данные с главного устройства на подчинённое; нам также необходимо передавать данные с подчинённого устройства на главное, что требует двусторонней передачи данных.

Для процесса связи по I2C мы можем рассмотреть наглядный пример из жизни.

![](http://photos.100ask.net/NewHomeSite/IIC_Image002.jpeg)

Учитель физкультуры: может как бросить мяч ученику, так и поймать мяч от ученика.

① Бросание мяча:

- a. Учитель говорит: "Внимание!" (start);
- b. Учитель говорит ученику A: "Я кидаю мяч тебе" (A — это адрес);
- c. Учитель бросает мяч (передача);
- d. После того, как A получит мяч, он должен сказать учителю (подтверждение);
- e. Учитель говорит: "Перемена!" (остановка).

② Ловля мяча:

- a. Учитель говорит: "Внимание!" (start);
- b. Учитель говорит: "B, кидай мне мяч" (B — это адрес);
- c. B кидает мяч учителю (передача);
- d. После того, как учитель получит мяч, он говорит B, что получил (подтверждение);
- e. Учитель говорит: "Перемена!" (остановка).

Используя этот простой пример, давайте объясним протокол передачи I2C:

① Учитель говорит "Внимание!", обозначая начальный сигнал (start)

② Учитель говорит конкретному ученику, обозначая отправку адреса (address)

③ Учитель бросает/ловит мяч, обозначая передачу данных

④ Учитель/ученик получает мяч и отвечает, обозначая сигнал подтверждения (ACK)

⑤ Учитель говорит "Перемена", обозначая прекращение передачи I2C (P)

### **12.2.2 Физический уровень**

##### 1) Характеристика 1: полудуплекс (не полный дуплекс)

В шине I2C используется только две линии: SDA и SCL.

**① SDA (серийная линия данных):**

Главная микросхема может отправлять данные подчинённому устройству через одну линию SDA и также может читать данные с линии SDA. Внутри устройства I2C есть два вывода (вывод передачи/приёма), которые оба подключены к внешней линии SDA. Подробнее см. рисунок ниже, где I2Cn_SDA (выход/вход) находится на стороне устройства.

**② SCL (серийная линия тактового сигнала):**

Главное устройство I2C выдаёт сигнал тактовой частоты, а подчинённое устройство принимает его.

Внутренняя структура выводов SDA и SCL одинакова. Выходной драйвер и входной буфер вывода соединены вместе. Где выход — это открытый сток полевого транзистора, а входной буфер — это высокоимпедансный повторитель напряжения. Эта структура имеет следующие характеристики:

a. Поскольку SDA и SCL имеют структуру открытого стока, логика "провод-И" реализована с помощью внешних подтягивающих резисторов;

b. Вывод одновременно выступает в качестве сигнала на выходе и входе для внутреннего обнаружения. Когда выход и вход не совпадают, это указывает на проблему. Это обеспечивает аппаратную основу для "синхронизации тактового сигнала" и "арбитража шины".

На линиях SDA и SCL подключены два подтягивающих резистора. Когда шина простаивает, обе линии находятся на высоком уровне. Низкий уровень, выданный любым устройством, подключённым к шине, делает сигнал шины низким.

Физическое соединение уровня показано на следующем рисунке:

![](http://photos.100ask.net/NewHomeSite/IIC_Image003.png)

##### **2) Характеристика 2: адрес и роль настраиваются**

Каждое устройство, подключённое к шине, может взаимодействовать с другими устройствами через уникальный адрес. Роль ведущего/ведомого и адрес можно настраивать. Главное устройство может выступать в качестве передатчика и приёмника.

##### **3) Характеристика 3: многомастеровая архитектура**

I2C — это истинная многомастеровая шина. Устройство I2C может стать ведущим во время связи. Если два или более ведущих устройства одновременно запрашивают шину, обнаружение конфликтов и арбитраж предотвращают повреждение данных шины.

##### 4) Характеристика 4: скорость передачи

Скорость передачи в стандартном режиме может достигать 100 кб/с, в быстром режиме — 400 кб/с.

##### 5) Характеристика 5: нагрузка и расстояние

Максимальное количество узлов ограничено пространством адресов и ёмкостью шины. Кроме того, общая ёмкость также ограничивает расстояние связи всего несколькими метрами.

### **12.2.3 Протокольный уровень**

##### 1) Валидность данных

Валидность данных протокола I2C обеспечивается часами. Во время высокого периода часов данные на линии SDA должны оставаться стабильными. Линия данных может измениться только при низком уровне SCL.

![](http://photos.100ask.net/NewHomeSite/IIC_Image004.png)

##### 2) Начальное и конечное условия

**Начальное условие:** переход SDA с высокого уровня на низкий уровень при высоком уровне SCL определяется как начальное условие.

**Конечное условие:** переход SDA с низкого уровня на высокий уровень при высоком уровне SCL определяется как условие остановки.

Важно отметить, что начальный и завершающий сигналы передаются главным устройством. Устройства, подключённые к шине I2C с аппаратным интерфейсом I2C, легко обнаруживают начальный и завершающий сигналы.

![](http://photos.100ask.net/NewHomeSite/IIC_Image005.png)

Шина считается занятой после начального условия и свободной после условия остановки.

##### 3) Подтверждение

Каждый раз, когда главное устройство завершает отправку одного байта данных ведомому устройству, главное устройство всегда должно ждать сигнала подтверждения от ведомого устройства, чтобы убедиться, что ведомое устройство успешно получило данные. Часы, необходимые для подтверждения ведомым устройством главного устройства, по-прежнему предоставляются главным устройством. Подтверждение происходит во время тактового цикла сразу после того, как главное устройство завершает передачу 8 бит данных. Низкий уровень (0) указывает подтверждение, высокий уровень (1) — отсутствие подтверждения.

##### 4) Формат кадра данных

Каждый байт на линии SDA должен быть длиной 8 бит, количество передаваемых байтов в каждой передаче не ограничено, после каждого байта должен следовать ACK. Из 8 битов данных сначала передаётся старший значащий бит (MSB).

![](http://photos.100ask.net/NewHomeSite/IIC_Image006.png)

## 12.2 Работа с периферийными устройствами I2C в системе Linux

### 12.2.1 Обзор

На диаграмме ниже показана блок-схема процесса работы с периферийными устройствами на шине I2C в среде операционной системы Linux. Давайте исследуем функции каждого компонента в этом процессе, начиная с нижних уровней и двигаясь вверх.

На аппаратном уровне шина I2C содержит только две линии, на которые может быть подключено несколько устройств I2C. Некоторые из этих устройств выступают в роли ведущего в шине I2C. В большинстве случаев ведущее устройство — это контроллер I2C в главном процессоре на плате. Например, на плате 100ask_imx6UL ведущее устройство — это модуль контроллера I2C в имеем процессоре imx6. Другие устройства I2C на шине действуют как ведомые, как правило, это датчики периферии плате, выполняющие специальные функции. Они взаимодействуют с главным процессором только через две линии шины I2C. Например, на плате 100ask_imx6UL есть два периферийных устройства: EEPROM и AP3216, которые оба действуют как ведомые на шине I2C и параллельно подключены к контроллеру I2C1 в процессоре imx6.

На уровне ядра драйверные программы должны реализовать протокол связи I2C на шине I2C снизу и собирать данные датчиков I2C, упаковывая их в стандартные интерфейсы операционной системы Linux для использования приложениями в пространстве пользователя. Сверху они должны реализовать интерфейсы, позволяющие программам Linux организовывать поток данных в протокол I2C и передавать его на соответствующие периферийные датчики на аппаратном уровне.

В приложениях в пространстве пользователя разработчик приложений может полностью игнорировать детали протокола I2C. Он просто должен следовать функциям интерфейса операции устройства I2C, предоставляемым слоем драйвера, и может легко работать с периферийными устройствами I2C, как с обычными файлами устройств Linux.

![](http://photos.100ask.net/NewHomeSite/IIC_Image007.png)

### **12.2.2** **Краткое описание драйвера I2C для Linux**

Архитектура драйвера I2C в ядре Linux состоит в основном из трёх частей:

#### 1) Уровень ядра I2C:

Ядро I2C предоставляет методы регистрации и отмены регистрации драйверов шины I2C и драйверов устройств, верхнюю часть протокола связи I2C (алгоритм), а также ряд функций интерфейса, независимых от конкретной аппаратной платформы, и код верхнего уровня для обнаружения и проверки адреса устройства. Она находится в файле drivers/i2c/i2c-core.c в каталоге исходного кода ядра и служит звеном между драйверами шины I2C и драйверами устройств, зависящим от ядра I2C.

Основные функции в ядре I2C включают:

Добавление/удаление i2c_adapter

```c
int i2c_add_adapter(struct i2c_adapter *adap);
int i2c_del_adapter(struct i2c_adapter *adap);
```

Добавление/удаление i2c_driver

```c
int i2c_register_driver(struct module *owner, struct i2c_driver *driver);
int i2c_del_driver(struct i2c_driver *driver);
inline int i2c_add_driver(struct i2c_driver *driver);
```

Присоединение/отсоединение i2c_client

```c
int i2c_attach_client(struct i2c_client *client);
int i2c_detach_client(struct i2c_client *client);
```

Передача, отправка и приём i2c

```c
int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num);
```

Используется для группы обменов сообщениями между адаптером I2C и устройством I2C. Сам по себе он не имеет возможности управлять физическим аппаратом адаптера для завершения обмена сообщениями. Он просто находит i2c_algorithm, соответствующий i2c_adapter, и использует функцию master_xfer() i2c_algorithm для действительного управления аппаратом.

```c
int i2c_master_send(struct i2c_client *client,const char *buf ,int count);
int i2c_master_recv(struct i2c_client *client, char *buf ,int count);
```

Функции i2c_master_send() и i2c_master_recv() внутри вызывают функцию i2c_transfer() для завершения одного сообщения записи и одного сообщения чтения соответственно.

a) Распределение команд управления I2C

Следующие функции помогают распределить команды, отправленные файлу устройства адаптера I2C ioctl, к функции algo_control() алгоритма соответствующего адаптера или функции command() i2c_driver:

```c
int i2c_control(struct i2c_client *client, unsigned int cmd, unsigned long arg);
void i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg);
```

#### 2) Слой драйвера шины I2C:

Драйвер шины I2C является реализацией на стороне адаптера в архитектуре аппаратного обеспечения I2C. Адаптер может управляться процессором или даже интегрирован непосредственно в процессор.

Основные функции:

a) Инициализация аппаратных ресурсов, используемых адаптером I2C, запрос адресов I/O, номеров прерываний и т.д.

b) Добавление структуры данных i2c_adapter через i2c_add_adapter(). Конечно, члены структуры данных i2c_adapter уже инициализированы указателями функций соответствующего адаптера xxx.

c) Освобождение аппаратных ресурсов, используемых адаптером I2C, освобождение адресов I/O, номеров прерываний и т.д.

d) Удаление структуры данных i2c_adapter через i2c_del_adapter().

#### 3) Слой драйвера устройства шины I2C:

Драйвер устройства I2C (также называемый драйвером клиента) является реализацией на стороне устройства в архитектуре аппаратного обеспечения I2C. Устройство обычно подключено к адаптеру I2C, управляемому процессором, и обменивается данными с процессором через адаптер I2C. Функция загрузки модуля драйвера устройства I2C обычно выполняет две задачи: регистрирует устройство I2C как символьное устройство через функцию register_chrdev() и добавляет i2c_driver через функцию i2c_add_driver() ядра I2C.

## 12.3 Использование I2C на прикладном уровне Linux

Из предыдущего обсуждения мы узнали о протоколе I2C и архитектуре драйвера Linux. Итак, когда вы получаете отладочную плату или получаете плату с периферийным устройством I2C от аппаратного коллеги вашей компании, как вы можете быстро её использовать? Поскольку мы часто говорим, что эта шина I2C широко используется в встроенной разработке, есть ли готовые инструменты тестирования, которые помогут нам быстро использовать периферийные устройства I2C на плате? Ответ — да, и исходный код этого инструмента тестирования является открытым исходным кодом, он широко используется на прикладном уровне Linux для быстрой проверки доступности периферийного устройства I2C, что обеспечивает хороший способ протестировать устройство I2C.

### **12.3.1** **Как использовать инструменты I2C для тестирования периферийных устройств I2C**

#### 1) Обзор инструментов I2C:

Инструменты I2C содержат набор инструментов для тестирования различных функций I2C на прикладном уровне Linux. Основная функция включает: инструмент сканирования шины, помощник доступа к SMBus, скрипт декодирования EEPROM, инструмент программирования EEPROM и модуль Python для доступа SMBus. Если ядро, которое вы используете, содержит драйвер устройства I2C, вы можете нормально использовать этот инструмент тестирования на вашей плате.

#### 2) Скачивание исходного кода инструментов I2C:

Как мы уже говорили, инструменты I2C имеют открытый исходный код. Где можно найти этот исходный код?

Способ скачивания 1: Прямое скачивание архива кода инструментов I2C с веб-сайта ядра https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/.

Способ скачивания 2: Используйте инструмент управления git для скачивания исходного кода инструментов I2C с помощью команды git clone git://git.kernel.org/pub/scm/utils/i2c-tools/i2c-tools.git. Настоятельно рекомендуем читателям использовать второй способ, поскольку вы можете быстро понять улучшения функций и исправления ошибок различных версий этого открытого кода через git, а использование git для разработки также является необходимым навыком для хорошего разработчика.

#### 3) Компиляция исходного кода инструментов I2C:

Войдите в каталог исходного кода iic-tools, загруженный с помощью git, и измените инструмент компиляции на текущий используемый инструмент кросс-компиляции:

```c
26  CC ?= arm-linux-gnueabihf-gcc
27  AR ?= arm-linux-gnueabihf-ar
```

Компиляция исходного кода: если вы хотите скомпилировать статическую версию, вы можете ввести команду make USE_STATIC_LIB=1; если вы используете динамическую библиотеку, вы можете просто ввести make для компиляции. Команда установки: make install. Если вы хотите, чтобы генерируемые в итоге бинарные файлы были как можно меньше, вы можете запустить "make strip" перед "make install". Однако это не будет генерировать какие-либо отладочные библиотеки и не позволит проводить дальнейшую отладку. Затем скопируйте 5 исполняемых файлов i2cdetect, i2cdump, i2cget, i2cset и i2ctransfer из каталога tools в /usr/sbin/ плате; скопируйте файл libi2c.so.0.1.1 из каталога lib в /usr/lib/libi2c.so.0 плате. Не забудьте затем изменить вышеуказанные файлы на исполняемые права доступа.

#### 4) Введение различных функций инструментов I2C — i2cdetect

Основная функция i2cdetect заключается в запросе устройств I2C. Она используется для сканирования устройств на шине I2C. Выводит таблицу со списком устройств, обнаруженных на указанной шине.

Распространённый формат команды: i2cdetect [-y] [-a] [-q|-r] i2cbus [first last]. Значение конкретных параметров приведено ниже:

| -y         | Отключить интерактивный режим. По умолчанию i2cdetect будет ждать подтверждения пользователя, при использовании этого флага операция будет выполнена непосредственно. |
| ---------- | ------------------------------------------------------------ |
| -a         | Принудительное сканирование нестандартных адресов. Обычно не рекомендуется. |
| -q         | Используйте команду SMBus "быстрая запись" для зондирования. Обычно не рекомендуется. |
| -r         | Используйте команду SMBus "получить байт" для зондирования. Обычно не рекомендуется. |
| -F         | Отобразить список функций, реализованных адаптером, и выйти. |
| -V         | Отобразить версию инструмента I2C и выйти. |
| -l         | Отобразить шины I2C, уже используемые в системе. |
| i2cbus     | Обозначает номер или имя сканируемой шины I2C. |
| first last | Обозначает диапазон адресов сканируемого ведомого устройства. |

Распространённый способ использования этой функции:

Во-первых, проверьте текущее состояние шин I2C в системе с помощью i2cdetect -l:

![](http://photos.100ask.net/NewHomeSite/IIC_Image008.png)

Во-вторых, если ведомые устройства I2C подключены к шине, вы можете отсканировать все устройства на определённой шине I2C через i2cdetect. Вы можете ввести i2cdetect -y 1 в консоль: (где "--" обозначает обнаруженный адрес, но на него нет ответа от микросхемы; "UU" означает, что этот адрес в настоящий момент используется драйверной программой, поэтому зондирование пропускается; а 16-ричные адреса 60, 1e и 50 обозначают, что обнаружены внешние периферийные устройства с адресами ведомого узла 0x60, 0x1e (AP3216) и 0x50 (EEPROM).

![](http://photos.100ask.net/NewHomeSite/IIC_Image009.png)

![](http://photos.100ask.net/NewHomeSite/IIC_Image010.png)

В-третьих, запрос функций для шины I2C 1 (I2C-1) с помощью команды i2cdetect -F 1:

![](http://photos.100ask.net/NewHomeSite/IIC_Image011.png)

#### 5) Введение различных функций инструментов I2C — i2cget

Основная функция i2cget — получить содержимое определённого регистра периферийного устройства I2C. Распространённый формат команды:

i2cget [-f] [-y] [-a] i2cbus chip-address [data-address [mode]]. Значение конкретных параметров приведено ниже:

| -f           | Принудительный доступ к устройству, даже если оно занято. По умолчанию i2cget откажет в доступе к устройству, которое уже находится под контролем драйверной программы ядра. |
| ------------ | ------------------------------------------------------------ |
| -y           | Отключить интерактивный режим. По умолчанию i2cdetect будет ждать подтверждения пользователя, при использовании этого флага операция будет выполнена непосредственно. |
| -a           | Разрешить использование адресов между 0x00 - 0x07 и 0x78 - 0x7f. Обычно не рекомендуется. |
| i2cbus       | Обозначает номер или имя сканируемой шины I2C. Это число должно соответствовать одной из шин, перечисленных в i2cdetect -l. |
| chip-address | Адрес ведомого устройства, над которым нужно выполнить операцию. |
| data-address | Адрес регистра периферийного устройства для просмотра. |
| mode         | Способ отображения данных: b (чтение байта данных, по умолчанию) w (чтение данных слова) c (запись байта/чтение байта) |

Ниже приведен пример завершения чтения данных из регистра 0x10 периферийного устройства с адресом ведомого узла 0x50 на шине 0. Команда:

i2cget -y -f 0 0x50 0x10

![](http://photos.100ask.net/NewHomeSite/IIC_Image012.png)

#### 6) Введение различных функций инструментов I2C — i2cdump

Основная функция i2cdump — просмотр всех значений регистров периферийного устройства I2C. Распространённый формат команды: i2cdump [-f] [-r first-last] [-y] [-a] i2cbus address [mode [bank [bankreg]]]. Значение конкретных параметров приведено ниже:

| -f         | Принудительный доступ к устройству, даже если оно занято. По умолчанию i2cget откажет в доступе к устройству, которое уже находится под контролем драйверной программы ядра. |
| ---------- | ------------------------------------------------------------ |
| -r         | Ограничить диапазон обращаемых регистров. Эта опция доступна только в режимах b, w, c и W. Для режима W первое число должно быть чётным, а последнее — нечётным. |
| -y         | Отключить интерактивный режим. По умолчанию i2cdetect будет ждать подтверждения пользователя, при использовании этого флага операция будет выполнена непосредственно. |
| -V         | Отобразить версию инструмента I2C и выйти. |
| i2cbus     | Обозначает номер или имя сканируемой шины I2C. Это число должно соответствовать одной из шин, перечисленных в i2cdetect -l. |
| first last | Обозначает диапазон адресов сканируемого ведомого устройства. |
| mode       | b: отдельный байт w: 16-битное слово s: модуль SMBus i: размер чтения модуля I2C c: последовательное чтение всех байтов, очень полезно для микросхем с функцией автоматического увеличения адреса (таких как EEPROM). W подобна w, но команда чтения может быть выполнена только на адресах чётных регистров; это в основном используется для EEPROM. |

Ниже приведён пример завершения чтения данных EEPROM с адресом ведомого узла 0x50 на шине 0. Команда:

i2cdump -f -y 0 0x50

![](http://photos.100ask.net/NewHomeSite/IIC_Image013.png)

#### 7) Введение различных функций инструментов I2C — i2cset

Основная функция i2cset заключается в установке значения определённого регистра устройства через шину I2C. Распространённый формат команды:

i2cset [-f] [-y] [-m mask] [-r] i2cbus chip-address data-address [value] ...[mode]

Значение конкретных параметров приведено ниже:

| -f      | Принудительный доступ к устройству, даже если оно занято. По умолчанию i2cget откажет в доступе к устройству, которое уже находится под контролем драйверной программы ядра. |
| ------- | ------------------------------------------------------------ |
| -r      | Прочитайте значение сразу же после записи и сравните результат с записанным значением. |
| -y      | Отключить интерактивный режим. По умолчанию i2cdetect будет ждать подтверждения пользователя, при использовании этого флага операция будет выполнена непосредственно. |
| -V      | Отобразить версию инструмента I2C и выйти. |
| i2cbus  | Обозначает номер или имя сканируемой шины I2C. Это число должно соответствовать одной из шин, перечисленных в i2cdetect -l. |
| -m mask | Если указан параметр маски, то описывает, какие биты значения будут фактически записаны в data-addres. Биты, установленные в маске на 1, будут взяты из значения, а биты, установленные на 0, будут прочитаны из адреса данных, таким образом сохраняемые операцией. |
| mode    | b: отдельный байт w: 16-битное слово s: модуль SMBus i: размер чтения модуля I2C c: последовательное чтение всех байтов, очень полезно для микросхем с функцией автоматического увеличения адреса (таких как EEPROM). W подобна w, но команда чтения может быть выполнена только на адресах чётных регистров; это в основном используется для EEPROM. |

Ниже приведён пример завершения записи значения 0x55 в регистр 0x10 EEPROM с адресом ведомого узла 0x50 на шине 0. Команда:

i2cset -y -f 0 0x50 0x10 0x55

Затем используйте i2cget для чтения данных из регистра 0x10 EEPROM с адресом ведомого узла 0x50 на шине 0. Команда: i2cget -y -f 0 0x50 0x10

![](http://photos.100ask.net/NewHomeSite/IIC_Image014.png)

#### 8) Введение различных функций инструментов I2C — i2ctransfer

Основная функция i2ctransfer заключается в отправке определённых пользователем сообщений I2C в одной передаче. i2ctransfer — это программа, которая создаёт сообщения I2C и объединяет их в один трансфер для отправки. Для сообщений чтения содержимое буфера приёма выводится в stdout, по одной строке для каждого сообщения чтения.

Распространённый формат команды: i2ctransfer [-f] [-y] [-v] [-a] i2cbus desc [data] [desc [data]]

Значение конкретных параметров приведено ниже:

| -f     | Принудительный доступ к устройству, даже если оно занято. По умолчанию i2cget откажет в доступе к устройству, которое уже находится под контролем драйверной программы ядра. |
| ------ | ------------------------------------------------------------ |
| -y     | Отключить интерактивный режим. По умолчанию i2cdetect будет ждать подтверждения пользователя, при использовании этого флага операция будет выполнена непосредственно. |
| -v     | Включить подробный вывод. Он выведет всю информацию отправки, включая сообщения чтения и сообщения записи. |
| -V     | Отобразить версию инструмента I2C и выйти. |
| -a     | Разрешить использование адресов между 0x00 - 0x02 и 0x78 - 0x7f. Обычно не рекомендуется. |
| i2cbus | Обозначает номер или имя сканируемой шины I2C. Это число должно соответствовать одной из шин, перечисленных в i2cdetect -l. |

Ниже приведён пример завершения записи 0x01, 0x02, 0x03, 0x04 в 4 регистра, начиная с адреса 0x20, EEPROM с адресом ведомого узла 0x50 на шине 0. Команда: i2ctransfer -f -y 0 w5@0x50 0x20 0x01 0x02 0x03 0x04. Затем прочитайте 4 регистра с адреса 0x20 с помощью команды i2ctransfer -f -y 0 w1@0x50 0x20 r4, см. рисунок ниже:

![](http://photos.100ask.net/NewHomeSite/IIC_Image015.png)

### **12.3.2** **Чтение и запись периферийных устройств I2C в приложениях Linux**

Сначала из предыдущего обсуждения мы уже знаем, что с точки зрения процессора управление периферийным устройством I2C фактически означает управление контроллером I2C, к которому подключено это периферийное устройство I2C. Этот контроллер I2C в системе Linux называется "адаптер I2C". Это уже было обсуждено во введении к драйверам. Как известно, в системе Linux каждое устройство представлено в виде файла, поэтому управление периферийным устройством I2C в Linux превращается в управление файлом устройства адаптера I2C. Ядро Linux (операционная система) генерирует узел устройства с основным номером устройства 89 для каждого адаптера I2C (дополнительные номера устройств от 0 до 255), он не предназначен для конкретного периферийного устройства I2C, а просто предоставляет универсальные интерфейсы файловых операций, такие как read(), write() и ioctl(). На прикладном уровне в пространстве пользователя можно использовать эти интерфейсы для доступа к пространству памяти или регистрам периферийного устройства I2C, подключённого к адаптеру, и для управления режимом работы периферийного устройства I2C.

Процесс операции:

#### 1) Определение узла устройства адаптера I2C

Узел устройства адаптера I2C — это /dev/i2c-x, где x — число. Поскольку номер адаптера назначается динамически (зависит от порядка регистрации), чтобы узнать, какому номеру соответствует какой адаптер, вы можете просмотреть содержимое файла в каталоге /sys/class/i2c-dev/ (здесь я настоятельно рекомендую читателям хорошо использовать файловую систему sys):

```c
cat /sys/class/i2c-dev/i2c-0/name
cat /sys/class/i2c-dev/i2c-1/name
```

![](http://photos.100ask.net/NewHomeSite/IIC_Image016.png)

Затем проверьте принципиальную схему оборудования, чтобы узнать, что EEPROM подключён к контроллеру I2C1 процессора, а затем проверьте справочник микросхемы IMX6UL, адрес регистра I2C1 — 21A_0000.

![](http://photos.100ask.net/NewHomeSite/IIC_Image017.png)

После сравнения мы легко узнаём, что узел устройства контроллера I2C, соответствующий периферийному устройству EEPROM, — это: /dev/i2c-0.

#### 2) Открытие узла устройства, соответствующего адаптеру

Когда пользователь открывает узел устройства адаптера, код i2c-dev в ядре создаёт для него i2c_client, но этот i2c_client не добавляется в список клиентов адаптера i2c. Когда пользователь закрывает узел устройства, он автоматически освобождается.

#### 3) Управление IOCTL

Это можно увидеть в файле include/linux/i2c-dev.h в исходном коде ядра. Ниже приведены основные команды IOCTL:

| I2C_SLAVE_FORCE | Установить адрес ведомого устройства I2C (успех только если адрес свободен) |
| --------------- | ------------------------------------------------------------ |
| I2C_SLAVE_FORCE | Принудительно установить адрес ведомого устройства I2C (успех независимо от того, есть ли уже драйвер, использующий этот адрес в ядре) |
| I2C_TENBIT      | Выбрать длину бита адреса: 0 означает адрес 7 бит; не равно 0 — адрес 10 бит. Эта команда действительна только если адаптер поддерживает I2C_FUNC_10BIT_ADDR. |
| I2C_FUNCS       | Получить функции, поддерживаемые адаптером. Подробнее см. файл include/linux/i2c.h |
| I2C_RDWR        | Установить для чтения и записи |
| I2C_RETRIES     | Установить количество повторных попыток при отсутствии ACK |
| I2C_TIMEOUT     | Установить предел по времени ожидания |

#### 4) Использование протокола I2C и обмен данными с устройством

Код: ioctl(file,I2C_RDWR,(struct i2c_rdwr_ioctl_data *)msgset); он может выполнять непрерывное чтение и запись без перерывов. Эта команда действительна только если адаптер поддерживает I2C_FUNC_I2C. Параметр msgset — это указатель на структуру типа i2c_rdwr_ioctl_data. Функция этой структуры заключается в позволении приложению передавать сообщения в ядро. Её члены включают: struct i2c_msg __ user *msgs; и представляющий количество i2c_msgs __u32 nmsgs. Это также определяет, сколько стартовых сигналов будет в аппаратной связи I2C. Поскольку обмен между адаптером I2C и внешним устройством выполняется единицами сообщений, структура struct i2c_msg очень важна для нас. Она может содержать несколько сообщений, и одно сообщение может содержать несколько данных. Например, запись на странице EEPROM содержит несколько данных. Ниже приведено описание этой структуры:

| __u16 addr;        | Адрес ведомого устройства |
| ------------------ | ------------------------------------------------------------ |
| __u16 flags;       | Флаги (чтение/запись) |
| I2C_M_TEN          | Это адрес микросхемы из 10 бит |
| I2C_M_RD           | Чтение данных из ведомого устройства в адаптер |
| I2C_M_NOSTART      | Не отправлять бит запуска |
| I2C_M_REV_DIR_ADDR | Реверс флагов чтения и записи |
| I2C_M_IGNORE_NAK   | Игнорировать сигнал NACK протокола I2C |
| I2C_M_NO_RD_ACK    | Не отправлять сигнал ACK при операции чтения |
| I2C_M_RECV_LEN     | Длина первого полученного данных |
| __u16 len;         | Количество данных для записи или чтения (байты) |
| __u8 *buf;         | Адрес данных для записи или чтения buf[0]. Примечание: не забудьте выделить память для buf в структуре i2c_msg в структуре i2c_rdwr_ioctl_data. |

#### 5) Использование read и write для чтения и записи устройств I2C

Конечно, вы можете использовать read()/write() для взаимодействия с устройством I2C. Код выглядит следующим образом (с EEPROM в качестве примера для краткого описания процесса операции):

Во-первых, откройте файл узла контроллера I2C: fd =open("/dev/i2c-0", O_RDWR);

Во-вторых, установите адрес устройства EEPROM: ioctl(fd,I2C_SLAVE, 0x50);

В-третьих, напишите данные в EEPROM:

Сначала назначьте адрес первого регистра EEPROM для записи в элемент буфера 0: wr_buf[0] = 0x10;

Затем запишите данные для записи после буфера: for(i=1;i<13;i++) wr_buf[i]=i;

Наконец, используйте функцию write для завершения функции записи данных в EEPROM: write(fd, wr_buf, 13);

Наконец, задержитесь на 1 секунду, чтобы отделить последующие операции от вышеуказанной операции записи.

В-четвёртых, прочитайте данные из EEPROM:

Сначала, как и при операции записи, отправьте адрес первого регистра 0x10 в EEPROM: write(fd, wr_buf, 1);

Прочитайте 12 байтов данных с адреса регистра 0x10: ret=read(fd, rd_buf, 12);

Вы обнаружите, что read и write могут выполнить только передачу в одном направлении за раз: либо чтение периферийного устройства, либо операцию записи.

Код выглядит следующим образом:

```c
01 #include <stdio.h>
02 #include <sys/ioctl.h>
03 #include <unistd.h>
04 #include <fcntl.h>
05 #include <linux/i2c-dev.h>
06 #include <linux/i2c.h>
07
08 /* Узел устройства контроллера I2C, соответствующий EEPROM */
09 #define EEPROM_DEVICE    	"/dev/i2c-0"
10
11 /* Адрес устройства EEPROM на шине I2C */
12 #define EEPROM_ADDR    0x50
13
14
15 int main()
16 {
17 	int fd,i,ret=0;
18 	unsigned char w_add=0x10;
19
20 	/* Буфер данных для чтения */
21 	unsigned char rd_buf[13] = {0x10};
22
23 	/* Буфер данных для записи, элемент 0 — адрес регистра EEPROM, с которым нужно работать*/
24 	unsigned char wr_buf[13] = {0};
25
26 	printf("hello,this is read_write i2c test \n");
27
28 	/* Откройте файл контроллера I2C, соответствующий EEPROM */
29 	fd =open(EEPROM_DEVICE, O_RDWR);
30 	if (fd< 0)
31 	{
32 		printf("open"EEPROM_DEVICE"failed \n");
33 	}
34
35 	/* Установите адрес устройства EEPROM на шине I2C */
36 	if (ioctl(fd,I2C_SLAVE_FORCE, EEPROM_ADDR) < 0)
37 	{
38 		printf("set slave address failed \n");
39 	}
40
41 	/* Назначьте адрес первого регистра, с которым нужно работать */
42 	wr_buf[0] = w_add;
43
44 	/* Запишите данные для записи в буфер позже */
45 	for(i=1;i<13;i++)
46 		wr_buf[i]=i;
47
48 	/* Используйте функцию write для завершения функции записи данных в EEPROM */
49 	write(fd, wr_buf, 13);
50
51 	/* Задержитесь на некоторое время */
52 	sleep(1);
53
54 	/* Начните следующую операцию, сначала запишите адрес первого регистра */
55 	write(fd, wr_buf, 1);
56
57 	/* Начните с адреса регистра wr_buf[0] = w_add и прочитайте 12 байтов данных */
58 	ret=read(fd, rd_buf, 12);
59 	printf("ret is %d \r\n",ret);
60
61 	for(i=0;i<12;i++)
62 	{
63 		printf("rd_buf is :%d\n",rd_buf[i]);
64 	}
65
66 	/* После завершения операции закройте файл узла устройства контроллера I2C EEPROM */
67 	close(fd);
68
69 	return 0;
70 }
```

#### 6) Управление устройством I2C с помощью пакетов данных

Построение структуры пакета данных:

Сначала используется struct i2c_rdwr_ioctl_data data; приложение передаёт сообщения в ядро через эту структуру. Эта структура содержит двух членов: struct i2c_msg __ user * msgs; и __ u32 nmsgs; где *msgs указывает на структуру сообщений метода связи трансфера. Nmsgs определяет, сколько таких сообщений связи имеет пакет данных. С точки зрения протокола связи I2C, это представляет собой, сколько стартовых сигналов будет.

Затем используется struct i2c_msg; он может содержать несколько сообщений, и одно сообщение может содержать несколько данных. Его члены включают: "адрес ведомого устройства I2C __ u16 addr; флаг, представляющий это сообщение __ u16 flags; длина данных __ u16 len; указатель на буфер данных __u8 *buf"

Затем установите связь между данными для взаимодействия с ведомым устройством I2C и двумя вышеупомянутыми структурами.

Наконец, вызовите I2C_RDWR для входа в драйверную программу для выполнения чтения и записи комбинированной передачи данных I2C.

Код выглядит следующим образом:

```c
01 #include <stdio.h>
02 #include <string.h>
03 #include <sys/ioctl.h>
04 #include <unistd.h>
05 #include <fcntl.h>
06 #include <linux/i2c-dev.h>
07 #include <linux/i2c.h>
08
09 /* Узел устройства контроллера I2C, соответствующий EEPROM */
10 #define EEPROM_DEVICE    	"/dev/i2c-0"
11
12 /* Адрес устройства EEPROM на шине I2C */
13 #define EEPROM_ADDR    0x50
14
15 /* Имя функции: eeprom_write
16 ** Функция: запишите данные в EEPROM
17 ** Параметр: fd: имя файла узла устройства контроллера I2C, соответствующее EEPROM
18 ** dev_addr: адрес ведомого устройства I2C EEPROM
19 ** reg_addr: адрес регистра EEPROM
20 ** data_buf: буфер данных для записи в EEPROM
21 ** len: запишите количество байтов. Максимум 8 байтов поддерживается в этом примере
22 ** Возвращаемое значение: отрицательное число указывает на ошибку, остальное на успех
23 */
24 int eeprom_write(int fd, unsigned char dev_addr, unsigned char reg_addr, unsigned char * data_buf,int len)
25 {
26 	int ret;
27
28 	unsigned char msg_buf[9];
29 	struct i2c_rdwr_ioctl_data data;
30
31 	struct i2c_msg messages;
32
33
34 	/* 1. Построить msg_buf */
35 	/* 1.1. Назначьте адрес первого регистра, который необходимо обработать, для первого байта данных обмена I2C */
36 	msg_buf[0] = reg_addr;
37
38 	/* 1.2. Назначьте буфер данных для записи в EEPROM после регистра EEPROM в обмене данными I2C */
39 	if (len < 9) {			/* Этот демонстрационный файл поддерживает максимум один раз запись одной страницы размером 8 байтов в EEPROM */
40         memcpy((void *) &msg_buf[1], data_buf, len);  // Данные находятся после первой позиции
41     } else {
42         printf("This function supports up to 8 bytes at a time !!!\n");
43         return -1;
44     }
45
46 	/* 2. Построить struct i2c_msg messages */
47 	/* 2.1. Назначьте адрес ведомого устройства I2C EEPROM */
48 	messages.addr = dev_addr;
49
50 	/* 2.2. Назначьте флаги для завершения функции записи в этой коммуникации I2C */
51 	messages.flags = 0;
52
53 	/* 2.3. Назначьте len в длину буфера данных + длину данных адреса регистра EEPROM */
54 	messages.len = len+1;
55
55 	/* 2.4. Построить буфер данных пакета сообщений */
56 	messages.buf = msg_buf;
57
58 	/* 3. Построить struct i2c_rdwr_ioctl_data data */
59 	/* 3.1. Назначьте подготовленный пакет сообщений msgs в i2c_rdwr_ioctl_data */
60 	data.msgs = &messages;
61
61 	/* 3.2. Поскольку эта связь I2C выполняет только операцию записи, количество сообщений равно 1 */
62 	data.nmsgs = 1;
63
63 	/* 4. Вызовите чтение и запись комбинированной передачи данных I2C драйверного слоя */
64 	if(ioctl(fd, I2C_RDWR, &data) < 0)
65 	{
66 		printf("I2C_RDWR err \n");
67 		return -1;
68 	}
69
69 	/* 5. Ждём, пока завершится запись на шину I2C */
70 	sleep(1);
71
71 	return 0;
72 }
73
73 /* Имя функции: eeprom_read
74 ** Функция: прочитайте данные из EEPROM
75 ** Параметр: fd: имя файла узла устройства контроллера I2C, соответствующее EEPROM
76 ** dev_addr: адрес ведомого устройства I2C EEPROM
77 ** reg_addr: адрес регистра EEPROM
78 ** data_buf: буфер для сохранения данных чтения из EEPROM
79 ** len: количество байтов для чтения.
80 ** Возвращаемое значение: отрицательное число указывает на ошибку, остальное на успех
81 */
82 int eeprom_read(int fd, unsigned char dev_addr, unsigned char reg_addr, unsigned char * data_buf,int len)
83 {
83 	int ret;
84
84 	unsigned char msg_buf[9];
85 	struct i2c_rdwr_ioctl_data data;
86
86 	struct i2c_msg messages[2];
87
87 	/* 1. Построить struct i2c_msg messages */
88 	/* 1.1. Построить первое сообщение messages[0] */
88 	/* 1.1.1. Назначьте адрес ведомого устройства I2C EEPROM */
89 	messages[0].addr = dev_addr;
90
90 	/* 1.1.2. Назначьте флаги для завершения операции записи в этой коммуникации I2C */
91 	messages[0].flags = 0;
92
92 	/* 1.1.3. Назначьте len в длину данных адреса регистра EEPROM 1 */
93 	messages[0].len = 1;
94

94 	/* 1.1.4. Данные этой операции записи — это адрес первого регистра EEPROM для чтения */
95 	messages[0].buf = &reg_addr;
96
97 	/* 1.2. Построить второе сообщение messages[1] */
98 	/* 1.2.1. Назначьте адрес ведомого устройства I2C EEPROM */
99 	messages[1].addr = dev_addr;
100
100 	/* 1.1.2. Назначьте флаги для завершения операции чтения в этой коммуникации I2C */
101 	messages[1].flags = I2C_M_RD;
102
102 	/* 1.1.3. Назначьте len для длины данных регистра EEPROM для чтения len */
103 	messages[1].len = len;
104

104 	/* 1.1.4. Буфер, в котором хранятся данные из операции чтения */
105 	messages[1].buf = data_buf;
106

106 	/* 2. Построить struct i2c_rdwr_ioctl_data data */
107 	/* 2.1. Назначьте подготовленный пакет сообщений msgs в i2c_rdwr_ioctl_data */
108 	data.msgs = messages;
109

109 	/* 2.2. Поскольку эта коммуникация I2C выполняет как операцию записи, так и операцию чтения, количество сообщений равно 2 */
110 	data.nmsgs = 2;
111

111 	/* 3. Вызовите чтение и запись комбинированной передачи данных I2C драйверного слоя */
112 	if(ioctl(fd, I2C_RDWR, &data) < 0)
113 	{
113 		printf("I2C_RDWR err \n");
114 		return -1;
115 	}
116

116 	/* 4. Ждём, пока завершится чтение с шины I2C */
117 	sleep(1);
118

118 	return 0;
119 }
120
121 int main()
122 {
122 	int fd,i,ret=0;
123 	unsigned char w_add=0x10;
124
125 	/* Буфер данных для чтения */
126 	unsigned char rd_buf[8] = {0};
127
128 	/* Буфер данных для записи */
129 	unsigned char wr_buf[8] = {0};
130

130 	printf("hello,this is I2C_RDWR i2c test \n");
131
132 	/* Откройте файл контроллера I2C, соответствующий EEPROM */
133 	fd =open(EEPROM_DEVICE, O_RDWR);
134 	if (fd< 0)
135 	{
135 		printf("open"EEPROM_DEVICE"failed \n");
136 	}
137

137 	/* Запишите данные для записи в буфер позже */
138 	for(i=0;i<8;i++)
139 		wr_buf[i]=i;
140

140 	/* Используйте I2C_RDWR для завершения функции чтения данных из EEPROM */
141 	eeprom_write(fd,EEPROM_ADDR,w_add,wr_buf,8);
142

142
143 	/* Используйте I2C_RDWR для завершения функции записи данных в EEPROM */
144 	eeprom_read(fd,EEPROM_ADDR,w_add,rd_buf,8);
145

145 	for(i=0;i<8;i++)
146 	{
147 		printf("rd_buf is :%d\n",rd_buf[i]);
148 	}
149
150 	/* После завершения операции закройте файл узла устройства контроллера I2C EEPROM */
151 	close(fd);
152

152 	return 0;
153 }
154
```

### 12.3.3 Краткое введение в методы отладки I2C

#### 1) Обзор общих элементов для завершения нормальной связи в коммуникации I2C:

Во-первых, проверьте, чтобы все устройства на шине I2C были подтянуты к питанию через подтягивающие резисторы и проверьте стабильность питания.

Во-вторых, проверьте, перепутаны ли линии данных и линии сигналов тактового сигнала.

В-третьих, убедитесь, что скорость связи I2C не превышает максимальную скорость, поддерживаемую устройством.

В-четвёртых, проверьте, подключены ли внешнее устройство I2C и управляемый контроллер I2C к одной и той же шине I2C.

В-пятых, убедитесь, что адрес периферийного устройства I2C правильный.

В-шестых, проверьте, нет ли нескольких ведомых устройств с одинаковым адресом на шине I2C, что приводит к конфликту связи.

В-седьмых, убедитесь, что периферийное устройство I2C, с которым вы работаете, не находится в защищённом режиме записи. Защищённый режим записи означает, что данные не могут быть записаны.

В-восьмых, проверьте, соответствует ли синхронизация связи I2C протоколу связи I2C.

В-девятых, перед запуском программы связи I2C проверьте, чистый ли и стабильный ли уровень электрического сигнала на шине I2C в состоянии покоя на высоком уровне, и нет ли ситуации, когда хост ошибочно тянет SDA на низкий уровень, что приводит к "занятому" состоянию шины I2C.

В-десятых, проверьте, остаётся ли SDA или SCL в состоянии долгого натяжения на низком уровне во время связи I2C. Например, ведомое периферийное устройство I2C из-за аномалии не освобождает SDA после отправки сигнала ACK. Другая ситуация заключается в том, что ЦП в роли ведомого не обрабатывает данные главного устройства, полученные своевременно, что приводит к длительному натяжению SCL на низком уровне, разрушающему процесс связи I2C. Поэтому при написании связи I2C лучше как можно быстрее завершить обработку данных в функции обработчика прерывания приёма I2C и разрешить контроллеру I2C работать нормально.

Из-за особенностей протокола шины I2C, если любое устройство I2C на шине натягивает сигнал SCL или SDA на низкий уровень, все другие устройства I2C увидят этот низкий уровень и не смогут натянуть их вверх. Это означает, что если устройство не отпускает шину и постоянно держит уровень шины на низком уровне, вся шина I2C войдёт в состояние зависания и не сможет нормально взаимодействовать по протоколу I2C.

Если контроллер I2C главного ЦП шины I2C испытывает вышеуказанное состояние долгого натяжения на низком уровне, в теории мы можем отладить код, чтобы найти причину зависания шины I2C и изменить код, чтобы переинициализировать контроллер I2C для сброса и возобновления связи I2C. Если обнаружено при отладке, что причина зависания шины I2C вызвана периферийным устройством I2C, мы можем выполнить сброс периферийного устройства. Однако в фактической разработке проекта сброс элементов на шине I2C также может быть невозможен для восстановления нормальной связи I2C. В это время необходимо спроектировать основную программу шины I2C, чтобы установить выводы контроллера I2C как функцию GPIO и имитировать протокол I2C для завершения одной полной связи I2C, а затем снова установить контроллер I2C как функцию I2C.

## 12.4 Заключение о преимуществах и недостатках применения I2C в разработке встроенных проектов

Преимущества: использование только двух проводов, поддержка нескольких ведущих контроллеров и нескольких ведомых устройств, I2C имеет очень широкое использование протокола.

Недостатки: скорость передачи данных медленнее, чем SPI, размер кадра данных ограничен 8 битами, реализация более сложного оборудования, чем SPI. Кроме того, при использовании I2C необходимо обратить внимание на следующие вопросы:

#### 1) Проблема синхронизации сигнала тактового сигнала I2C (SCL)

Сигнал синхронизации при передаче информации на шине I2C завершается логическим "И" всех устройств, подключённых к линии SCL. Переход SCL с высокого уровня на низкий уровень влияет на эти устройства. Как только тактовый сигнал любого устройства падает на низкий уровень, линия SCL остаётся на низком уровне, в результате чего все устройства на SCL входят в период низкого уровня. В это время переход тактового сигнала устройства с более коротким периодом низкого уровня с низкого на высокий уровень не может влиять на состояние линии SCL. Таким образом, эти устройства входят в состояние ожидания высокого уровня. Когда все тактовые сигналы устройств переходят на высокий уровень, период низкого уровня заканчивается, и линия SCL освобождается и возвращается на высокий уровень, и все устройства одновременно начинают свой период высокого уровня. После этого устройство, которое первым заканчивает период высокого уровня, снова натягивает линию SCL на низкий уровень. Таким образом, на линии SCL генерируется синхронный сигнал тактового сигнала. Видно, что время низкого уровня тактового сигнала определяется устройством с самым длинным периодом низкого уровня, а время высокого уровня определяется устройством с самым коротким периодом высокого уровня.

#### 2) Способность управления шиной

Подтягивающий резистор и паразитная ёмкость нагрузки определяют стабильность шины на определённой скорости. Когда выход находится на высоком уровне, ток через подтягивающий резистор заряжает паразитную ёмкость нагрузки. Чем больше подтягивающий резистор, чем больше паразитная ёмкость, тем больше требуемое время. Если это превышает 10% цикла связи, передний фронт будет слишком медленным, и соответствующее время установки будет затронуто. Максимальная паразитная ёмкость согласно спецификации I2C составляет 400 пФ, в быстром режиме — 100 пФ. Если выход находится на низком уровне, ток через подтягивающий резистор поглощается устройством главного узла I2C (обратите внимание, что согласно спецификации I2C минимальный ток поглощения составляет всего 3 мА). Тогда падение напряжения этого тока поглощения на подтягивающем резисторе определяет диапазон, на который может упасть уровень выходного низкого уровня. Если она не может опуститься ниже 0,3 VDD, произойдёт неправильная дискретизация. Некоторые люди говорят, что увеличение подтягивающего резистора неуместно. Необходимо конкретно проанализировать ток поглощения, паразитную ёмкость нагрузки, уровень подтяжки и скорость связи, чтобы принять решение (обычный режим и быстрый режим отличаются).

Хотя скорость не очень высока, если на линии сигнала добавлена ёмкость, помните, что не добавляйте большую, она должна быть маленькой, иначе сигнал не достигнет ведомого устройства и будет "съеден" ёмкостью.
