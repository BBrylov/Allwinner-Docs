# 16 Анализ протокола MQTT

## 16.1 Введение в протокол MQTT

### 16.1.1 Обзор

MQTT - это протокол передачи сообщений по модели публикация/подписка в архитектуре клиент-сервер. Его философия проектирования заключается в легковесности, открытости, простоте, стандартизации и легкости реализации. Эти характеристики делают его отличным выбором для многих сценариев, особенно для ограниченных сред, таких как связь между машинами (M2M) и интернет вещей (IoT).

### 16.1.2 Особенности

a) Открытый протокол сообщений, простой в реализации

b) Модель публикация/подписка, отправка сообщений "один ко многим"

c) Базируется на сетевом соединении TCP/IP

d) Фиксированный заголовок 1 байт, пакет heartbeat 2 байта, компактная структура пакетов

e) Поддержка QoS для сообщений, гарантия надежной передачи

### 16.1.3 Применение

Протокол MQTT широко применяется в интернете вещей, мобильном интернете, умном оборудовании, автомобильных сетях, электроэнергетике и других областях.

a) Связь M2M в интернете вещей, сбор больших данных IoT

b) Push-уведомления для Android, push-уведомления для веб

c) Мобильные мгновенные сообщения, например Facebook Messenger

d) Умное оборудование, умная мебель, умная бытовая техника

e) Связь в автомобильных сетях, сбор данных от зарядных станций для электромобилей

f) Умные города, удаленная медицина, дистанционное образование

g) Рынки энергетики, нефти и других отраслей

## 16.2 Состав формата пакетов протокола MQTT

### 16.2.1 Структура управляющего пакета MQTT

Протокол MQTT осуществляет связь путем обмена предопределенными управляющими пакетами MQTT. Этот раздел описывает формат этих пакетов. Управляющий пакет MQTT состоит из трех частей, как показано на рисунке:

![Рисунок 2.1 Состав пакета MQTT](http://photos.100ask.net/NewHomeSite/MQTT_Image0002.png)


### 16.2.2 Фиксированный заголовок MQTT

Каждый управляющий пакет MQTT содержит фиксированный заголовок. Формат фиксированного заголовка показан на рисунке:

![Рисунок 2.2 Фиксированный заголовок MQTT](http://photos.100ask.net/NewHomeSite/MQTT_Image0003.png)


### 16.2.3 Типы управляющих пакетов MQTT

Позиция: 1-й байт, биты 7-4, представлены как 4-битное беззнаковое значение.

Типы управляющих пакетов MQTT представлены в следующей таблице:

| Название        | Значение | Направление передачи | Описание                                            |
| --------------- | -------- | -------------------- | --------------------------------------------------- |
| **Reserved**    | 0        | Запрещено            | Зарезервировано                                     |
| **CONNECT**     | 1        | Клиент к серверу     | Запрос клиента на подключение к серверу            |
| **CONNACK**     | 2        | Сервер к клиенту     | Подтверждение пакета подключения                    |
| **PUBLISH**     | 3        | Оба направления      | Публикация сообщения                                |
| **PUBACK**      | 4        | Оба направления      | Подтверждение получения сообщения QoS 1            |
| **PUBREC**      | 5        | Оба направления      | Получение публикации (первый шаг гарантированной доставки) |
| **PUBREL**      | 6        | Оба направления      | Освобождение публикации (второй шаг гарантированной доставки) |
| **PUBCOMP**     | 7        | Оба направления      | Завершение публикации сообщения QoS 2 (третий шаг гарантированного обмена) |
| **SUBSCRIBE**   | 8        | Клиент к серверу     | Запрос клиента на подписку                         |
| **SUBACK**      | 9        | Сервер к клиенту     | Подтверждение запроса подписки                      |
| **UNSUBSCRIBE** | 10       | Клиент к серверу     | Запрос клиента на отписку                          |
| **UNSUBACK**    | 11       | Сервер к клиенту     | Подтверждение отписки                              |
| **PINGREQ**     | 12       | Клиент к серверу     | Запрос heartbeat                                    |
| **PINGRESP**    | 13       | Сервер к клиенту     | Ответ heartbeat                                     |
| **DISCONNECT**  | 14       | Клиент к серверу     | Отключение клиента                                 |
| **Reserved**    | 15       | Запрещено            | Зарезервировано                                     |

### 16.2.4 Флаги

Оставшиеся 4 бита [3-0] первого байта фиксированного заголовка содержат флаги, специфичные для каждого типа управляющего пакета MQTT. Описание битов флагов приведено в следующей таблице:

| Управляющий пакет | Флаги фиксированного заголовка | Бит 3 | Бит 2 | Бит 1 | Бит 0   |
| ----------------- | ------------------------------ | ----- | ----- | ----- | ------- |
| **CONNECT**       | Reserved                       | 0     | 0     | 0     | 0       |
| **CONNACK**       | Reserved                       | 0     | 0     | 0     | 0       |
| **PUBLISH**       | Used in MQTT 3.1.1            | DUP1  | QoS2  | QoS2  | RETAIN3 |
| **PUBACK**        | Reserved                       | 0     | 0     | 0     | 0       |
| **PUBREC**        | Reserved                       | 0     | 0     | 0     | 0       |
| **PUBREL**        | Reserved                       | 0     | 0     | 1     | 0       |
| **PUBCOMP**       | Reserved                       | 0     | 0     | 0     | 0       |
| **SUBSCRIBE**     | Reserved                       | 0     | 0     | 1     | 0       |
| **SUBACK**        | Reserved                       | 0     | 0     | 0     | 0       |
| **UNSUBSCRIBE**   | Reserved                       | 0     | 0     | 1     | 0       |
| **UNSUBACK**      | Reserved                       | 0     | 0     | 0     | 0       |
| **PINGREQ**       | Reserved                       | 0     | 0     | 0     | 0       |
| **PINGRESP**      | Reserved                       | 0     | 0     | 0     | 0       |
| **DISCONNECT**    | Reserved                       | 0     | 0     | 0     | 0       |

DUP1 = Флаг повторной передачи управляющего пакета
QoS2 = Уровень качества обслуживания пакета PUBLISH
RETAIN3 = Флаг сохранения пакета PUBLISH

### 16.2.5 Оставшаяся длина

Позиция: начиная со второго байта. Оставшаяся длина (Remaining Length) представляет количество байтов в оставшейся части текущего пакета, включая переменный заголовок и данные полезной нагрузки. Оставшаяся длина не включает байты, используемые для кодирования самого поля оставшейся длины.

![Рисунок 2.3 Диапазон пакета, содержащийся в оставшейся длине](http://photos.100ask.net/NewHomeSite/MQTT_Image0004.png)


Поле оставшейся длины использует схему кодирования переменной длины. Для значений меньше 128 используется однобайтовое кодирование. Большие значения обрабатываются следующим образом. Младшие 7 значащих битов используются для кодирования данных, а старший значащий бит используется для указания наличия дополнительных байтов. Таким образом, каждый байт может кодировать 128 значений и бит продолжения (continuation bit). Поле оставшейся длины может занимать максимум 4 байта.

Например, десятичное число 64 будет закодировано как один байт со значением 64, в шестнадцатеричном виде 0x40. Десятичное число 321 (=65+2*128) кодируется двумя байтами, младший байт идет первым. Первый байт равен 65+128=193. Обратите внимание, что старший бит равен 1, что указывает на наличие еще хотя бы одного байта. Второй байт равен 2.

#### 16.2.5.1 Пример

```c
123456  = 964 x 128 + 64

964 = 7x128 + 68

7 < 128

то есть 123456 = (7 x 128 + 68)x128 + 64

Раскрывая: 64 + 68 x128 + 7x128x128

Первый байт: 64 | 0x80 = x (0x80=0x1000 0000 OR со старшим битом указывает на наличие дополнительных байтов)

Второй байт: 68 | 0x80 = y (0x80=0x1000 0000 OR со старшим битом указывает на наличие дополнительных байтов)

Третий байт: 7=z

Представление на языке C: unsigned char len_byte[4] = { 64 | 128 , 68 | 128,  7  , 0 }

Обратная операция для вычисления 123456:

x-128 + (y-128)*128 + z x 128 x 128
```

Преобразование оставшейся длины в байтовое представление:

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0005.png)

Преобразование байтов обратно в оставшуюся длину:

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0006.png)

### 16.2.6 Переменный заголовок

Некоторые управляющие пакеты MQTT содержат часть переменного заголовка. Он находится между фиксированным заголовком и полезной нагрузкой. Содержимое переменного заголовка различается в зависимости от типа пакета. Идентификатор пакета является одним из типов переменного заголовка. Поле идентификатора пакета (Packet Identifier) переменного заголовка присутствует в пакетах нескольких типов.

Типы идентификаторов пакетов показаны на рисунке:

![Рисунок 2.4 Идентификатор пакета](http://photos.100ask.net/NewHomeSite/MQTT_Image0007.png)


Переменная часть заголовка многих управляющих пакетов содержит двухбайтовое поле идентификатора пакета. Эти пакеты: PUBLISH (когда QoS>0), PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, как показано в следующей таблице:

| **Управляющий пакет** | **Поле идентификатора пакета** |
| --------------------- | ------------------------------ |
| **CONNECT**           | Не требуется                   |
| **CONNACK**           | Не требуется                   |
| **PUBLISH**           | Требуется (если QoS > 0)       |
| **PUBACK**            | Требуется                      |
| **PUBREC**            | Требуется                      |
| **PUBREL**            | Требуется                      |
| **PUBCOMP**           | Требуется                      |
| **SUBSCRIBE**         | Требуется                      |
| **SUBACK**            | Требуется                      |
| **UNSUBSCRIBE**       | Требуется                      |
| **UNSUBACK**          | Требуется                      |
| **PINGREQ**           | Не требуется                   |
| **PINGRESP**          | Не требуется                   |
| **DISCONNECT**        | Не требуется                   |

Клиент и сервер независимо назначают идентификаторы пакетов. Таким образом, комбинация клиент-сервер может использовать один и тот же идентификатор пакета для осуществления параллельного обмена сообщениями.

Например, когда клиент отправляет пакет с Packet Identifier = 0x1234 серверу, ответный пакет сервера должен иметь packet identifier = 0x1234. Packet identifier начинается с 1 и увеличивается, достигнув 65535, снова начинает отсчет с 1.

![Рисунок 2.5 Схема взаимодействия типов пакетов, требующих Packet Identifier](http://photos.100ask.net/NewHomeSite/MQTT_Image0008.png)


### 16.2.7 Полезная нагрузка

Некоторые управляющие пакеты MQTT содержат полезную нагрузку в последней части пакета. Типы пакетов с полезной нагрузкой показаны в следующей таблице:

| **Управляющий пакет** | **Полезная нагрузка** |
| --------------------- | --------------------- |
| **CONNECT**           | Требуется             |
| **CONNACK**           | Не требуется          |
| **PUBLISH**           | Опционально           |
| **PUBACK**            | Не требуется          |
| **PUBREC**            | Не требуется          |
| **PUBREL**            | Не требуется          |
| **PUBCOMP**           | Не требуется          |
| **SUBSCRIBE**         | Требуется             |
| **SUBACK**            | Требуется             |
| **UNSUBSCRIBE**       | Требуется             |
| **UNSUBACK**          | Не требуется          |
| **PINGREQ**           | Не требуется          |
| **PINGRESP**          | Не требуется          |
| **DISCONNECT**        | Не требуется          |

## 16.3 Анализ пакетов

### 16.3.1 CONNECT - подключение к серверу

После установления сетевого соединения клиента с сервером (завершения трехстороннего рукопожатия) первым пакетом, который клиент должен отправить серверу, должен быть пакет CONNECT.

![Рисунок 3.1 Процесс взаимодействия трехстороннего рукопожатия и MQTT connect](http://photos.100ask.net/NewHomeSite/MQTT_Image0009.png)



В рамках одного сетевого соединения клиент может отправить пакет CONNECT только один раз. Сервер должен рассматривать второй пакет CONNECT, отправленный клиентом, как нарушение протокола и отключить клиента.

Полезная нагрузка содержит одно или несколько закодированных полей, включая уникальный идентификатор клиента, тему Will, сообщение Will, имя пользователя и пароль. Все поля, кроме идентификатора клиента, являются опциональными и включаются в переменный заголовок на основе битов флагов.

![Рисунок 3.2 Состав пакета connect](http://photos.100ask.net/NewHomeSite/MQTT_Image0010.png)


#### 16.3.1.1 Фиксированный заголовок connect

<table>
   <tr>
      <td>    bit</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
   </tr>
   <tr>
      <td>    Byte1</td>
      <td colspan="4">Тип пакета MQTT (1)</td>
      <td colspan="4">  Reserved (зарезервированные биты)</td>
   </tr>
   <tr>
      <td></td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
   </tr>
   <tr>
      <td>   Byte2~n</td>
      <td>Оставшаяся длина</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
   </tr>
</table>

Таблица 3.1

#### 16.3.1.2 Состав байтов имени протокола

<table>
    <tr>
        <td></td>
        <td>Описание</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td  colspan="10" >Имя протокола</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td>Длина имени протокола MSB(0)</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td>Длина имени протокола LSB(4)</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte3</td>
        <td>'M'</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
    </tr>
    <tr>
        <td>Byte4</td>
        <td>'Q'</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
    </tr>
    <tr>
        <td>Byte5</td>
        <td>'T'</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte6</td>
        <td>'T'</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
</table>

Инструменты обнаружения пакетов, такие как межсетевые экраны, могут использовать имя протокола для идентификации трафика MQTT.

#### 16.3.1.3 Уровень протокола

<table>
    <tr>
        <td></td>
        <td>Описание</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td colspan="10">Уровень протокола</td>
    </tr>
    <tr>
        <td>Byte7</td>
        <td>Level(4)</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
</table>

Клиент использует 8-битное беззнаковое значение для представления версии ревизии протокола. Для протокола версии 3.1.1 значение поля уровня протокола равно 4 (0x04). Если обнаружен неподдерживаемый уровень протокола, сервер должен отправить пакет CONNACK с кодом возврата 0x01 (неподдерживаемый уровень протокола) в ответ на пакет CONNECT, а затем отключить клиента.

#### 16.3.1.4 Флаги подключения

| **бит**    | **7**           | **6**            | **5**        | **4**    | **3**     | **2**         | **1**    | **0** |
| ---------- | --------------- | ---------------- | ------------ | -------- | --------- | ------------- | -------- | ----- |
|            | Флаг имени пользователя | Флаг пароля пользователя | Will retain  | Will qos | Will flag | Очистка сессии | reserved |       |
| **Byte 8** | x               | x                | x            | x        | x         | x             | 0        |       |

**Бит 1 Очистка сессии**

Как правило, при подключении клиент всегда устанавливает флаг очистки сессии в 0 или 1 и не чередует два значения. Этот выбор зависит от конкретного приложения. Клиент с флагом очистки сессии, установленным в 1, не будет получать старые сообщения приложения и должен будет повторно подписаться на все соответствующие темы после каждого успешного подключения. Клиент с флагом очистки сессии, установленным в 0, будет получать все сообщения уровня QoS 1 и QoS 2, опубликованные во время его отключения. Таким образом, чтобы гарантировать отсутствие потери сообщений во время отключения, необходимо использовать уровень QoS 1 или QoS 2 и установить флаг очистки сессии в 0.

**Бит 2 Флаг завещания**

Флаг завещания (Will Flag), установленный в 1, указывает, что если запрос на подключение принят, сообщение завещания (Will Message) должно быть сохранено на сервере и связано с этим сетевым соединением. После закрытия сетевого соединения сервер должен опубликовать это сообщение завещания, если только сервер не удалил это сообщение завещания при получении пакета DISCONNECT.

**Бит 3 и бит 4 QoS завещания**

Эти два бита используются для указания уровня качества обслуживания, используемого при публикации сообщения завещания. Если флаг завещания установлен в 0, QoS завещания также должен быть установлен в 0 (0x00). Если флаг завещания установлен в 1, значение QoS завещания может быть равно 0 (0x00), 1 (0x01), 2 (0x02), но не может быть равно 3.

**Бит 5 Сохранение завещания**

Если сообщение завещания должно быть сохранено при публикации, необходимо указать значение этого бита. Если флаг завещания установлен в 0, флаг сохранения завещания (Will Retain) также должен быть установлен в 0.
Если флаг завещания установлен в 1:
 · Если сохранение завещания установлено в 0, сервер должен опубликовать сообщение завещания как несохраняемое сообщение.
 · Если сохранение завещания установлено в 1, сервер должен опубликовать сообщение завещания как сохраняемое сообщение.

**Бит 7 Флаг имени пользователя**

Если флаг имени пользователя (User Name) установлен в 0, полезная нагрузка не может содержать поле имени пользователя.

Если флаг имени пользователя (User Name) установлен в 1, полезная нагрузка должна содержать поле имени пользователя.

**Бит 6 Флаг пароля пользователя**

Если флаг пароля (Password) установлен в 0, полезная нагрузка не может содержать поле пароля.
Если флаг пароля (Password) установлен в 1, полезная нагрузка должна содержать поле пароля.
Если флаг имени пользователя установлен в 0, флаг пароля также должен быть установлен в 0.

#### 16.3.1.5 Поддержание соединения

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte9</td>
        <td colspan="8">Keep Alive MSB</td>
    </tr>
    <tr>
        <td>Byte10</td>
        <td  colspan="8">Keep Alive LSB</td>
    </tr>
</table>

a) Keep Alive - это временной интервал в секундах, представленный как 16-битное слово, указывающий момент завершения передачи управляющего пакета клиентом.

b) Момент отправки следующего пакета - это максимальный допустимый период простоя между двумя моментами. Клиент отвечает за контроль управления.

c) Временной интервал отправки пакета не должен превышать значение keep alive. Если нет других управляющих пакетов для отправки, клиент должен отправить пакет PINGREQ.

d) Независимо от значения keep alive, клиент может в любое время отправить пакет PINGREQ и использовать пакет PINGRESP для определения активности сети и сервера.

e) Если значение keep alive не равно нулю и сервер не получает управляющий пакет от клиента в течение полуторакратного времени keep alive, он должен отключить сетевое соединение клиента, считая, что сетевое соединение разорвано.

f) После того как клиент отправил пакет PINGREQ, если он все еще не получил пакет PINGRESP в разумные сроки, он должен закрыть сетевое соединение с сервером.

g) Значение keep alive, равное нулю, означает отключение функции keep alive. Это означает, что серверу не нужно отключать соединение из-за неактивности клиента. Обратите внимание: независимо от значения keep alive, в любое время, если сервер считает клиента неактивным или неотвечающим, он может отключить клиента.

#### 16.3.1.6 Идентификатор клиента

Сервер использует идентификатор клиента (ClientId) для идентификации клиента. Каждый клиент, подключающийся к серверу, имеет уникальный идентификатор клиента (ClientId). Клиент и сервер должны использовать ClientId для идентификации состояния, связанного с сессией MQTT между ними. Идентификатор клиента (ClientId) должен присутствовать и должен быть первым полем полезной нагрузки пакета CONNECT. Идентификатор клиента должен быть строкой в кодировке UTF-8.

#### 16.3.1.7 Тема завещания

Если флаг завещания установлен в 1, следующим полем полезной нагрузки является тема завещания (Will Topic). Тема завещания должна быть строкой в кодировке UTF-8.

#### 16.3.1.8 Сообщение завещания

Если флаг завещания установлен в 1, следующим полем полезной нагрузки является сообщение завещания. Сообщение завещания определяет сообщение приложения, которое будет опубликовано в теме завещания.



#### 16.3.1.9 Имя пользователя и пароль

Если флаг имени пользователя (User Name) установлен в 1, следующим полем полезной нагрузки является оно. Имя пользователя должно быть определенной строкой в кодировке UTF-8. Сервер может использовать его для аутентификации и авторизации.

Если флаг пароля (Password) установлен в 1, следующим полем полезной нагрузки является оно. Поле пароля содержит двухбайтовое поле длины, длина указывает количество байтов двоичных данных (не включая два байта, занимаемых самим полем длины), за которыми следуют от 0 до 65535 байтов двоичных данных.

![Рисунок 3.2 Состав имени пользователя и пароля в пакете connect](http://photos.100ask.net/NewHomeSite/MQTT_Image0011.png)


#### 16.3.10.1 Анализ пакета connect с помощью Wireshark

Из захвата пакетов видно, что сверху вниз расположены фиксированный заголовок, переменный заголовок, флаги подключения, keep alive, имя пользователя, пароль пользователя. Поля, связанные с завещанием, отсутствуют, что согласуется с анализом состава фиксированного заголовка в разделе 3.1.1.

![Рисунок 3.3 Анализ состава формата пакета connect с помощью Wireshark](http://photos.100ask.net/NewHomeSite/MQTT_Image0012.png)


#### 16.3.10.2 Построение пакета MQTT connect на языке C

```C
static uint8_t client_id[512] = {"mqtt_client"};
static uint8_t user_name[512] = {"mqtt"};
static uint8_t passwd[512] = {"12345678"};
#define KEEP_ALIVE 20
int mqtt_connect(int sockfd)
{
    uint8 flags = 0x00;
	uint8 *packet = NULL;
	uint16 packet_length = 0;
	uint16 clientidlen = strlen(client_id);
	uint16 usernamelen = strlen(user_name);
	uint16 passwordlen = strlen(passwd);
	uint16 payload_len = clientidlen + 2;
	// Переменный заголовок
	uint8 var_header[10] = {
		0x00,0x04,/*длина*/
        0x4d,0x51,0x54,0x54,/*mqtt*/
		0x04,/*версия протокола*/};

	uint8 fixedHeaderSize = 2;    // Размер по умолчанию = один байт типа сообщения + один байт оставшейся длины
	uint8 remainLen = 0;
	uint8 *fixed_header = NULL;
	uint16 offset = 0;

	// Подготовка флагов
	if(usernamelen) { /*длина имени пользователя (опционально)*/
		payload_len += usernamelen + 2;
		flags |= MQTT_USERNAME_FLAG;/*установить флаг имени пользователя*/
	}
	if(passwordlen) { /*пароль пользователя (опционально)*/
		payload_len += passwordlen + 2;
		flags |= MQTT_PASSWORD_FLAG;/*бит флага пароля пользователя*/
	}
	flags |= MQTT_CLEAN_SESSION;
	var_header[7] = flags;/*флаги подключения*/
	var_header[8] = KEEP_ALIVE>>8;/*поле keep alive, занимает два байта*/
	var_header[9] = KEEP_ALIVE&0xFF;

	remainLen = sizeof(var_header)+payload_len; /*оставшаяся длина, то есть длина переменного заголовка плюс полезная нагрузка*/

	if (remainLen > 127) {
	    fixedHeaderSize++;// добавить дополнительный байт для оставшейся длины
	}

	fixed_header = (uint8 *)malloc(fixedHeaderSize); /*фиксированный заголовок*/
	// Тип сообщения
	*fixed_header = MQTT_MSG_CONNECT;/*тип пакета, connect*/


	if (remainLen <= 127) {// Оставшаяся длина, вычисление оставшейся длины, кодирование переменной длины
	    *(fixed_header+1) = remainLen;
	} else {
	    // первый байт - остаток (mod) от 128, затем установить MSB для указания наличия дополнительных байтов
	    *(fixed_header+1) = remainLen % 128;
	    *(fixed_header+1) = *(fixed_header+1) | 0x80;
	    // второй байт - количество 128-х
	    *(fixed_header+2) = remainLen / 128;
	}

	packet_length = fixedHeaderSize+sizeof(var_header)+payload_len;/*фиксированный заголовок+переменный заголовок+длина полезной нагрузки*/
	packet = (uint8 *)malloc(packet_length);/*выделить память*/
	memset(packet, 0, packet_length);
	memcpy(packet, fixed_header, fixedHeaderSize);/*заполнить фиксированный заголовок*/
	free(fixed_header);
	offset += fixedHeaderSize;
	memcpy(packet+offset, var_header, sizeof(var_header));/*заполнить переменный заголовок*/
	offset += sizeof(var_header);

	packet[offset++] = clientidlen>>8;// Client ID - UTF encoded, заполнить длину clientid + clientid
	packet[offset++] = clientidlen&0xFF;
	memcpy(packet+offset, client_id, clientidlen);
	offset += clientidlen;

	if(usernamelen) {// Имя пользователя - UTF encoded, заполнить имя пользователя + длину имени пользователя
		packet[offset++] = usernamelen>>8;
		packet[offset++] = usernamelen&0xFF;
		memcpy(packet+offset, user_name, usernamelen);
		offset += usernamelen;
	}

	if(passwordlen) {// Пароль - UTF encoded, заполнить пароль пользователя + длину пароля пользователя
		packet[offset++] = passwordlen>>8;
		packet[offset++] = passwordlen&0xFF;
		memcpy(packet+offset, passwd, passwordlen);
		offset += passwordlen;
	}
	// Отправить пакет
    if (client_send(sockfd,packet, packet_length) < 0){
         free(packet);
        return -1;
    }
    free(packet);
	return 1;
}
```

### 16.3.2 CONNACK - подтверждение запроса на подключение

Сервер отправляет пакет CONNACK в ответ на пакет CONNECT, полученный от клиента. Первым пакетом, который сервер отправляет клиенту, должен быть CONNACK.

#### 16.3.2.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td  colspan="4">Тип управляющего пакета MQTT (2)</td>
        <td  colspan="4">Reserved зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td  colspan="8">Оставшаяся длина</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
    </tr>
</table>

Поле оставшейся длины указывает длину переменного заголовка. Для пакета CONNACK это значение равно 2.

#### 16.3.2.2 Переменный заголовок

<table>
    <tr>
        <td></td>
        <td>Описание</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td  colspan="2">Флаги подтверждения подключения</td>
        <td  colspan="7">Зарезервированные биты</td>
        <td >SP1</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td></td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>X</td>
    </tr>
    <tr>
        <td  colspan="10">Код возврата подключения</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td></td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
    </tr>
</table>
**Byte1, Бит 0 Флаг подтверждения подключения**

Биты 7-1 зарезервированы и должны быть установлены в 0.

Для бита 0, если сервер получил подключение с CleanSession равным 0, значение флага текущей сессии зависит от того, сохранил ли сервер состояние сессии для ClientId соответствующего клиента. Если сервер сохранил состояние сессии, он должен установить флаг текущей сессии в пакете CONNACK в 1. Если сервер не имеет сохраненного состояния сессии, он должен установить флаг текущей сессии в пакете CONNACK в 0. Также необходимо установить код возврата в пакете CONNACK в 0.

**Код возврата подключения**

Если сервер отправил пакет CONNACK, содержащий ненулевой код возврата, он должен закрыть сетевое соединение.

| **Значение** | **Ответ кода возврата** | **Описание**                                                        |
| ------------ | ----------------------- | ------------------------------------------------------------------- |
| **0**        | 0x00                    | Соединение принято сервером                                         |
| **1**        | 0x01                    | Сервер не поддерживает версию протокола, запрошенную клиентом      |
| **2**        | 0x02                    | Идентификатор клиента в правильной кодировке UTF-8, но сервер не разрешает его использование |
| **3**        | 0x03                    | Сетевое соединение установлено, но служба MQTT недоступна           |
| **4**        | 0x04                    | Формат данных имени пользователя или пароля недействителен          |
| **5**        | 0x05                    | Клиент не авторизован для подключения к этому серверу               |
| **6-255**    |                         | Зарезервировано                                                     |

CONNACK не имеет полезной нагрузки.

#### 16.3.2.3 Анализ пакета CONNACK с помощью Wireshark

![Рисунок 3.4 Захваченный пакет CONNACK](http://photos.100ask.net/NewHomeSite/MQTT_Image0013.png)


#### 16.3.2.4 Построение пакета connect ack на языке C

```c
void mqtt_connect_ack(int sockfd)
{
	uint8_t cmd[]={ 0x20/*тип пакета*/, 0x02/*оставшаяся длина*/ ,0x00,0x00/*последние два байта переменного заголовка указывают код состояния возврата*/ };
	send_msg(sockfd,cmd,sizeof(cmd));
	socket_record_t *socket_record = look_up_by_sokfd(sockfd);
	if(socket_record==NULL){
		return;
	}
	socket_record->is_connect=0x01;
}
```

### 16.3.3 PUBLISH - публикация сообщения

Управляющий пакет PUBLISH используется для передачи сообщения приложения от клиента к серверу или от сервера к клиенту.

![Рисунок 3.5 Формат состава пакета publish](http://photos.100ask.net/NewHomeSite/MQTT_Image0014.png)


#### 16.3.3.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td  colspan="4">Тип пакета MQTT (3)</td>
        <td>dup</td>
        <td  colspan="2">Уровень QoS</td>
        <td>RETAIN</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
        <td>x</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td  colspan="8">Оставшаяся длина</td>
    </tr>
</table>
**Бит 3 dup**

Если флаг DUP установлен в 0, это указывает, что это первый запрос клиента или сервера на отправку этого пакета PUBLISH. Если флаг DUP установлен в 1, это может указывать на повторную отправку более раннего запроса пакета. При запросе повторной отправки пакета PUBLISH клиент или сервер должен установить флаг DUP в 1. Для сообщений QoS 0 флаг DUP должен быть установлен в 0.

**Бит 1 и бит 2 уровень QoS**

| Значение QoS | бит 2 | бит 1 | Описание                    |
| ------------ | ----- | ----- | --------------------------- |
| 0            | **0** | **0** | **Максимум одна доставка**  |
| 1            | **0** | **1** | **Минимум одна доставка**   |
| 2            | **1** | **0** | **Только одна доставка**    |
| -            | **1** | **1** | **Зарезервировано, не использовать** |

QoS определяется отправителем. Какой QoS отправляет отправитель, таким QoS получатель и отвечает.

![Процесс взаимодействия пакетов MQTT для разных уровней QoS](http://photos.100ask.net/NewHomeSite/MQTT_Image0015.png)

**Бит 0 Бит флага сохранения**

Обычно устанавливается в 0.

**Оставшаяся длина**

Равна длине переменного заголовка плюс длина полезной нагрузки.

**Переменный заголовок**

Переменный заголовок содержит по порядку имя темы и идентификатор. Тема используется для определения, в какой информационный канал должны быть опубликованы данные полезной нагрузки. Идентификатор может присутствовать в пакете PUBLISH только когда уровень QoS равен 1 или 2.

#### 16.3.3.2 Анализ пакета PUBLISH с помощью захвата

![Рисунок 3.6 Захваченный пакет PUBLISH](http://photos.100ask.net/NewHomeSite/MQTT_Image0016.png)


#### 16.3.3.3 Построение пакета publish

```c
int mqtt_publish_with_qos(int sockfd,const char* topic, const char* msg, uint16 msgl, uint8 retain, uint8 qos, uint16* message_id)
{
    socket_record_t *socket_record = look_up_by_sokfd(sockfd);
    if(NULL == socket_record){
        return -1;
    }
    DEBUG_INFO("sockfd:%d",socket_record->sockfd);
	uint16 topiclen = strlen(topic);
	uint16 msglen = msgl;
	uint8 *var_header = NULL; // Размер темы (2 байта), тема в кодировке UTF
	uint8 *fixed_header = NULL;
	uint8 fixedHeaderSize = 0,var_headerSize = 0; // Размер по умолчанию = один байт типа сообщения + один байт оставшейся длины
	uint16 remainLen = 0;
	uint8 *packet = NULL;
	uint16 packet_length = 0;

	uint8 qos_flag = MQTT_QOS0_FLAG; /*флаг QoS*/
	uint8 qos_size = 0; // Без QoS
	if(qos == 1) {
		qos_size = 2; // 2 байта для QoS
		qos_flag = MQTT_QOS1_FLAG;
	}
	else if(qos == 2) {
		qos_size = 2; // 2 байта для QoS
		qos_flag = MQTT_QOS2_FLAG;
	}

	// Переменный заголовок
	var_headerSize = topiclen/*содержимое темы*/+2/*длина темы занимает два байта*/+qos_size/*идентификатор*/;
	var_header = (uint8 *)malloc(var_headerSize);
	memset(var_header, 0, var_headerSize);
	*var_header = topiclen>>8;
	*(var_header+1) = topiclen&0xFF;
	memcpy(var_header+2, topic, topiclen);
	if(qos_size) {// пакеты QoS 1 и QoS 2 требуют заполнения идентификатора, похоже на seq в TCP
        socket_record->publish_seq++;
        if(socket_record->publish_seq == 0){
            // unsigned short представляет диапазон 0~65535, идентификатор должен быть ненулевым целым числом
            socket_record->publish_seq = 1;
        }
		var_header[topiclen+2] = (socket_record->publish_seq & 0xff00)>>8;
		var_header[topiclen+3] = socket_record->publish_seq & 0x00ff;
		if(message_id) {
			*message_id = socket_record->publish_seq;
		}
	}

	fixedHeaderSize = 2;    // Размер по умолчанию = один байт типа сообщения + один байт оставшейся длины
	remainLen = var_headerSize+msglen;
	if (remainLen > 127) {/*оставшаяся длина*/
		fixedHeaderSize++;          // добавить дополнительный байт для оставшейся длины
	}
	fixed_header = (uint8 *)malloc(fixedHeaderSize);/*фиксированный заголовок + оставшаяся длина*/

	// Тип сообщения, флаг DUP, уровень QoS, Retain
	*fixed_header = MQTT_MSG_PUBLISH | qos_flag;/*тип пакета и флаг QoS*/
	if(retain) {
		*fixed_header  |= MQTT_RETAIN_FLAG;/*сохранить или нет*/
	}
	// Оставшаяся длина
	if (remainLen <= 127) {
	   *(fixed_header+1) = remainLen;
	} else {
	   // первый байт - остаток (mod) от 128, затем установить MSB для указания наличия дополнительных байтов
	   *(fixed_header+1) = remainLen % 128;
	   *(fixed_header+1) = *(fixed_header+1) | 0x80;
	   // второй байт - количество 128-х
	   *(fixed_header+2) = remainLen / 128;
	}

	packet_length = fixedHeaderSize+var_headerSize+msglen;/*фиксированный заголовок+переменный заголовок+длина полезной нагрузки*/
	packet = (uint8 *)malloc(packet_length);
	memset(packet, 0, packet_length);
	memcpy(packet, fixed_header, fixedHeaderSize);/*заполнить фиксированный заголовок*/
	memcpy(packet+fixedHeaderSize, var_header, var_headerSize);/*заполнить переменный заголовок*/
	memcpy(packet+fixedHeaderSize+var_headerSize, msg, msglen);/*полезная нагрузка*/
	free(var_header);
	free(fixed_header);
    send_msg(sockfd,packet , packet_length);
	free(packet);
	return 1;
}
```

### 16.3.4 PUBREC - получение публикации

Пакет PUBREC является ответом на пакет PUBLISH уровня QoS 2. Это второй пакет в обмене протоколом уровня QoS 2.

#### 16.3.4.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td   colspan="4">Тип пакета MQTT (5)</td>
        <td   colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td   colspan="8">Оставшаяся длина</td>
    </tr>
</table>
**Оставшаяся длина**

Представляет длину переменного заголовка. Для пакета PUBREC это значение равно 2.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>
**Полезная нагрузка**

Пакет PUBREC не имеет полезной нагрузки.

#### 16.3.4.2 Захваченный пакет PUBREC

![Рисунок 3.7 Диаграмма захваченного пакета PUBREC](http://photos.100ask.net/NewHomeSite/MQTT_Image0017.png)


#### 16.3.4.3 Построение пакета PUBREC на языке C

```c
// Если это пакет PUBREC, head_type=0x50
void mqtt_qos2_pubrec(int  sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);/*идентификатор пакета, идентификатор ответного пакета и принятого пакета должен быть одинаковым*/
	unsigned char qos2_pubrec_respon[]={head_type/*фиксированный заголовок*/,0x02/*оставшаяся длина*/, (msg_id&0xff00)>>8 , msg_id&0x00ff/*последние два байта - идентификатор пакета*/};
	send_msg(sockfd,qos2_pubrec_respon,sizeof(qos2_pubrec_respon));
}
```

### 16.3.5 PUBREL - освобождение публикации

Пакет PUBREL является ответом на пакет PUBREC. Это третий пакет в обмене протоколом уровня QoS 2.

#### 16.3.5.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (6)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина</td>
    </tr>
</table>
**Оставшаяся длина**

Представляет длину переменного заголовка. Для пакета PUBREL это значение равно 2.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>
**Полезная нагрузка**

Пакет PUBREL не имеет полезной нагрузки.

#### 16.3.5.2 Захваченный пакет PUBREL

![Рисунок 3.8 Диаграмма захваченного пакета PUBREL](http://photos.100ask.net/NewHomeSite/MQTT_Image0018.png)


#### 16.3.5.3 Построение пакета PUBREL на языке C

```c
// head_type=0x62
void mqtt_qos2_pubrel(int sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);
	unsigned char qos2_pubrel_respon[]={head_type/*тип пакета*/,0x02/*оставшаяся длина*/, (msg_id & 0xff00)>>8 , msg_id & 0x00ff/*последние два байта - идентификатор пакета*/};
	send_msg(sockfd,qos2_pubrel_respon,sizeof(qos2_pubrel_respon));
}
```

### 16.3.6 PUBCOMP - завершение публикации

Пакет PUBCOMP является ответом на пакет PUBREL. Это четвертый и последний пакет в обмене протоколом уровня QoS 2.

#### 16.3.6.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (7)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина</td>
    </tr>
</table>
**Оставшаяся длина**

Представляет длину переменного заголовка. Для пакета PUBCOMP это значение равно 2.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>
**Полезная нагрузка**

Пакет PUBCOMP не имеет полезной нагрузки.

#### 16.3.6.2 Захваченный пакет PUBCOMP

![Рисунок 3.9 Диаграмма захваченного пакета PUBCOMP](http://photos.100ask.net/NewHomeSite/MQTT_Image0019.png)


#### 16.3.6.3 Построение пакета PUBCOMP на языке C

```c
// head_type=0x70
void mqtt_qos2_pubcomp(int   sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);/*идентификатор пакета*/
	unsigned char qos2_pubcomp_respon[]={head_type/*тип пакета*/,0x02/*оставшаяся длина*/, (msg_id & 0xff00)>>8 , msg_id & 0x00ff/*последние два байта - идентификатор пакета*/};
	send_msg(sockfd,qos2_pubcomp_respon,sizeof(qos2_pubcomp_respon));
}
```

### 16.3.7 PINGREQ - запрос heartbeat

Клиент отправляет пакет PINGREQ серверу. Используется для:

a) Когда от клиента к серверу не отправляется никаких других управляющих пакетов, информировать сервер о том, что клиент еще жив.

b) Запросить у сервера отправку ответного подтверждения о том, что он еще жив.

c) Использовать сеть для подтверждения того, что сетевое соединение не разорвано.

#### 16.3.7.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (12)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>
**Переменный заголовок**

Пакет не имеет переменного заголовка.

**Полезная нагрузка**

Пакет PINGREQ не имеет полезной нагрузки.

#### 16.3.7.2 Захваченный пакет PINGREQ

![Рисунок 3.10 Диаграмма захваченного пакета PINGREQ](http://photos.100ask.net/NewHomeSite/MQTT_Image0020.png)


#### 16.3.7.3 Построение пакета PINGREQ на языке C

```c
int mqtt_ping(int sockfd)
{
	uint8 packet[] = {MQTT_MSG_PINGREQ/*тип пакета*/,0x00/*оставшаяся длина*/};
	int ret = send_msg(sockfd,packet, sizeof(packet));
	return ret;
}
```

### 16.3.8 PINGRESP - ответ heartbeat

Сервер отправляет пакет PINGRESP в ответ на пакет PINGREQ клиента. Указывает, что сервер еще жив.

#### 16.3.8.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (13)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>
**Переменный заголовок**

Пакет не имеет переменного заголовка.

**Полезная нагрузка**

Пакет PINGRESP не имеет полезной нагрузки.

#### 16.3.8.2 Захваченный пакет PINGRESP

![Рисунок 3.11 Диаграмма захваченного пакета PINGRESP](http://photos.100ask.net/NewHomeSite/MQTT_Image0021.png)


#### 16.3.8.3 Построение пакета PINGRESP на языке C

```c
void mqtt_ping_req_reply(int sockfd)
{
    uint8_t cmd[]={0xd0/*тип пакета*/, 0x00/*оставшаяся длина*/};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

### 16.3.9 DISCONNECT - отключение

Пакет DISCONNECT является последним управляющим пакетом, отправляемым клиентом серверу. Указывает на нормальное отключение клиента.

#### 16.3.9.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (14)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>

**Переменный заголовок**

Пакет DISCONNECT не имеет переменного заголовка.

**Полезная нагрузка**

Пакет DISCONNECT не имеет полезной нагрузки.

#### 16.3.9.2 Захваченный пакет DISCONNECT

![Рисунок 3.12 Диаграмма захваченного пакета DISCONNECT](http://photos.100ask.net/NewHomeSite/MQTT_Image0022.png)


#### 16.3.9.3 Построение пакета disconnect на языке C

```c
int mqtt_disconnect(int sockfd)
{
	uint8 packet[] = {MQTT_MSG_DISCONNECT/*тип пакета*/,0x00/*оставшаяся длина*/};
	int ret = client_send(sockfd,packet, sizeof(packet));
    DEBUG_INFO("ret=%d",ret);
	return ret;
}
```

### 16.3.10 SUBSCRIBE - подписка на тему

Клиент отправляет пакет SUBSCRIBE серверу для создания одной или нескольких подписок. Каждая подписка регистрирует одну или несколько тем, интересующих клиента. Для пересылки сообщений приложения клиенту с темами, соответствующими этим подпискам, сервер отправляет пакеты PUBLISH клиенту. Пакет SUBSCRIBE также указывает (для каждой подписки) максимальный уровень QoS, согласно которому сервер отправляет сообщения приложения клиенту.

![Рисунок 3.13 Формат состава пакета подписки на тему](http://photos.100ask.net/NewHomeSite/MQTT_Image0023.png)


#### 16.3.10.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (8)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>

Биты 3, 2, 1, 0 фиксированного заголовка управляющего пакета SUBSCRIBE зарезервированы и должны быть установлены соответственно в 0, 0, 1, 0. Сервер должен рассматривать любое другое значение как недопустимое и закрывать сетевое соединение.

**Поле оставшейся длины**
Равно длине переменного заголовка (2 байта) плюс длина полезной нагрузки.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>

Когда сервер получает пакет SUBSCRIBE, отправленный клиентом, он должен ответить пакетом SUBACK. Пакет SUBACK должен иметь тот же идентификатор пакета, что и пакет SUBSCRIBE, ожидающий подтверждения.

**Полезная нагрузка**

<table>
    <tr>
        <td></td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td colspan="9">Тема</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td  colspan="8">Длина темы MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td colspan="8">Длина темы LSB</td>
    </tr>
    <tr>
        <td>Byte3~n</td>
        <td colspan="8">Тема</td>
    </tr>
    <tr>
        <td colspan="9">Качество обслуживания</td>
    </tr>
    <tr>
        <td colspan="8">Зарезервировано</td>
        <td>Уровень QoS</td>
    </tr>
    <tr>
        <td>ByteN+1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>x</td>
        <td>x</td>
    </tr>
</table>


Если QoS не равен 0, 1 или 2, сервер должен считать пакет SUBSCRIBE недопустимым и закрыть сетевое соединение.

#### 16.3.10.2 Захват пакета SUBSCRIBE

![Рисунок 3.14 Захваченный пакет подписки на тему](http://photos.100ask.net/NewHomeSite/MQTT_Image0024.png)


#### 16.3.10.3 Построение пакета subscribe на языке C

```c
static uint16 su_seq = 1;
int mqtt_subscribe_theme(int sockfd,char *Theme , uint8_t Qos)
{
	su_seq++; // идентификатор пакета
	if(su_seq == 0){
		su_seq = 1;
	}
	uint16_t MessageId = su_seq;
	uint8_t cmd[1024]={0};
    // длина идентификатора пакета 2 + биты длины темы занимают 2 байта + содержимое темы + идентификатор QoS
	int data_length = 2+2+strlen(Theme)+1;
	int playload_len = strlen(Theme);
	uint8_t len_byte[4] ={0x00 , 0x00 ,0x00 ,0x00};
	uint8_t byte_num = length_trans_byte_form(data_length , len_byte);/*преобразовать оставшуюся длину в кодирование переменной длины*/
	cmd[0] = 0x82;
	memcpy(&cmd[1] , len_byte , byte_num);

	cmd[1+byte_num]=(MessageId & 0xff00) >> 8 ;
	cmd[1+byte_num+1] = MessageId & 0x00ff;
	cmd[1+byte_num+1+1] = (playload_len & 0xff00) >> 8;
	cmd[1+byte_num+1+1+1] = playload_len & 0x00ff;
	memcpy(&cmd[1+byte_num+1+1+1+1] , Theme , playload_len);
	cmd[1+byte_num+1+1+1+1+playload_len] = Qos;
	client_send(sockfd,cmd, 1+byte_num+1+1+1+1+playload_len+1);
}
```

### 16.3.11 SUBACK - подтверждение подписки

Сервер отправляет пакет SUBACK клиенту, чтобы подтвердить, что он получил и обрабатывает пакет SUBSCRIBE.

#### 16.3.11.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (9)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>
**Поле оставшейся длины**
Равно длине переменного заголовка плюс длина полезной нагрузки.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>

Переменный заголовок содержит идентификатор пакета из пакета SUBSCRIBE, ожидающего подтверждения.

### 3.11.2 Захваченный пакет SUBACK

![Рисунок 3.15 Захваченный пакет подтверждения подписки на тему](http://photos.100ask.net/NewHomeSite/MQTT_Image0025.png)


#### 16.3.11.3 Построение пакета SUBACK на языке C

```c
void mqtt_subscribe_ack(int sockfd,const uint8 *buf)
{
    uint16 msg_id = mqtt_parse_msg_id(buf);/*извлечь идентификатор пакета*/
    uint8 qos = MQTTParseMessageQos(buf);/*извлечь QoS пакета*/
    uint8 cmd[]={0x90,0x03/*оставшаяся длина*/, (msg_id & 0xff00) >> 8, msg_id & 0x00ff,qos};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

### 16.3.12 UNSUBSCRIBE - отписка

Клиент отправляет пакет UNSUBSCRIBE серверу для отмены подписки на темы.

![Рисунок 3.16 Структура пакета отписки от темы](http://photos.100ask.net/NewHomeSite/MQTT_Image0026.png)


#### 16.3.12.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (10)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>

Биты 3, 2, 1, 0 фиксированного заголовка пакета UNSUBSCRIBE зарезервированы и должны быть установлены соответственно в 0, 0, 1, 0. Сервер должен считать любое другое значение недопустимым и закрывать сетевое соединение.

**Поле оставшейся длины**
Равно длине переменного заголовка плюс длина полезной нагрузки.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>

Переменный заголовок содержит идентификатор пакета.

**Полезная нагрузка**

<table>
    <tr>
        <td></td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td colspan="9">Тема 1</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td colspan="8">Длина темы MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td colspan="8">Длина темы LSB</td>
    </tr>
    <tr>
        <td>Byte3~n</td>
        <td colspan="8">Тема</td>
    </tr>
    <tr>
        <td colspan="9">Тема 2</td>
    </tr>
</table>

Полезная нагрузка пакета UNSUBSCRIBE должна содержать хотя бы один фильтр сообщений. Пакет UNSUBSCRIBE без полезной нагрузки нарушает протокол.

#### 16.3.12.2 Захваченный пакет UNSUBSCRIBE

![Рисунок 3.17 Захваченный пакет отписки от темы](http://photos.100ask.net/NewHomeSite/MQTT_Image0027.png)

#### 16.3.12.3 Построение пакета unsubscribe на языке C

```c
static uint16 un_seq = 1;
int mqtt_unsubscribe_theme(int sockfd,const char* topic)
{
	un_seq++;
	if(un_seq == 0){
		un_seq = 1;
	}
    uint16_t MessageId = un_seq;
	uint8_t cmd[1024]={0};
    // длина идентификатора пакета 2 + биты длины темы занимают 2 байта + содержимое темы + идентификатор QoS
	int data_length = 2+2+strlen(topic)+1;
	int playload_len = strlen(topic);
	uint8_t len_byte[4] ={0x00 , 0x00 ,0x00 ,0x00};
	uint8_t byte_num = length_trans_byte_form(data_length , len_byte);/*преобразовать оставшуюся длину в кодирование переменной длины*/
	cmd[0] = 0xa2;
	memcpy(&cmd[1] , len_byte , byte_num);

	cmd[1+byte_num]=(MessageId & 0xff00) >> 8 ;
	cmd[1+byte_num+1] = MessageId & 0x00ff;
	cmd[1+byte_num+1+1] = (playload_len & 0xff00) >> 8;
	cmd[1+byte_num+1+1+1] = playload_len & 0x00ff;
	memcpy(&cmd[1+byte_num+1+1+1+1] , topic , playload_len);
	client_send(sockfd,cmd,1+byte_num+1+1+1+1+playload_len+1);
	return 1;
}
```

### 16.3.13 UNSUBACK - подтверждение отписки

Сервер отправляет пакет UNSUBACK клиенту для подтверждения получения пакета UNSUBSCRIBE.

![Рисунок 3.18 Состав пакета подтверждения отписки от темы](http://photos.100ask.net/NewHomeSite/MQTT_Image0028.png)


#### 16.3.13.1 Фиксированный заголовок

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte 1</td>
        <td    colspan="4">Тип пакета MQTT (11)</td>
        <td    colspan="4">Зарезервированные биты</td>
    </tr>
    <tr>
        <td></td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td     colspan="8">Оставшаяся длина 0</td>
    </tr>
</table>
**Поле оставшейся длины**
Представляет длину переменного заголовка. Для пакета UNSUBACK это значение равно 2.

**Переменный заголовок**

<table>
    <tr>
        <td>бит</td>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>Byte1</td>
        <td    colspan="8">Идентификатор пакета MSB</td>
    </tr>
    <tr>
        <td>Byte2</td>
        <td    colspan="8">Идентификатор пакета LSB</td>
    </tr>
</table>

Переменный заголовок содержит идентификатор пакета из пакета UNSUBSCRIBE, ожидающего подтверждения.

#### 16.3.12.2 Захваченный пакет UNSUBSCRIBE ACK

![Рисунок 3.19 Захваченный пакет подтверждения отписки от темы](http://photos.100ask.net/NewHomeSite/MQTT_Image0029.png)


#### 16.3.12.3 Построение пакета unsubscribe на языке C

```c
void mqtt_unsubscribe_ack(int sockfd,const uint8 *buf)
{
    uint16 msg_id = mqtt_parse_msg_id(buf);
    uint8 cmd[]={0xb0,0x02/*оставшаяся длина*/,(msg_id & 0xff00) >> 8, msg_id & 0x00ff/*последние два байта - идентификатор пакета*/};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

### 16.3.14 Процесс взаимодействия между сервером и клиентом

#### 16.3.14.1 Компиляция

Перед компиляцией клиента сначала укажите IP сервера в коде

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0030.png)

Войдите в каталог client и выполните make

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0031.png)

Войдите в каталог server и выполните make

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0032.png)

#### 16.3.14.2 Выполнение

Сначала запустите server

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0033.png)

Затем запустите client

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0034.png)

Процесс работы Client

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0035.png)

Просмотр на стороне server

![](http://photos.100ask.net/NewHomeSite/MQTT_Image0036.png)
