# 10 RTC - Часы реального времени

## 10.1 Назначение RTC и представление времени

"RTC" (Real-Time Clock) переводится как "часы реального времени". Чип часов реального времени является одним из наиболее широко используемых электронных устройств в повседневной жизни, он обеспечивает людей или электронные системы точным реальным временем. Чип часов реального времени предоставляет интерфейс для чтения и записи времени через выводы, обычно имеет встроенную батарею, что гарантирует нормальную работу внутренней схемы и поддержание времени при выключении внешней системы. Разные чипы часов имеют различные внутренние механизмы, форматы хранения данных времени и методы операций чтения/записи. Система Linux и драйверы инкапсулируют детали работы различных чипов часов, предоставляя приложениям единый интерфейс для операций со временем.

Итак, как представляется время в мире Linux? Используется ли год, месяц, день + часы, минуты, секунды, как это делают люди? Умные программисты, конечно, не заставляют компьютер делать это таким образом. Чем проще, тем научнее - время представляется целым числом, которое обозначает разницу во времени (в секундах) от Epoch Time. Epoch Time - это конкретное время: 1 января 1970 года, 00:00:00. Предположим, что прошло N секунд с 1 января 1970 года 00:00:00, в системе Linux значение времени будет равно N.

Возникает вопрос: почему отсчет начинается с 1 января 1970 года 00:00:00? Что произошло в том году, что Unix-система взяла его за "эпоху"? Дело в том, что Unix был создан именно в ту эпоху - прототип был выпущен в 1969 году, изначально основывался на счетчике времени оборудования с частотой 60 Гц. В "Unix Programmer's Manual", опубликованном в конце 1971 года, Unix Time был определен с началом отсчета 1 января 1971 года 00:00:00, увеличиваясь на 60 каждую секунду. Позже, учитывая, что если считать 60 чисел в секунду, максимальное значение времени будет достигнуто через 1,1 года, было решено считать в секундах, что позволило представлять время до 68,1 лет. Поэтому перестало иметь значение, был ли начальный год 1970 или 1971, и выбрали 1970 год для удобства запоминания и вычислений. Так началась "эпоха" мира Unix, и метка времени Unix стала специальным термином. Позже система Linux переняла этот способ определения времени.

В то время компьютерные операционные системы были 32-битными, и время также представлялось 32-битным знаковым числом с диапазоном значений от -2147483648 до 2147483647, то есть максимальное значение времени могло быть только 2147483647 (секунд), что в годах составляет 2147483647÷365÷24÷60÷60=68,1 лет, то есть максимальное время, которое может представить 32-битное число, это 1970+68,1=2038 год. Точнее, 19 января 2038 года 03:14:07, время достигнет максимального значения 0x7FFFFFFF. После этого момента следующая секунда приведет к значению 0x80000000, что соответствует 13 декабря 1901 года 20:45:52, что приведет к явлению возврата времени назад, и многие системы будут работать неправильно.

Как было сказано выше, это было в "год основания" системы Unix, 32-битного времени было достаточно для решения проблем того времени. Сейчас основные процессоры 64-битные, использование 64-битных данных для представления времени - естественное дело. Используя 64-битное знаковое число для представления времени, можно представить до 292 277 026 596 года, 4 декабря, 15:30:08, и нам больше не придется беспокоиться о проблеме возврата времени.

## 10.2 Команды для работы с RTC

После того, как мы разобрались, как представляется время, как Linux использует и поддерживает время? Как мы можем управлять временем через Linux?

### 10.2.1 Системное время и аппаратное время

В Linux существует два типа часов: системные часы и аппаратные часы. Системное время поддерживается таймером основного чипа процессора. Обычно выбирается таймер с наивысшей точностью на чипе в качестве основы для системного времени, чтобы избежать больших временных смещений при длительной работе системы. Особенность в том, что при отключении питания системы системное время теряется. Аппаратные часы - это время, поддерживаемое внутри чипа RTC в системе. Чипы RTC имеют двойной механизм питания: батарея + системное питание. При нормальной работе системы питание подается от системы, при отключении системного питания - от батареи. Поэтому после отключения системного питания время RTC продолжает нормально работать. Основная цель аппаратных часов в системе Linux - сохранять время, когда Linux не работает.

При загрузке Linux системное время инициализируется из аппаратных часов, затем аппаратные часы больше не используются. При запуске системы операционная система Linux считывает аппаратное время из чипа RTC, после чего время поддерживается внутренним таймером процессора. После этого операционная система использует системное время, если явно не управлять операциями чтения/записи RTC с помощью команд, система больше не будет получать или синхронизировать время с RTC.

### 10.2.2 Команды для работы с системным временем

Просмотр системного времени:

```c
date
Sat May  1 08:11:19 EDT 2020
```

Форматированный вывод:

```c
date +"%Y-%m-%d"
2020-05-01
```

Вывод через 2 секунды:

```c
date -d "2 second" +"%Y-%m-%d %H:%M.%S"
2020-05-01 14:21.31
```

Отобразить время 1234567890 секунд:

```c
date -d "1970-01-01 1234567890 seconds" +"%Y-%m-%d %H:%m:%S"
2009-02-13 23:02:30
```

Обычное преобразование формата:

```c
date -d "2009-05-01" +"%Y/%m/%d %H:%M.%S"
2020/05/01 00:00.00
```

Вывод других дат:

```c
date -d "+1 day" +%Y%m%d   # Отобразить дату следующего дня
date -d "-1 day" +%Y%m%d   # Отобразить дату предыдущего дня
date -d "-1 month" +%Y%m%d # Отобразить дату предыдущего месяца
date -d "+1 month" +%Y%m%d # Отобразить дату следующего месяца
date -d "-1 year" +%Y%m%d  # Отобразить дату предыдущего года
date -d "+1 year" +%Y%m%d  # Отобразить дату следующего года
```

Установка системного времени:

```c
date -s 20200501 # Установить на 20200501, это установит конкретное время в 00:00:00
date -s 01:01:01 # Установить конкретное время, не изменяя дату
date -s "01:01:01 2020-05-01" # Так можно установить полное время
date -s "01:01:01 20200501"    # Так можно установить полное время
date -s "2020-05-01 01:01:01" # Так можно установить полное время
date -s "20200501 01:01:01"    # Так можно установить полное время
```

Дополнительные параметры команды можно найти на: https://www.cnblogs.com/machangwei-8/p/10352546.html

### 10.2.3 Команды для работы с аппаратным временем

Отобразить аппаратное время:

```c
hwclock или hwclock -r или hwclock --show
2000年04月11日 星期二 13时24分35秒  -0.109687 seconds
```

Установить аппаратные часы:

```c
hwclock --set --date '2015-04-11 13:36:11'
```

Синхронизировать системное время с аппаратным:

```c
hwclock -w
```

Синхронизировать аппаратное время с системным:

```c
hwclock -s
```

Дополнительные параметры команды можно найти на: https://www.cnblogs.com/wj78080458/p/9806774.html

## 10.3 Структуры данных и функции RTC

В среде Linux мы научились использовать команды для изменения системного и аппаратного времени. При программировании мы, конечно, можем напрямую использовать системный вызов `system` для работы со временем, но это не только выглядит непрофессионально, но и не может удовлетворить большинство требований, потому что во многих случаях нам нужно не просто изменить время, а выполнить вычисления со временем.

При программировании RTC важно изучить структуры, связанные со временем, и соответствующие функции.

### 10.3.1 Структуры данных, связанные со временем

В программировании на C часто требуется запускать события по таймеру, что связано с получением системного времени. Существует несколько типов структур данных. В системе Linux типы данных, связанные со временем, определены в заголовочном файле `/usr/include/sys/time.h`:

Основные типы данных, связанные со временем:

#### 1. Тип time_t: длинное целое

Обычно используется для представления количества секунд, прошедших с Epoch Time (полночь 1 января 1970 года (00:00:00)), в секундах.

```c
#define _TIME_T
	typedef    long    time_t;
#endif
```

Данные `time_t` получаются функцией `time_t time(time_t* lpt)`, которая возвращает время, прошедшее с Epoch Time (полночь 1 января 1970 года (00:00:00)), в секундах. Если `lpt` не пусто, возвращаемое значение также сохраняется в переменной, на которую указывает `lpt`.

Пример:

```
time_t t = time(NULL);
```

#### 2. Структура struct timeb

Имеет четыре члена: один для секунд, другой для миллисекунд.

```c
struct timeb{
    time_t  time;
    unsigned short millitm;
    short   timezone;
    short   dstflag;
};
```

`time` - количество секунд, накопленных с Epoch Time (полночь 1 января 1970 года (00:00:00)).

`millitm` - количество миллисекунд в секунде.

`dstflag` - если не равен 0, это летнее время.

`timezone` - разница в минутах между UTC и местным временем.

Получается функцией `int ftime(struct timeb *tp)`, при успешном вызове возвращает 0, при неудаче возвращает -1.

Пример:

```c
struct timeb tp;
ftime(&tp);
```

#### 3. Структуры struct timeval и struct timezone

`timeval` имеет два члена: один для секунд, другой для микросекунд.

```c
struct  timeval{
	long  tv_sec；    /* секунды */
	long  tv_usec；/* микросекунды */
};
```

`tv_sec` - количество секунд от Epoch Time до создания `struct timeval`, `tv_usec` - количество микросекунд, то есть остаток после секунд. Например, когда `tv_sec` равно 1234567890, `tv_usec` равно 1234, текущее время отстоит от Epoch на 1234567890 секунд и 1234 микросекунды.

```c
struct  timezone{
    int tz_minuteswest;/* разница в минутах с Greenwich */
    int tz_dsttime;    /* тип коррекции DST */
};
```

`tz_minuteswest` указывает разницу во времени между текущим часовым поясом системы и UTC в минутах. Например, для Пекина GMT+8, `tz_minuteswest` равно -480. `tz_dsttime` определяет летнее время (DST - Daylight Saving Time).

Получается функцией `int gettimeofday(struct timeval*tv, struct timezone *tz)`, в которой `tv` или `tz` могут быть NULL. Если NULL, соответствующая структура не возвращается. При успешном выполнении функция возвращает 0, при неудаче возвращает -1, код ошибки сохраняется в `errno`.

Пример:

```c
struct  timeval  tv;
gettimeofday(&tv, NULL);
```

#### 4. Структура struct tm

```c
 struct tm {
　　int tm_sec; /* секунды – диапазон [0,59] */
　　int tm_min; /* минуты - диапазон [0,59] */
　　int tm_hour; /* часы - диапазон [0,23] */
　　int tm_mday; /* день месяца - диапазон [1,31] */
　　int tm_mon; /* месяц (начиная с января, 0 представляет январь) - диапазон [0,11] */
　　int tm_year; /* год, значение начинается с 1900 */
　　int tm_wday; /* день недели – диапазон [0,6], где 0 - воскресенье, 1 - понедельник и т.д. */
　　int tm_yday; /* дней с начала года (с 1 января) – диапазон [0,365], где 0 - 1 января, 1 - 2 января и т.д. */
　　int tm_isdst; /* индикатор летнего времени, положительный при летнем времени, 0 - нет летнего времени, отрицательный - неизвестно */
};
	int   tm_sec представляет текущие секунды, нормальный диапазон 0-59
	int   tm_min представляет текущие минуты, диапазон 0-59
	int   tm_hour часы с полуночи, диапазон 0-23
	int   tm_mday день текущего месяца, диапазон 01-31
	int   tm_mon представляет текущий месяц, начиная с января, диапазон 0-11
	int   tm_year лет с 1900 года
	int   tm_wday дней недели, начиная с понедельника, диапазон 0-6
	int   tm_yday дней с 1 января текущего года, диапазон 0-365
	int   tm_isdst флаг летнего времени
```

Получается функцией `struct tm* gmtime(const time_t*timep)`, которая преобразует информацию из типа данных `time_t`, на который указывает параметр `timep`, в представление времени и даты реального мира, затем возвращает результат через указатель на структуру `tm`.

Пример:

```c
struct tm* tm = NULL;
time_t t = time(NULL);
tm = gmtime(&t);
```

### 10.3.2 Функции для работы со временем

#### 1. Функция форматирования времени

Прототип функции `strftime()`: `size_t strftime(char *str, size_t max, char *fmt, struct tm *tp);` Функция распознает набор команд форматирования, начинающихся с процента (%), формат определяется `fmt`. Можно использовать функцию `strftime` для преобразования формата времени в нужный (результат выводится как строка), `strftime` похожа на `sprintf`.

`str` - возвращаемая строка времени

`count` - максимальное количество байтов для записи

`format` - строка формата состоит из нуля или более преобразователей и обычных символов (кроме %)

`tm` - входное время

Команды форматирования чувствительны к регистру:

```c
%a сокращенное название дня недели
%A полное название дня недели
%b сокращенное название месяца
%B полное название месяца
%c стандартная строка даты и времени
%C последние две цифры года
%d день месяца в десятичном формате
%D месяц/день/год
%e день месяца в двухсимвольном поле в десятичном формате
%F год-месяц-день
%g последние две цифры года, использует год на основе недель
%G год, использует год на основе недель
%h сокращенное название месяца
%H часы в 24-часовом формате
%I часы в 12-часовом формате
%j день года в десятичном формате
%m месяц в десятичном формате
%M минуты в десятичном формате
%n символ новой строки
%p локальный эквивалент AM или PM
%r время в 12-часовом формате
%R отображение часов и минут: hh:mm
%S секунды в десятичном формате
%t символ горизонтальной табуляции
%T отображение часов, минут и секунд: hh:mm:ss
%u день недели, понедельник - первый день (значения от 0 до 6, понедельник - 0)
%U неделя года, воскресенье как первый день (значения от 0 до 53)
%V неделя года, использует год на основе недель
%w день недели в десятичном формате (значения от 0 до 6, воскресенье - 0)
%W неделя года, понедельник как первый день (значения от 0 до 53)
%x стандартная строка даты
%X стандартная строка времени
%y год без века в десятичном формате (значения от 0 до 99)
%Y год с веком в десятичном формате
%z,%Z название часового пояса, если название недоступно, возвращает пустую строку
%% знак процента
```

Пример:

```c
time_t t = time(NULL);
struct tm *info;
info = gmtime(&t);
strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", info);
printf("форматированная дата и время: |%s|\n", buffer);
```

#### 2. Функция localtime

Прототип функции `localtime()`: `struct tm *localtime(const time_t *timer)` использует значение `timer` для заполнения структуры `tm`, значение `timer` разбирается в структуру `tm` и представляется в местном часовом поясе

Пример:

```c
time_t rawtime;
struct tm *info;
time(&rawtime);
info = localtime(&rawtime);
```

#### 3. Функция mktime

Прототип функции `mktime()`: `time_t mktime(struct tm *timeptr)` преобразует структуру, на которую указывает `timeptr`, в значение `time_t` согласно местному часовому поясу. Функция преобразует данные структуры `tm`, на которую указывает параметр `timeptr`, в количество секунд, прошедших с 00:00:00 1 января 1970 года по UTC. Функция возвращает значение `time_t`, соответствующее календарному времени, переданному в качестве параметра. При ошибке возвращается значение -1.

Пример:

```c
time_t rawtime;
struct tm *timeinfo;
int year, month, day;
/* Получить текущую информацию о времени и изменить введенные пользователем данные */
time(&rawtime);
timeinfo = localtime(&rawtime);
timeinfo->tm_year -= 1; // год назад от сегодня
rawtime = mktime(timeinfo);
```

#### 4. Функция asctime

Прототип функции `asctime()`: `char *asctime(const struct tm *timeptr);` Функция возвращает указатель на строку, представляющую дату и время структуры `struct timeptr`. Содержит информацию о дате и времени в читаемом формате `Www Mmm dd hh:mm:ss yyyy`, где `Www` - день недели, `Mmm` - месяц в буквенном формате, `dd` - день месяца, `hh:mm:ss` - время, `yyyy` - год.

Пример:

```c
struct tm t;
t.tm_sec    = 10;
t.tm_min    = 10;
t.tm_hour   = 6;
t.tm_mday   = 25;
t.tm_mon    = 2;
t.tm_year   = 89;
t.tm_wday   = 6;
puts(asctime(&t));
```

#### 5. Функция ctime

Прототип функции `ctime()`: `char *ctime(const time_t *timer);` Может преобразовать результат функции `time` в строку времени, возвращает строку, представляющую местное время, основанное на параметре `timer`. Возвращаемая строка имеет формат: `Www Mmm dd hh:mm:ss yyyy`, где `Www` - день недели, `Mmm` - месяц в буквенном формате, `dd` - день месяца, `hh:mm:ss` - время, `yyyy` - год. Вызов `ctime(t)` эквивалентен `asctime(localtime(t))`.

Пример:

```c
time_t curtime;
time(&curtime);
printf("текущее время = %s", ctime(&curtime));
```

## 10.4 Пример программирования с RTC

В среде встраиваемого Linux программирование RTC такое же, как в среде настольного Linux. В этой статье программирование выполняется в настольной среде Linux для реализации отображения времени, вычислений и других функций. Скомпилированная программа называется "mytime". После входа в программу используются различные команды для выполнения различных функций, основные команды приведены в таблице ниже:

| № | Команда | Функция                                      | Пример |
| - | ------- | -------------------------------------------- | ------ |
| 1 | p       | Отобразить текущее время в терминале         | p      |
| 2 | y       | Отобразить вчерашнюю дату в терминале        | y      |
| 3 | n       | Отобразить количество дней до Нового года    | n      |
| 4 | a       | Отобразить возраст на основе года рождения   | a 2001 |
| 5 | e       | Выйти из программы                           | e      |

В функции `main` сначала печатается руководство пользователя, затем в цикле принимаются введенные пользователем команды и в зависимости от команды вызываются соответствующие функции:

```c
32      // Печать руководства пользователя
33      printf( "\n\n"\
34            "Usage:\np\n"\
35            "y\n"\
36             "n\n"\
37             "a 2001\n"\
38             "e\n"\
39             "p:отобразить текущее время в терминале\ny:посмотреть вчерашнюю дату\nn:посмотреть количество дней до Нового года\n"\
40             "a:рассчитать возраст на основе введенного года рождения\ne:выйти из программы\n"\
41      );
42
43     // В основной программе циклически принимаются введенные команды, выполняя разные функции в зависимости от команды
44      while (1){
45              if (c !='\n')
46                printf("\nВведите команду:");
47              scanf("%c",&c);
48              switch(c){
49                      case 'p':// Отобразить текущее время в терминале
50                              displaydate();
51                              break;
52              		case 'y':// Отобразить вчерашнюю дату
53                              displayyesterday();
54                              break;
55                      case 'n':// Отобразить количество дней до Нового года
56                              displaynewyear();
57                              break;
58                      case 'a':// Рассчитать возраст на основе введенного года рождения
59                          	scanf("%d",&age);
60                              displayage(age);
61                              break;
62                      case 'e':// Выйти из программы
63                              exit(0);
64                              break;
65
66                      default : /* опционально */
67                              break;
68      	}
69      }
```

Реализация функции для отображения текущего времени в терминале:

```c
/**********************************************************
72  * Имя функции: displaydate
73  * Описание: Вывод текущей информации о времени в терминал
74  * Входные параметры: нет
75  * Выходные параметры: нет
76  * Возвращаемое значение: нет
77  * 2020/05/10         V1.0    yanxni            создано
78 ***********************************************************/
79 void displaydate(){
80      struct tm *ptr;
81      time_t lt;
82
83     /* Получить календарное время */
84     lt = time(NULL);
85
86     /* Преобразовать в местное время */
87     ptr = localtime(&lt);
88
89     /* Вывести в виде строки местного времени */
90     printf("%s\n",ctime(&lt));
91
92      /* Вывести в виде строки местного времени */
93     printf("%s\n",asctime(ptr));
94
95 }
```

Реализация функции для отображения вчерашней даты в терминале:

```c
/**********************************************************
97  * Имя функции: displayyesterday
98  * Описание: Вывод вчерашней даты в терминал
99  * Входные параметры: нет
100  * Выходные параметры: нет
101  * Возвращаемое значение: нет
102  * 2020/05/10         V1.0    yanxni            создано
103 ***********************************************************/
104 void displayyesterday(void){
105     struct tm *ptr;
106     time_t lt;
107
108     /* Получить календарное время */
109     lt = time(NULL);
110     lt -= 24*60*60;
111
112     /* Преобразовать в местное время */
113     ptr = localtime(&lt);
114
115     /* Вывести в виде строки местного времени */
116     printf("Вчера было %d год %d месяц %d день\n",ptr->tm_year + 1900,ptr->tm_mon + 1,ptr->tm_mday);
117 }
```

Реализация функции для отображения количества дней до Нового года в терминале:

```c
118 /**********************************************************
119  * Имя функции: displaynewyear
120  * Описание: Вывод количества дней до Нового года в терминал
121  * Входные параметры: нет
122  * Выходные параметры: нет
123  * Возвращаемое значение: нет
124  * 2020/05/10         V1.0    yanxni            создано
125 ***********************************************************/
126 void displaynewyear(void){
127     struct tm *ptr;
128     time_t lt,lt2;
129     int date;
130
131     /* Получить календарное время */
132     lt = time(NULL);
133
134     /* Преобразовать в местное время */
135     ptr = localtime(&lt);
136     /* Создать местное время Нового года */
137     ptr->tm_year += 1;
138     ptr->tm_mon = 0;
139     ptr->tm_mday =1;
140     ptr->tm_hour =0;
141     ptr->tm_min =0;
142     ptr->tm_sec =0;
143
144     lt2 = mktime(ptr);
145     date = (lt2-lt)/(24*60*60);
146
147     printf("До Нового года осталось %d дней\n",date);
148 }
```

Реализация функции для отображения возраста на основе введенного года рождения в терминале:

```c
/**********************************************************
151  * Имя функции: displayage
152  * Описание: Вывод возраста в терминал
153  * Входные параметры: год рождения
154  * Выходные параметры: нет
155  * Возвращаемое значение: нет
156  * 2020/05/10         V1.0    yanxni            создано
157 ***********************************************************/
158 void displayage(int year){
159     struct tm *ptr;
160     time_t lt;
161
162     /* Получить календарное время */
163     lt = time(NULL);
164
165     /* Преобразовать в местное время */
166     ptr = localtime(&lt);
167
168     printf("Ваш возраст: %d лет\n",ptr->tm_year + 1900 - year);
169 }
```
