#14 Программирование CAN

## 14.1 Введение в CAN

### 14.1.1 Что такое CAN?

CAN, сокращённо от "Controller Area Network", на русском языке означает сеть контроллеров, является одним из наиболее широко используемых полевых интерфейсов в мире.

Первоначально CAN была разработана для связи микроконтроллеров в автомобильной среде, для обмена информацией между различными электронными блоками управления ECU в автомобиле и образования сети электронного управления автомобилем. Например, в системе управления двигателем, контроллере коробки передач, приборной панели, электронной главной системе все встроены контроллеры CAN.

В одной сетевой топологии, сформированной шиной CAN, теоретически можно подключить неограниченное количество узлов. На практике количество узлов ограничено характеристиками электронного оборудования сетевого оборудования. Например, при использовании приёмопередатчика Philips P82C250 в одной сети допускается подключение 110 узлов.

CAN может обеспечить скорость передачи данных до 1 Мбит/с, что делает управление в реальном времени очень простым. Кроме того, встроенная в оборудование функция обнаружения ошибок также повышает устойчивость CAN к электромагнитным помехам.

### 14.1.2 Происхождение CAN

CAN впервые появилась в конце 1980-х годов в автомобильной промышленности и была впервые предложена немецкой компанией Bosch. В то время требования потребителей к функциям автомобилей становились всё выше, и большинство из этих функций реализовывались на основе электронных операций, что привело к всё более сложной связи между электронными устройствами и означало, что требуется больше соединительных сигнальных линий. Первоначальная цель введения шины CAN заключалась в решении задачи связи между большим количеством электронных блоков управления в современном автомобиле и уменьшении постоянно растущего числа сигнальных линий. Таким образом, была разработана одна сетевая шина, к которой могут быть подключены все периферийные устройства. В 1993 году CAN стала международным стандартом ISO11898 (для приложений высокой скорости) и ISO11519 (для приложений низкой скорости).

CAN — это многомастеровая последовательная шина связи. Основные требования стандартов проектирования — это высокая скорость передачи, высокая помехоустойчивость, а также способность обнаруживать возникающие ошибки. Когда расстояние передачи сигнала достигает 10 км, CAN может по-прежнему обеспечивать скорость передачи данных до 50 кбит/с.

Благодаря высокой производительности в реальном времени шины CAN она получила широкое применение в автомобильной промышленности, авиационной промышленности, промышленном управлении, защите безопасности и других областях.

### 14.1.3 Модель передачи CAN

Протокол связи CAN в основном описывает способ передачи информации между устройствами. Определение уровня CAN соответствует открытой модели системного взаимодействия (OSI). Каждый уровень взаимодействует с тем же уровнем на другом устройстве. Фактическое взаимодействие происходит между смежными уровнями на каждом устройстве, и устройства взаимодействуют только через физический носитель физического слоя модели. Спецификация CAN определяет два нижних уровня модели: уровень канала передачи данных и физический уровень. Протокол прикладного слоя может быть определён пользователем CAN как любой план, подходящий для конкретной отрасли. Стандартом, получившим широкое применение в областях промышленного управления и производства, является DeviceNet, разработанный для ПЛК и интеллектуальных датчиков. В автомобильной промышленности многие производители применяют свои собственные стандарты.

| Таблица модели OSI открытой системы взаимодействия | | |
| ------- | -------- | -------------------------------------------------- |
| **Последовательность** | **Уровень** | **Описание**                                           |
| 7        | Прикладной уровень    | Высший уровень. Используется для обмена информацией между пользователями, программным обеспечением, конечными точками сети. |
| 6        | Уровень представления    | Преобразование информации между двумя приложениями с разными форматами данных в общепонимаемый формат |
| 5        | Уровень сеанса    | Опирается на коммуникационные функции нижних уровней для эффективной передачи данных. |
| 4        | Транспортный уровень    | Управление передачей данных между двумя узлами связи. Операции включают переотправку данных, исправление ошибок данных |
| 3        | Сетевой уровень    | Определяет протоколы установления, поддержания и разрыва сетевых соединений. Например, маршрутизация и адресация |
| 2        | Уровень канала передачи данных | Определяет расположение и организацию битов данных, передаваемых на носителе. Например, проверка данных и структура кадра |
| 1        | Физический уровень    | Определяет физические характеристики среды связи. Например, характеристики электронов и интерпретация обмена сигналами |

Хотя протокол передачи CAN ссылается на семиуровневую модель OSI, в действительности протокол CAN определяет только два уровня — "физический уровень" и "уровень канала передачи данных". Таким образом, появилось несколько различных протоколов "прикладного уровня". Например, стандарт полевого интерфейса DeviceNet, используемый в технике автоматизации, CanOpen для промышленного управления, диагностический протокол OBD и UDS (унифицированный диагностический сервис, ISO14229) для легковых автомобилей, протокол CAN шины для грузовиков SAEJ1939.

| **Таблица CAN** | | |
| -------------- | ---------- | ------------------------------------------------------------ |
| **Последовательность**       | **Уровень**   | **Описание**                                                     |
| 7              | Прикладной уровень     | Основное определение слоя приложения CAN.                                          |
| 2              | Уровень канала передачи данных | Уровень канала передачи данных разделён на подслой логической связи LLC и подслой управления доступом к среде MAC.<br>MAC подслой — это ядро протокола CAN. Он передаёт полученные сообщения подслою LLC и получает сообщения из подслоя LLC. Подслой MAC отвечает за разделение сообщений, арбитраж, подтверждение, обнаружение ошибок и синхронизацию. Подслой MAC также называется управляющей сущностью определения отказа Подслой LLC включает фильтрацию сообщений, уведомление о перегрузке и управление восстановлением.<br>LLC = Логическое управление ссылкой   MAC = Управление доступом к среде |
| 1              | Физический уровень     | Физический уровень, физический кодирующий подслой PCS. Этот слой определяет, как сигналы фактически передаются, поэтому включает время бита, кодирование бита, синхронизацию. |

### 14.1.4 Топология сети CAN

CAN шина является распределённой управляющей шиной.

Как сеть контроллеров, CAN шина, как и обычная сеть Ethernet, состоит из множества узлов CAN.

Её сетевая топология показана на рисунке ниже:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0001.png)

Каждый узел сети CAN очень простой, состоит из микроконтроллера (MCU), контроллера CAN и приёмопередатчика CAN, а затем подключается к сети CAN с помощью витой пары.

### 14.1.5 Физические характеристики CAN

Шина CAN соответствует международному стандарту ISO11898, такому как ISO11898-1, ISO11898-2, ISO11898-3, ISO11898-4.

| Последовательность | Стандарт       | Описание                     |
| ---- | ---------- | ------------------------ |
| 1    | ISO11898-1 | Сигналы физического уровня и уровня канала   |
| 2    | ISO11898-2 | Блок доступа высокой скорости             |
| 3    | ISO11898-3 | Блок доступа низкой скорости, отказоустойчивый         |
| 4    | ISO11898-4 | Синхронизация по времени                       |
| 5    | ISO11898-5 | Блок доступа с низким энергопотреблением         |
| 6    | ISO11898-6 | Блок доступа высокой скорости с выборочным пробуждением |

CAN может использовать различные физические носители, такие как витая пара, оптоволокно и т.д. Наиболее часто используется витая пара.

Сигнал передаётся с использованием дифференциального напряжения. Две сигнальные линии называются "CAN_H" и "CAN_L".

В статическом состоянии CAN_H и CAN_L оба имеют напряжение около 2,5 В, это состояние представляется как логическая "1", также может быть названо "рецессивным".

Использование CAN_H выше CAN_L представляет логический "0", называемый "доминирующим", в это время обычно значения напряжения: CAN_H = 3,5 В и CAN_L = 1,5 В.

В настоящее время часто используемые типы приёмопередатчиков CAN:

| Последовательность | Модель      | Описание            |
| ---- | --------- | --------------- |
| 1    | PCA82C250 | Приёмопередатчик CAN высокой скорости |
| 2    | PCA82C251 | Приёмопередатчик CAN высокой скорости |
| 3    | PCA82C252 | Отказоустойчивый приёмопередатчик CAN |
| 4    | TJA1040   | Приёмопередатчик CAN высокой скорости |
| 5    | TJA1041   | Приёмопередатчик CAN высокой скорости |
| 6    | TJA1042   | Приёмопередатчик CAN высокой скорости |
| 7    | TJA1043   | Приёмопередатчик CAN высокой скорости |
| 8    | TJA1050   | Приёмопередатчик CAN высокой скорости |
| 9    | TJA1053   | Отказоустойчивый приёмопередатчик CAN |
| 10   | TJA1054   | Отказоустойчивый приёмопередатчик CAN |

В настоящее время часто используемые типы контроллеров CAN:

| Последовательность | Модель          | Описание                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| 1    | SJA1000       | Независимый контроллер CAN                                                |
| 2    | MCU контроллер внутри | В настоящее время на рынке многие микроконтроллеры, такие как серия STM32, серия S32K, серия IMX6 и т.д., имеют встроенный контроллер CAN. |

### 14.1.6 Кадр сообщения CAN

#### 14.1.6.1 Формат сообщения CAN

Стандартная длина идентификатора CAN составляет 11 бит, а расширённая длина идентификатора CAN может достигать 29 бит.

Версия 2.0A протокола CAN требует, чтобы контроллер CAN имел 11-битный идентификатор.

В то же время, в версии 2.0B указано, что длина идентификатора контроллера CAN может быть 11 бит или 29 бит.

Контроллер CAN, соответствующий протоколу CAN2.0B, может отправлять и принимать кадры стандартного формата с 11-битным идентификатором или кадры расширённого формата с 29-битным идентификатором.

| **Сравнение стандартного и расширённого кадра** | | |
| --------------------- | ----------- | --------------------- |
| **Формат кадра**            | **Стандартный кадр**  | **Расширённый кадр**            |
| Спецификация                  | CAN2.0A     | CAN2.0B               |
| Длина идентификатора CAN (ID)  | 11 бит     | 29 бит               |
| Диапазон идентификатора CAN (ID)  | 0x000~0x7FF | 0x00000000~0x1FFFFFFF |

#### 14.1.6.2 Тип кадра сообщения CAN

Тип сообщения CAN разделён на 5 типов кадров:

Кадр данных: в основном используется для отправки данных с отправителя на получателя;

Кадр дистанционного управления: в основном используется для запроса данных от получателя к отправителю с тем же ID;

Кадр ошибки: в основном используется для уведомления других узлов об ошибке при обнаружении ошибки.

Кадр перегрузки: в основном используется для уведомления других узлов, которые ещё не готовы к приёму;

Кадр промежутка: в основном используется для разделения кадра данных и кадра дистанционного управления от предыдущего кадра.

Среди них кадр данных — это наиболее часто используемый тип кадра. Здесь основное внимание уделяется кадру данных ниже.

Кадр данных выглядит на рисунке ниже:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0002.jpeg)

Как показано на рисунке выше, кадр данных включает:

(1) Начало кадра. Сегмент, обозначающий начало кадра данных.

(2) Сегмент арбитража. Сегмент, обозначающий приоритет кадра.

(3) Сегмент управления. Сегмент, обозначающий количество байтов данных и зарезервированные биты.

(4) Сегмент данных. Содержание данных, один кадр может передавать 0-8 байтов данных.

(5) Сегмент CRC. Сегмент для проверки ошибок передачи кадра.

(6) Сегмент ACK. Сегмент, обозначающий подтверждение нормального приёма.

(7) Конец кадра. Сегмент, обозначающий конец кадра данных.

Для подробного введения см. "CAN2.0A" и "CAN2.0B".

Мы в основном сосредоточиваемся на нескольких сегментах, которые нам нужны для программирования:

ID: идентификатор сообщения CAN;

IDE: 0 — стандартный кадр, 1 — расширённый кадр;

RTR: 0 — кадр данных, 1 — кадр дистанционного управления;

DLC: длина данных сообщения CAN, диапазон 0-8 байтов;

Data: данные, 0-8 байтов;

## 14.2 Создание фреймворка программирования CAN

Когда мы изучаем программирование прикладного уровня, чтобы облегчить портируемость и универсальность фреймворка программирования CAN в будущем, мы создаём абстрактный фреймворк программирования CAN. Этот фреймворк может быть применён как к программированию приложений микроконтроллеров, так и к программированию приложений Linux.

Таким образом, на основе универсальных свойств программирования шины CAN, мы абстрагируем следующие свойства:

| Свойство          | Описание свойства                                                     | Примечание |
| ------------- | ------------------------------------------------------------ | ---- |
| Номер порта CAN     | Описываем порт CAN, такой как CAN1, CAN2, CAN3, связанный с конкретным аппаратным оборудованием. |      |
| Конфигурация приёмопередатчика CAN | Описываем настройку режима приёмопередатчика CAN. Режимы приёмопередатчика включают Normal, Stanby, Sleep, ListenOnly и т.д. Приёмопередатчик, используемый в этой главе, использует конфигурацию оборудования по умолчанию, поэтому конфигурация не требуется. |      |
| Конфигурация контроллера CAN | Описываем конфигурацию приёмопередатчика CAN, такую как конфигурация скорости передачи CAN, установка скорости дискретизации, установка фильтра и т.д. |      |
| Конфигурация прерывания CAN   | Описываем конфигурацию функции обработки прерывания приёма CAN |      |
| Чтение сообщения CAN   | Описываем реализацию чтения сообщения CAN |      |
| Отправка сообщения CAN   | Описываем реализацию отправки сообщения CAN |      |

На основе свойств, описанных в таблице выше, создаём фреймворк программирования CAN следующим образом:

```c
typedef struct _CAN_COMM_STRUCT
{
    /* Имя аппаратной части CAN */
    char name[10];
    /* Номер порта CAN, на голой машине — номер порта; в приложении Linux — сокет */
    int  can_port;
    /* Функция конфигурации контроллера CAN, возвращает номер порта, присвоенный can_port */
    int  (*can_set_controller)( void );
    /* Создание прерывания интерфейса CAN, в Linux соответствует созданию потока приёма */
    void (*can_set_interrput)( int can_port , pCanInterrupt callback );
    /* Интерфейс чтения сообщения CAN */
    void (*can_read)( int can_port , CanRxMsg* recv_msg);
    /* Интерфейс отправки сообщения CAN*/
    void (*can_write)( int can_port , CanTxMsg send_msg);
}CAN_COMM_STRUCT, *pCAN_COMM_STRUCT;
```

Этот фреймворк может быть аналогично применён на микроконтроллерах и может быть использован в программировании приложений Linux socketcan.

## 14.3 Программирование CAN приложений STM32

В этом разделе основное внимание уделяется использованию фреймворка программирования приложений из раздела 14.2 для проверки осуществимости фреймворка на микроконтроллере с базовым примером отправки и приёма;

### 14.3.1 Схема интерфейса CAN STM32

Как показано на рисунке ниже, это минимальная система STM32 и схема интерфейса приёмопередатчика CAN TJA1050, используемые в примере STM32 этой главы.

![Рис. 14.3.1-1 STM32F407 минимальная система](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0003.png)

![Рис. 14.3.1-1 Схема интерфейса приёмопередатчика CAN TJA1050](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0004.png)

### 14.3.2 Шаги программирования приложения CAN STM32

Ниже мы реализуем программирование приложения CAN на основе STM32 шаг за шагом согласно фреймворку связи CAN.

Шаги программирования приложения CAN STM32 выглядят следующим образом:

#### **14.3.2.1** **Подготовка шаблона проекта STM32**

Пожалуйста, обратитесь к примеру кода в главе 14 "01_stm32f407_can";

Используемая среда разработки: MDK 5.24.

После открытия проекта MDK, как показано ниже:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0005.png)

На рисунке выше каталоги CMSIS, STM32F407_LIB, main — это базовый фреймворк для запуска STM32.

Каталог app_can содержит файлы, необходимые для программирования приложения CAN.

#### **14.3.2.2** **Написание функций реализации абстрактного фреймворка CAN**

**(1) Определение номера порта CAN**

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" файл "can_controller.h".

В основном определяем, в зависимости от количества маршрутов CAN на аппаратной части STM32, — как CAN_PORTCAN1, CAN_PORT_CAN2 и т.д. Из раздела "14.3.1 Схема интерфейса CAN STM32" мы знаем, что в настоящее время используется CAN1.

```c
25 /* Определение номера порта CAN*/
26 enum
27 {
28     CAN_PORT_NONE = 0,
29     CAN_PORT_CAN1,
30     CAN_PORT_CAN2,
31     CAN_PORT_MAX
32 };
```

**(2) Конфигурация контроллера CAN**

Конфигурация контроллера CAN состоит из 3 частей: конфигурация GPIO (выводы CAN_TX, CAN_RX), конфигурация скорости передачи CAN, конфигурация фильтра CAN.

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" функцию int CAN_Set_Controller( void ) в файле "can_controller.c".

**A. Конфигурация GPIO (выводы CAN_TX, CAN_RX)**

Код конфигурации GPIO выглядит следующим образом:

```c
96     /*************************************************************/
97     /* Конфигурация GPIO, связанная с CAN: CAN_TX, CAN_RX*/
98
99     /* Включить часы GPIO*/
100     RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
101     /* Инициализировать конфигурацию вывода*/
102     GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_0 ;
103     GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
104     GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_50MHz;
105     GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
106     GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;
107     GPIO_Init(GPIOD, &GPIO_InitStructure);
108
109     GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_1;
110     GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
111     GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_50MHz;
112     GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
113     GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;
114     GPIO_Init(GPIOD, &GPIO_InitStructure);
115     /* Установите GPIO в режим переназначения CAN*/
116     GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_CAN1);
117     GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_CAN1);
```

**B. Конфигурация скорости передачи и режима работы**

Согласно коду ниже, включите периферию CAN, установите режим работы CAN на Normal, установите скорость передачи на 500 кбит/с.

```c
119     /*************************************************************/
120     /* Конфигурация контроллера CAN, в этом случае скорость передачи, скорость дискретизации и т.д.*/
121
122     /* Включить часы CAN */
123     RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
124
125     /* Инициализировать режим работы контроллера CAN*/
126     CAN_DeInit(CAN1);
127     CAN_StructInit(&CAN_InitStructure);
128     CAN_InitStructure.CAN_TTCM = DISABLE;
129     CAN_InitStructure.CAN_ABOM = DISABLE;
130     CAN_InitStructure.CAN_AWUM = DISABLE;
131     CAN_InitStructure.CAN_NART = DISABLE;
132     CAN_InitStructure.CAN_RFLM = DISABLE;
133     CAN_InitStructure.CAN_TXFP = DISABLE;
134     CAN_InitStructure.CAN_Mode = CAN_Mode_Normal; // Режим работы CAN
135
136     /* Инициализировать скорость передачи CAN */
137     CAN_Baud_Process(500,&CAN_InitStructure);
138     CAN_Init(CAN1, &CAN_InitStructure);
```

Функция конфигурации скорости передачи — это пользовательская функция. Здесь вам не нужно понимать, вам просто нужно знать, что это конфигурация скорости передачи. Если вам нужно использовать код этой главы, вы можете просмотреть конкретный исходный код проекта.

**C. Конфигурация фильтра CAN**

Код конфигурации фильтра выглядит следующим образом:

```c
141     /*************************************************************/
142     /* Инициализировать фильтр CAN */
143     CAN_FilterInitStructure.CAN_FilterNumber = 0;                       /* Номер фильтра CAN1 от 0 до 13 */
144     CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;     /* Режим фильтра маскирования */
145     CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
146     CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
147     CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
148     CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;      /* Не маскировать никакие ID */
149     CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;           /* Не маскировать никакие ID */
150     CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
151
152     CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
153     CAN_FilterInit(&CAN_FilterInitStructure);
154
155     /*************************************************************/
156     /* После настройки CAN верните номер порта CAN, который был установлен. Здесь в основном аналогично сокету в Linux socketcan */
```

Здесь мы устанавливаем фильтр, чтобы не маскировать никакие ID сообщений. Это только для понимания процесса на микроконтроллере.

**(3) Конфигурация прерывания приёма CAN**

Шина CAN поддерживает прерывания передачи и приёма. Здесь используется только прерывание приёма.

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" функцию void CAN_Set_Interrupt(int can_port, pCanInterrupt callback) в файле "can_controller.c".

Код конфигурации прерывания CAN выглядит следующим образом:

```c
163 /**********************************************************************
164 * Имя функции: void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
165 * Описание функции: Включить обработку прерывания CAN и передать функцию обратного вызова приложения для обработки функциональности приложения в слое
166 * Входной параметр: can_port, номер порта
167 *            callback: функция обратного вызова для конкретной обработки функциональности приложения в прерывании
168 * Выходной параметр: нет
169 * Возвращаемое значение: нет
170 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
171 * -----------------------------------------------
172 * 2020/05/13         V1.0             bert            создание
173 ***********************************************************************/
174 void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
175 {
176     NVIC_InitTypeDef NVIC_InitStructure;
177
178     /* Настроить прерывание в зависимости от номера порта CAN */
179     switch( can_port )
180     {
181         case CAN_PORT_CAN1:
182         {
183             /* Инициализировать функцию обратного вызова интерфейса */
184             if ( NULL != callback )
185             {
186                 g_pCanInterrupt = callback;
187             }
188
189             /* Использовать прерывание CAN0_RX. В Linux socketcan аналогично созданию потока приёма */
190             NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX0_IRQn;
191             NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
192             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
193             NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
194             NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
195             NVIC_Init(&NVIC_InitStructure);
196             CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
197         }
198         break;
199
200         default:
201             break;
202
203     }
204     return ;
205 }
```

Функция обработки прерывания приёма CAN выглядит следующим образом:

```c
275 /**********************************************************************
276 * Имя функции: void CAN1_RX0_IRQHandler(void)
277 * Описание функции: Функция обработки прерывания приёма CAN
278 * Входной параметр: нет
279 * Выходной параметр: нет
280 * Возвращаемое значение: нет
281 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
282 * -----------------------------------------------
283 * 2020/05/13         V1.0             bert            создание
284 ***********************************************************************/
285 void CAN1_RX0_IRQHandler(void)
286 {
287     /* Если функция обратного вызова существует, выполнить функцию обратного вызова */
288     if( g_pCanInterrupt != NULL)
289     {
290         g_pCanInterrupt();
291     }
292
293     /* Очистить ожидающее прерывание */
294     CAN_ClearITPendingBit(CAN1,CAN_IT_FMP0);
295 }
```

Прерывание CAN передаёт функциональный код, необходимый слою приложения, через функцию обратного вызова g_pCanInterrupt(), слоизируя код приложения в слой приложения, что является универсальным интерфейсом части драйвера.

**(4) Функция чтения сообщения CAN**

Когда генерируется прерывание приёма CAN, прочитайте принятое сообщение CAN из FIFO через функцию чтения сообщения CAN.

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" функцию void CAN_Read(int can_port, CanRxMsg* recv_msg) в файле "can_controller.c".

Функция чтения сообщения CAN выглядит следующим образом:

```c
208 /**********************************************************************
209 * Имя функции: void CAN_Read(int can_port, CanRxMsg* recv_msg)
210 * Описание функции: Прочитайте регистр приёма CAN и извлеките принятое сообщение
211 * Входной параметр: can_port, номер порта
212 * Выходной параметр: recv_msg: принятое сообщение
213 * Возвращаемое значение: нет
214 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
215 * -----------------------------------------------
216 * 2020/05/13         V1.0             bert            создание
217 ***********************************************************************/
218 void CAN_Read(int can_port, CanRxMsg* recv_msg)
219 {
220     switch( can_port )
221     {
222         case CAN_PORT_CAN1:
223         {
224             /* Прочитайте сообщение CAN из FIFO */
225             CAN_Receive(CAN1,CAN_FIFO0, recv_msg);
226         }
227         break;
228
229         default:
230             break;
231     }
232     return ;
233 }
```

**(5) Функция отправки сообщения CAN**

Когда необходимо отправить сообщение CAN, заполните почтовый ящик отправки CAN и запустите отправку сообщения.

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" функцию void CAN_Write(int can_port, CanTxMsg send_msg) в файле "can_controller.c".

Функция чтения сообщения CAN выглядит следующим образом:

```c
235 /**********************************************************************
236 * Имя функции: void CAN_Write(int can_port, CanTxMsg send_msg)
237 * Описание функции: Интерфейс отправки сообщения CAN, вызвать регистр отправки для отправки сообщения
238 * Входной параметр: can_port, номер порта
239 * Выходной параметр: send_msg: отправляемое сообщение
240 * Возвращаемое значение: нет
241 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
242 * -----------------------------------------------
243 * 2020/05/13         V1.0             bert            создание
244 ***********************************************************************/
245 void CAN_Write(int can_port, CanTxMsg send_msg)
246 {
246 	unsigned char i;
247 	uint8_t transmit_mailbox = 0;
248 	CanTxMsg TxMessage;
249
250 	switch( can_port )
251 	{
252 		case CAN_PORT_CAN1:
253 		{
254 			TxMessage.StdId = send_msg.StdId;     // Стандартный идентификатор 0x000~0x7FF
255 			TxMessage.ExtId = 0x0000;             // Расширённый идентификатор 0x0000
256 			TxMessage.IDE   = CAN_ID_STD;         // Использовать стандартный идентификатор
257 			TxMessage.RTR   = CAN_RTR_DATA;       // Установить кадр данных
258 			TxMessage.DLC   = send_msg.DLC;       // Длина данных, спецификация CAN определяет максимальную длину данных 8 байтов
259
260 			for(i=0; i<TxMessage.DLC; i++)
261 			{
262 				TxMessage.Data[i] = send_msg.Data[i];
263 			}
264 			transmit_mailbox = CAN_Transmit(CAN1,&TxMessage);  /* Возвращает номер почтового ящика этого запроса отправки 0, 1, 2 или нет почтового ящика для отправки no_box */
265 		}
266 		break;
267
268 		default:
269 			break;
270 	}
271 	return ;
272 }
```

**(6) Инициализация структуры абстрактного фреймворка CAN**

Определить экземпляр структуры связи can1_controller CAN_COMM_STRUCT;

Использовать функции, реализованные на этапах (1)~(5), инициализировать can1_controller и сформировать точку соединения, связанную с прикладным слоем.

```c
298 /**********************************************************************
299 * Имя: can1_controller
300 * Описание функции: Инициализация структуры CAN1
301 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
302 * -----------------------------------------------
303 * 2020/05/13         V1.0             bert            создание
304 ***********************************************************************/
305 CAN_COMM_STRUCT can1_controller = {
306     .name                   = "can0",
307     .can_port               = CAN_PORT_CAN1,
307     .can_set_controller     = CAN_Set_Controller,
309     .can_set_interrput      = CAN_Set_Interrupt,
310     .can_read               = CAN_Read,
311     .can_write              = CAN_Write,
312 };
```

#### **14.3.2.3** **Написание кода приложения CAN**

На основе рассмотренного в 14.3.2.2 уже были реализованы конкретные операции с аппаратным обеспечением CAN и уже реализована и реализована структура программирования CAN.

Однако мы пока не связались с прикладным слоем. Прикладной слой не знает, какой интерфейс вызывать.

**(1) Регистрация экземпляра приложения CAN**

Напишите функцию регистрации общего экземпляра в прикладном слое.

Посмотрите в примере кода главы 14 "01_stm32f407_can_addline" функцию int register_can_controller(const pCAN_COMM_STRUCT p_can_controller) в файле "app_can.c".

Реализация кода выглядит следующим образом:

```c
62 /**********************************************************************
63 * Имя функции: int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
64 * Описание функции: Регистрация структуры CAN1 на уровне приложения
65 * Входной параметр: p_can_controller, абстрактная структура контроллера CAN
66 * Выходной параметр: нет
67 * Возвращаемое значение: нет
68 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
69 * -----------------------------------------------
70 * 2020/05/13         V1.0             bert            создание
71 ***********************************************************************/
72 int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
73 {
74     /* Определить, что передаваемый p_can_controller не равен нулю, цель — подтвердить, что эта структура является объектом*/
75     if( p_can_controller != NULL )
76     {
77         /* Назначить передаваемый параметр p_can_controller структуре приложения gCAN_COMM_STRUCT */
78
79         /* Номер порта, аналогия socketcan сокет*/
80         gCAN_COMM_STRUCT.can_port              = p_can_controller->can_port;
81         /* Функция конфигурации контроллера CAN*/
82         gCAN_COMM_STRUCT.can_set_controller    = p_can_controller->can_set_controller;
83         /* Конфигурация прерывания CAN*/
84         gCAN_COMM_STRUCT.can_set_interrput     = p_can_controller->can_set_interrput;
85         /* Функция чтения сообщения CAN*/
86         gCAN_COMM_STRUCT.can_read              = p_can_controller->can_read;
87         /* Функция отправки сообщения CAN*/
88         gCAN_COMM_STRUCT.can_write             = p_can_controller->can_write;
89         return 1;
90     }
91      return 0;
92 }
```

Затем вызовите register_can_controller( &can1_controller ); для регистрации экземпляра can1_controller в структуре приложения 4 static CAN_COMM_STRUCT gCAN_COMM_STRUCT;

После этого прикладному слою нужно только использовать свой собственный экземпляр gCAN_COMM_STRUCT приложения для работы с функциональностью связи CAN.

```c
315 /**********************************************************************
316 * Имя функции: void CAN1_contoller_add(void)
317 * Описание функции: Интерфейс регистрации структуры CAN, вызывается приложением перед использованием can1_controller
318 * Входной параметр: нет
319 * Выходной параметр: нет
320 * Возвращаемое значение: нет
321 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
322 * -----------------------------------------------
323 * 2020/05/13         V1.0             bert            создание
324 ***********************************************************************/
325 void CAN1_contoller_add(void)
326 {
327     /* Передать can1_controller на уровень приложения*/
328     register_can_controller( &can1_controller );
329 }
```

**(2) Инициализация приложения CAN**

Код инициализации приложения CAN выглядит следующим образом;

```c
94 /**********************************************************************
95 * Имя функции: void app_can_init(void)
96 * Описание функции: Инициализация приложения CAN
97 * Входной параметр: нет
98 * Выходной параметр: нет
99 * Возвращаемое значение: нет
100 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
101 * -----------------------------------------------
102 * 2020/05/13         V1.0             bert            создание
103 ***********************************************************************/
104 void app_can_init(void)
105 {
106     /**
107     * Регистрация структуры CAN1 на уровне приложения
108     */
109     CAN1_contoller_add();
110
111     /*
112     * Вызвать can_set_controller для конфигурации контроллера CAN,
113     * возвращает can_port, аналогия socketcan в Linux сокет, на микроконтроллере как пользовательский канал CAN
114     */
115     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
116     /**
117     * Вызвать can_set_interrput для конфигурации прерывания приёма CAN, аналогия socketcan в Linux потоку приёма
118     */
119     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, CAN_RX_IRQHandler_Callback );
120 }
```

**(3) Разработка простой функции периодической отправки сообщения**

Реализация кода функции периодической отправки сообщения CAN выглядит следующим образом:

```c
123 /**********************************************************************
124 * Имя функции: void app_can_tx_test(void)
125 * Описание функции: Функция отправки сообщения на уровне приложения CAN, используемая для тестирования периодической отправки сообщения
126 * Входной параметр: нет
127 * Выходной параметр: нет
128 * Возвращаемое значение: нет
129 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
130 * -----------------------------------------------
131 * 2020/05/13         V1.0             bert            создание
132 ***********************************************************************/
133 void app_can_tx_test(void)
134 {
134 	// Основана на 10 мс, запуск тестовой программы CAN
135
136 	unsigned char i=0;
137
138 	/* Определение отправляемого сообщения */
139 	CanTxMsg TxMessage;
140
141 	/* Используется один байт в отправляемом сообщении в качестве счётчика */
142 	static unsigned char tx_counter = 0;
143
144 	/* На основе 10 мс установите период выполнения следующего кода функции обработки через счётчик timer на 1 секунду*/
145 	static unsigned int timer =0;
146 	if(timer++>100)
147 	{
147 		timer = 0;
148 	}
149 	else
150 	{
151 		return ;
152 	}
153
154 	/* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
155 	TxMessage.StdId = TX_CAN_ID;          /* Стандартный идентификатор 0x000~0x7FF */
156 	TxMessage.ExtId = 0x0000;             /* Расширённый идентификатор 0x0000 */
157 	TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
158 	TxMessage.RTR   = CAN_RTR_DATA;       /* Установить кадр данных  */
159 	TxMessage.DLC   = 8;                  /* Длина данных, спецификация CAN определяет максимальную длину данных 8 байтов */
160
161 	/* Заполнение данных, этот раздел может быть заполнен в соответствии с фактическим приложением */
162 	TxMessage.Data[0] = tx_counter++;       /* Используется для идентификации счётчика отправляемого сообщения */
163 	for(i=1; i<TxMessage.DLC; i++)
164 	{
164 		TxMessage.Data[i] = i;
165 	}
166
167 	/*  Вызвать can_write для отправки сообщения CAN */
168 	gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
169
170 }
```

**(4) Разработка простой функции приёма сообщения**

```c
220 /**********************************************************************
221 * Имя функции: void CAN_RX_IRQHandler_Callback(void)
222 * Описание функции: Функция обработки прерывания приёма CAN1; в Linux можно использовать поток или таймер для чтения данных CAN по аналогии
223 * Входной параметр: нет
224 * Выходной параметр: нет
225 * Возвращаемое значение: нет
226 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
227 * -----------------------------------------------
228 * 2020/05/13         V1.0             bert            создание
229 ***********************************************************************/
230 void CAN_RX_IRQHandler_Callback(void)
231 {
231 	/* Определение принимаемого сообщения */
232 	CanRxMsg RxMessage;
233
234 	/* Очистка принимаемого сообщения */
235 	memset( &RxMessage, 0, sizeof(CanRxMsg) );
236
237 	/* Прочитайте уже принятое сообщение из регистра через интерфейс can_read */
238 	gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);
239
240 	/* Скопируйте прочитанное сообщение CAN в глобальную структуру сообщения g_CAN1_Rx_Message */
241 	memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
242
243 	/* Установить флаг завершения текущего приёма, определить, что текущий ID принятого сообщения RX_CAN_ID, затем установить g_CAN1_Rx_Flag=1*/
244 	if( g_CAN1_Rx_Message.StdId == RX_CAN_ID )
245 	{
245 		g_CAN1_Rx_Flag = 1;
246 	}
247 }
```

```c
176 /**********************************************************************
177 * Имя функции: void app_can_rx_test(void)
178 * Описание функции: Функция обработки принятого сообщения на уровне приложения CAN, используется для обработки сообщения, полученного в функции прерывания
179 * Входной параметр: нет
180 * Выходной параметр: нет
181 * Возвращаемое значение: нет
182 * Дата изменения             Номер версии        Человек, изменивший        Содержание изменения
183 * -----------------------------------------------
184 * 2020/05/13         V1.0             bert            создание
185 ***********************************************************************/
186 void app_can_rx_test(void)
187 {
187 	unsigned char i=0;
188
189 	/* Определение отправляемого сообщения */
190 	CanTxMsg TxMessage;
191
191 	/* Используется один байт в отправляемом сообщении в качестве счётчика */
192 	static unsigned char rx_counter = 0;
193
194
195 	if( g_CAN1_Rx_Flag == 1)
196 	{
196 		g_CAN1_Rx_Flag = 0;
197
198 		/* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
199 		TxMessage.StdId = RX_TO_TX_CAN_ID;    /* Стандартный идентификатор 0x000~0x7FF */
200 		TxMessage.ExtId = 0x0000;             /* Расширённый идентификатор 0x0000 */
201 		TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
202 		TxMessage.RTR   = CAN_RTR_DATA;       /* Установить кадр данных  */
203 		TxMessage.DLC   = 8;                  /* Длина данных, спецификация CAN определяет максимальную длину данных 8 байтов */
204
205 		/* Заполнение данных, этот раздел может быть заполнен в соответствии с фактическим приложением */
206 		TxMessage.Data[0] = rx_counter++;      /* Используется для идентификации счётчика отправляемого сообщения */
207 		for(i=1; i<TxMessage.DLC; i++)
208 		{
208 			TxMessage.Data[i] = g_CAN1_Rx_Message.Data[i];
209 		}
210
211 		/*  Вызвать can_write для отправки сообщения CAN */
212 		gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
213 	}
214 }
```

#### **14.3.2.4 Тестирование примера CAN STM32**

После завершения разработки кода в предыдущих нескольких разделах мы проведём тест;

Инструмент тестирования, используемый здесь: Valuecan3 (блок протокола CAN) от Intrepid, Vehicle Vspy3 (программное обеспечение сбоку компьютера).

Вы также можете купить дешёвый инструмент преобразования USB в CAN на Taobao.

Шаги тестирования выглядят следующим образом:

Шаг 1: Загрузите завершённую программу тестирования STM32 CAN на фактическую отладочную плату;

Шаг 2: Используйте программное обеспечение Vehicle Vspy3 для отправки сообщения с ID 0X201;

Шаг 3: Наблюдайте за результатом, отображаемым программным обеспечением тестирования CAN:

Сообщение с ID 0x101 отправляется в соответствии с периодом 1 секунда, как показано на рисунке 14.3.2.4-1.

Сообщение с ID 0x201 отправляется Vehicle Spy3 в соответствии с периодом 500 мс в отладочную плату STM32, как показано на рисунке 14.3.2.4-1

Сообщение с ID 0x301 — это сообщение, которое отправляется после получения сообщения с ID 0x201, как показано на рисунке 14.3.2.4-2.

![Рисунок 14.3.2.4-1 Просмотр результатов отправки сообщения](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0006.png)

![Рисунок 14.3.2.4-2 Просмотр ситуации приёма сообщения](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0007.png)

## **14.4 Базовое программирование приложения Linux socketcan**

### **14.4.1 Обзор socketcan**

Socketcan — это метод реализации протокола CAN (Controller Area Network) в Linux. CAN — это сетевая технология, которая широко используется во всём мире в автоматическом управлении, встроенных устройствах и автомобильной промышленности. Самый ранний способ использования CAN в Linux основан на интерфейсе символьного устройства. В отличие от этого, Socket CAN использует интерфейс сокета Berkeley и стек сетевого протокола Linux, что позволяет драйверам устройств CAN вызывать через сетевой интерфейс. Интерфейс Socket CAN разработан таким образом, чтобы быть как можно ближе к TCP/IP протоколу, позволяя программистам, знакомым с программированием в сети, относительно легко изучать и использовать его.

Основная цель использования Socket CAN — предоставить приложениям в пространстве пользователя интерфейс сокета, основанный на сетевом уровне Linux. В отличие от широко известного протокола TCP/IP и Ethernet, шина CAN не имеет адреса MAC уровня, аналогичного Ethernet, и может использоваться только для трансляции. ID CAN используется только для арбитража шины. Следовательно, ID CAN на шине должен быть уникальным. При разработке сетевой системы CAN-ECU (Electronic Control Unit, электронный блок управления), ID сообщения CAN можно отобразить на конкретный ECU. Следовательно, ID сообщения CAN можно использовать как адрес отправителя.

### **14.4.2 Основные знания socketcan**

В разделе "14.3 Программирование приложения STM32 CAN" мы уже построили полный фреймворк программирования приложения CAN. Однако в программировании приложения Linux операция с драйвером CAN нижнего уровня похожа на идеи STM32, но интерфейс вызова или иначе говоря, используемый метод сильно отличается. Поскольку STM32 прямо вызывает пакет SDK или напрямую управляет регистрами, в системе Linux необходимо вызывать системные команды или использовать драйвер CAN Linux для реализации операций физического уровня.

Следовательно, здесь основное внимание уделяется некоторым системным командам Linux и концепциям, связанным с socketcan.

#### **14.4.2.1 Управление устройством CAN**

Устройство CAN имеет три функции: открытие, закрытие и установку параметров. Поскольку устройство CAN в Linux имитируется как сетевой интерфейс, открытие, закрытие и установка устройства CAN выполняются через команду ip.

На отладочной плате 100ask_IMX6ULL откройте последовательный порт и используйте "ifconfig -a" для просмотра всех узлов сети. Обнаружится первый узел "can0".

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0008.png)

(1) Открытие устройства CAN в Linux:

```c
#define ip_cmd_open      "ifconfig can0 up"     /* Открыть CAN0 */
```

Примечание: can0: имя устройства CAN;

up: команда открытия устройства

(2) Закрытие устройства CAN в Linux:

```c
#define ip_cmd_close      "ifconfig can0 down"    /* Закрыть CAN0 */
```

Примечание: can0: имя устройства CAN;

down: команда закрытия устройства

(2) Установка параметров CAN в Linux (скорость передачи, скорость дискретизации):

```c
#define ip_cmd_set_can_params "ip link set can0 type can bitrate 500000 triple-sampling on"

/* Установить скорость передачи CAN0 на 500000 бит/с */
```

Примечание: can0: имя устройства CAN;

down: команда закрытия устройства

Type can: тип устройства — CAN

Bitrate 500000: установить скорость передачи на 500 кбит/с

Triple-sampleing on: включить дискретизацию

#### **14.4.2.2 Что такое сокет (Socket)**

В Linux сокет используется для операций сетей, поскольку устройство CAN также имитируется как сетевой интерфейс, оно также использует сокет.

Как показано на рисунке ниже, когда телефон A звонит телефону B, телефон A вводит номер телефона B, а телефон B получает входящий звонок от телефона A.

Телефон A и телефон B — это две конечные точки. Сокет в Linux похож на связь по телефону. Сокет — это конечная точка связи, а конечные точки связаны каналом связи; связь по телефону — это набор номера другого телефона для звонка, а сокет использует адрес для идентификации другой стороны.

![Рисунок 14.2.2.2 Модель телефонной связи](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0009.png)

#### **14.4.2.3 Функции интерфейса сокета**

Чтобы создавать и использовать интерфейсы сокета для программирования связи, нам нужно понимать функции, связанные с сокетом.

Для запроса функций в системе Linux вы можете использовать команду man для просмотра.

Пример:

man socket  /* Просмотреть описание функции socket */

**(1) Функция socket()**

В системе Linux с помощью команды "man socket" описание функции socket() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0010.png)

Прототип функции Socket выглядит следующим образом:

```c
#include <sys/types.h>

#include <sys/socket.h>

int socket(int domain, int type, int protocol);  /* Прототип функции сокета */
```

Три параметра функции выглядят следующим образом:

| domain: протокольная область, также называемая семейством протоколов (family). Обычно используемые протокольные семейства включают AF_INET, AF_INET6, AF_LOCAL (или AF_UNIX, сокет домена Unix), AF_ROUTE и т.д. Протокольное семейство определяет тип адреса сокета. При связи необходимо использовать соответствующий адрес. AF_INET определяет использование IPv4 адреса (32-битного) и номера порта (16-битного), AF_UNIX определяет использование абсолютного пути как адреса. |
| ------------------------------------------------------------ |
| type: указать тип сокета. Обычно используемые типы сокетов включают SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_PACKET, SOCK_SEQPACKET и т.д. |
| protocol: указать протокол. Обычно используемые протоколы включают IPPROTO_TCP, IPPTOTO_UDP, IPPROTO_SCTP, IPPROTO_TIPC и т.д., которые соответственно соответствуют протоколу передачи TCP, протоколу передачи UDP, протоколу передачи STCP и протоколу передачи TIPC. |

Примечание:

Не все сочетания type и protocol выше могут быть произвольно объединены. Например, SOCK_STREAM не может быть объединён с IPPROTO_UDP. Когда protocol равен 0, автоматически выбирается протокол по умолчанию, соответствующий типу type.

Когда мы вызываем сокет для создания сокета, дескриптор сокета, возвращаемый существует в пространстве протокольного семейства (адресное семейство, AF_XXX), но у него нет конкретного адреса. Если вы хотите назначить ему адрес, вы должны вызвать функцию bind(). В противном случае, когда вы вызываете connect() или listen(), система автоматически назначит случайный порт.

Socketcan использует протокольное семейство domain AF_CAN (или PF_CAN), тип type — SOCK_RAW, задаёт протокол protocol как CAN_RAW.

**(2) Функция bind()**

В системе Linux с помощью команды "man bind" описание функции bind() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0011.png)

Функция bind() назначает адрес из определённого семейства адресов к сокету. Например, для AF_INET и AF_INET6, это назначение IPv4 или IPv6 адреса и номера порта сокету.

Прототип функции Bind выглядит следующим образом:

```c
#include <sys/types.h>
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

Три параметра функции описаны ниже:

**sockfd**: дескриптор сокета, созданный функцией socket(), уникально идентифицирующий один сокет. Функция bind() привязывает имя к этому дескриптору.

**addr**: указатель на структуру const struct sockaddr *, указывающий на адрес протокола, который следует привязать к sockfd. Структура адреса зависит от семейства адресов протокола, используемого при создании сокета.

Например, для IPv4 это:

```c
struct sockaddr_in {
    sa_family_t    sin_family;   /* address family: AF_INET */
    in_port_t      sin_port;    /* port in network byte order */
    struct in_addr sin_addr;     /* internet address */
};
/* Internet address. */struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
```

Для IPv6 это:

```c
struct sockaddr_in6 {
    sa_family_t     sin6_family;   /* AF_INET6 */
    in_port_t       sin6_port;     /* port number */
    uint32_t        sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr  sin6_addr;     /* IPv6 address */
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
};
struct in6_addr {
    unsigned char   s6_addr[16];   /* IPv6 address */
};
```

Для Unix домена это:

```c
#define UNIX_PATH_MAX  108
struct sockaddr_un {
  sa_family_t sun_family;        /* AF_UNIX */
  char    sun_path[UNIX_PATH_MAX]; /* pathname */
};
```

Для домена CAN это:

Определено в файле "Linux-4.9.88\include\uapi\linux\can.h", это главное, что нужно понять в этой главе.

```c
/**
 * struct sockaddr_can - структура адреса для CAN сокетов
 * @can_family:  семейство адресов протокола AF_CAN.
 * @can_ifindex:  индекс сетевого интерфейса CAN
 * @can_addr:    информация адреса протокола
 */
struct sockaddr_can {
	__kernel_sa_family_t can_family;
	int         can_ifindex;
	union {
		/* информация адреса типа транспортного протокола (e.g. ISOTP) */
		struct { canid_t rx_id, tx_id; } tp;

		/* зарезервирована для будущего использования информация адреса CAN протокола*/
	} can_addr;
};
```

**addrlen**: соответствующая длина адреса.

Обычно сервер при запуске привязывает хорошо известный адрес (например IP адрес + номер порта) для предоставления услуги, и клиент может подключиться к серверу через него; в то время как клиент не нужно указывать, система автоматически назначит номер порта и комбинацию с его собственным IP адресом. Это причина, по которой обычно серверная сторона вызывает bind() перед listen(), в то время как клиент не вызывает его, вместо этого система случайно генерирует во время connect().

**(3) Функция ioctl()**

В системе Linux, с помощью команды "man ioctl" описание функции ioctl() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0012.png)

Уровни вызова функции Ioctl() показаны на следующей диаграмме:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0013.png)

Прототип функции Ioctl() выглядит следующим образом:

```c
#include <sys/ioctl.h>
int ioctl(int fd, unsigned long request, ...);
```

Для получения адреса локального сетевого интерфейса с помощью ioctl требуются две структуры ifconf и ifreq.

**Определение struct ifreq**
ifreq используется для сохранения информации о некотором интерфейсе.

В файле "Linux-4.9.88\include\uapi\linux\if.h" определена struct ifreq, нужно понимать, что она используется при вызове функции ioctl() для получения индекса устройства CAN (ifr_ifindex), другие параметры можно не учитывать.

```c
/*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */

/* for compatibility with glibc net/if.h */
#if __UAPI_DEF_IF_IFREQ
struct ifreq {
#define IFHWADDRLEN	6
	union
	{
		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	} ifr_ifrn;

	union {
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		struct	sockaddr ifru_netmask;
		struct  sockaddr ifru_hwaddr;
		short	ifru_flags;
		int	ifru_ivalue;
		int	ifru_mtu;
		struct  ifmap ifru_map;
		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
		char	ifru_newname[IFNAMSIZ];
		void __user *	ifru_data;
		struct	if_settings ifru_settings;
	} ifr_ifru;
};
#endif /* __UAPI_DEF_IF_IFREQ */

#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
#define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
#define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
#define	ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
#define ifr_map		ifr_ifru.ifru_map	/* device map		*/
#define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index	*/
#define ifr_bandwidth	ifr_ifru.ifru_ivalue    /* link bandwidth	*/
#define ifr_qlen	ifr_ifru.ifru_ivalue	/* Queue length 	*/
#define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
#define ifr_settings	ifr_ifru.ifru_settings	/* Device/proto settings*/
```

**Определение struct ifconf**
ifconf обычно используется для сохранения информации о всех интерфейсах, эта глава не использует его, поэтому мы не даём подробного описания.

**(4) Функция setsockopt()**

В системе Linux, с помощью команды "man setsockopt" описание функции setsockopt() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0014.png)

Прототипы функций setsockopt() и getsockopt выглядят следующим образом:

```c
#include <sys/types.h>
#include <sys/socket.h>
int getsockopt(int sockfd, int level, int optname,void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

Setsockopt() используется для установки значений параметров для сокетов любого типа и в любом состоянии. Несмотря на наличие параметров на разных уровнях протокола, эта функция определяет параметры только на самом высоком уровне "сокета".

Параметры функции выглядят следующим образом:

| sockfd: дескриптор, идентифицирующий сокет.                             |
| ------------------------------------------------------------ |
| level: уровень, на котором определён параметр; поддерживает SOL_SOCKET, IPPROTO_TCP, IPPROTO_IP, IPPROTO_IPV6, SOL_CAN_RAW и др. |
| optname: параметр, который нужно установить.                                      |
| optval: указатель на буфер, содержащий новое значение параметра для установки.                    |
| optlen: длина буфера optval.                                   |

Примеры вызова функции выглядят следующим образом:

| **Пример 1: Установить фильтр CAN так, чтобы не принимались никакие сообщения.**                   |
| ------------------------------------------------------------ |
| //Отключить правило фильтрации, этот процесс не принимает сообщения, только отправляет    <br><br/> //Установить правило фильтрации  setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL,  0); |

| **Пример 2: Установить фильтр CAN для приёма определённого сообщения**                   |
| ------------------------------------------------------------ |
| //Определить правило приёма, принимать только сообщения с идентификатором 0x201    <br/><br/> //Определено в заголовочных файлах Linux, можно также определить самостоятельно  <br/>#define CAN_SFF_MASK 0x000007ffU    <br/><br/> //Определить фильтр (1 штука)  <br/>struct can_filter rfilter[1]; <br/> rfilter[0].can_id = 0x201;  <br/>rfilter[0].can_mask = CAN_SFF_MASK;  <br/>//Установить правило фильтрации <br/>setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER,  &rfilter, sizeof(rfilter)); |

| **Пример 2: Установить фильтр CAN для приёма определённого сообщения**                   |
| ------------------------------------------------------------ |
| //Определить правило приёма, принимать только сообщения с идентификатором 0x201    <br/><br/> //Определено в заголовочных файлах Linux, можно также определить самостоятельно  <br/>#define CAN_SFF_MASK 0x000007ffU     <br/><br/>//Определить фильтр (3 штуки)  <br/>struct can_filter rfilter[3];  <br/>rfilter[0].can_id = 0x201;  <br/>rfilter[0].can_mask = CAN_SFF_MASK;     <br/><br/>rfilter[1].can_id = 0x401;  <br/>rfilter[1].can_mask = CAN_SFF_MASK;     <br/><br/>rfilter[2].can_id = 0x601;  <br/>rfilter[2].can_mask = CAN_SFF_MASK;     <br/><br/>//Установить правило фильтрации <br/>setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER,  &rfilter, sizeof(rfilter)); |

**(5) Функция write()**

В системе Linux, с помощью команды "man 2 write" описание функции write() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0015.png)

Прототип функции Write выглядит следующим образом:

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

**(6) Функция read()**

В системе Linux, с помощью команды "man 2 read" описание функции read() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0016.png)

Прототип функции Read выглядит следующим образом:

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

**(7) Функция close()**

В системе Linux, с помощью команды "man 2 close" описание функции close() выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0017.png)

Прототип функции close() выглядит следующим образом:

```c
#include <unistd.h>
int close(int fd);
```

### **14.4.3 простой пример отправки socket_can**

Каталог с кодом простого примера отправки: "02_socketcan_send"



Описание случая:

1. Реализовать периодическую отправку сообщения с ID: 0x101 с периодом в 1 секунду;



**Информация для понимания: электрическая схема интерфейса CAN IMX6**

Из приведённой ниже схемы периферии CAN видно, что она полностью идентична STM32, только встроенный контроллер CAN имеет некоторые небольшие отличия из-за разных производителей микросхем. Эта схема предназначена только для сравнения, при разработке Linux приложений не нужно обращать внимание на обработку нижнего уровня драйвера.

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0018.png)

Теперь давайте, следуя порядку раздела 14.3, пошагово напишем приложение Linux socketCAN по образцу каркаса приложения программирования CAN под STM32.

**Подготовка:**

Подготовим файлы кода приложения CAN в соответствии с разделом 14.3:

| Имя файла           | Описание содержимого файла                                                 |
| ---------------- | ------------------------------------------------------------ |
| App_can.c        | Реализация функции приложения CAN                                              |
| App_can.h        | Файл заголовка функции приложения CAN                                            |
| Can_controller.c | Конкретная реализация уровня абстракции операций драйвера CAN                                    |
| Can_controller.h | Файл заголовка уровня абстракции операций драйвера CAN                                      |
| Can_msg.h        | Базовая структура сообщения CAN, скопирована из драйвера CAN STM32, главным образом используется для использования наиболее знакомого нам структурного при использовании сообщений CAN. Этот файл является новым по сравнению со STM32, так как наш каркас основан на приложениях микроконтроллеров, а затем переносится в Linux путём сравнительного обучения. |
| Makefile         | Скрипт компиляции Makefile                                             |

#### **14.4.3.1** **Написание функций реализации каркаса абстракции**



Сначала мы используем абстрактную структуру, уже созданную в разделе 14.3, как показано ниже:

Смотрите в коде главы 14 "02_socketcan_send_addline" в файле "can_controller.h".

```c
34 /* Определение структуры абстракции связи CAN*/
35 typedef struct _CAN_COMM_STRUCT
36 {
37     /* Имя оборудования CAN */
38     char *name;
39     /* Номер порта CAN, в микроконтроллере это номер порта; в приложении Linux это служит в качестве сокета */
40     int  can_port;
41     /* Функция конфигурации контроллера CAN, возвращает номер порта для назначения can_port */
42     int  (*can_set_controller)( void );
43     /* Создание прерывания интерфейса CAN, в Linux это соответствует созданию потока приёма */
44     void (*can_set_interrput)( int can_port , pCanInterrupt callback );
45     /* Интерфейс чтения сообщения CAN */
46     void (*can_read)( int can_port , CanRxMsg* recv_msg);
47     /* Интерфейс отправки сообщения CAN*/
48     void (*can_write)( int can_port , CanTxMsg send_msg);
49 }CAN_COMM_STRUCT, *pCAN_COMM_STRUCT;
50
```

Мы напишем функции для реализации CAN операций драйвера в can_controller.c в порядке структуры этого структурного типа.



**(1) Определение устройства CAN**

На основе описания раздела 14.4.2.1, для использования приложением CAN на уровне приложения Linux нужно знать имя устройства.

Откройте последовательный порт на плате разработки 100ask_IMX6ULL и используйте команду "ifconfig -a" для просмотра, узнаём, что имя текущего устройства CAN это "can0".



Можно напрямую использовать команду ip на командной строке Linux для открытия, установки и закрытия устройства CAN, поэтому мы определили три макроса ip_cmd_open, ip_cmd_close, ip_cmd_set_can_params, эти три макроса можно выполнять через системный вызов system().



Смотрите определения макросов в коде главы 14 "02_socketcan_send_addline" в файле "can_controller.c".

```c
29 /**************Определения макросов**************************************************/

31 /* Установить битовую скорость CAN0 на 500000 bps */
32 #define ip_cmd_set_can_params  "ip link set can0 type can bitrate 500000 triple-sampling on"

34 /* Открыть CAN0 */
35 #define ip_cmd_open            "ifconfig can0 up"

37 /* Закрыть CAN0 */
38 #define ip_cmd_close           "ifconfig can0 down"
```

**(2) Конфигурирование контроллера CAN**

Конфигурирование контроллера CAN имеет 3 части: открытие устройства can0, конфигурирование битовой скорости CAN, конфигурирование фильтра CAN.

Смотрите функцию int CAN_Set_Controller( void ) в файле "can_controller.c" в коде главы 14 "01_stm32f407_can_addline".



**A. Конфигурирование битовой скорости, открытие устройства can0**

Используя три команды ip_cmd_open, ip_cmd_close, ip_cmd_set_can_params из (1), посредством системного вызова system(): конкретный код выглядит следующим образом:

```c
77     /* Установить битовую скорость CAN по системному вызову ip команды */
78     system(ip_cmd_close);
79     system(ip_cmd_set_can_params);
80     system(ip_cmd_open);
```

**B. Создание сокета**

Так как приложение Linux работает с устройствами только через операции чтения read и записи write, Linux всё это - файл, а socketcan это специальный файл, поэтому нам нужно вызвать функцию socket() для создания интерфейса socketcan и получить дескриптор sock_fd.

Конкретный код выглядит следующим образом:

```c
82   /*************************************************************/
83   /* Создать сокет sock_fd */
84   sock_fd = socket(AF_CAN, SOCK_RAW, CAN_RAW);
85 	if(sock_fd < 0)
86 	{
87 		perror("socket create error!\n");
88 		return -1;
89 	}
```

**C. Привязать устройство can0 к сокету**



Конкретный код выглядит следующим образом:

```c
92   //Привязать сокет к can0
93   strcpy(ifr.ifr_name, "can0");
94 	ioctl(sock_fd, SIOCGIFINDEX,&ifr); // Установить устройство на can0

96 	ifr.ifr_ifindex = if_nametoindex(ifr.ifr_name);
97 	printf("ifr_name:%s \n",ifr.ifr_name);
98 	printf("can_ifindex:%d \n",ifr.ifr_ifindex);

100 addr.can_family = AF_CAN;
101 addr.can_ifindex = ifr.ifr_ifindex;
102
103 if( bind(sock_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0 )
104 {
105 	perror("bind error!\n");
106 	return -1;
107 }
```

**C. Конфигурирование фильтра**



Конкретный код выглядит следующим образом:

```c
109 	/*************************************************************/
110 	//Отключить правило фильтрации, этот процесс не принимает сообщения, только отправляет
111  setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
```

**D. Конфигурирование неблокирующей операции**

Системные вызовы Linux read и write имеют режимы блокирования и неблокирования, при периодическом вызове мы используем неблокирующий режим для операций чтения-записи сообщений CAN.

Конкретная реализация кода выглядит следующим образом:

```c
114     //Установить функции read() и write() в неблокирующий режим
115     int flags;
116     flags = fcntl(sock_fd, F_GETFL);
117     flags |= O_NONBLOCK;
118     fcntl(sock_fd, F_SETFL, flags);
```

**E. Вернуть сокет sock_fd**

Конкретная реализация кода выглядит следующим образом:

Функция int CAN_Set_Controller( void ) напрямую заканчивается, возвращаемое значение назначается члену can_port структуры CAN_COMM_STRUCT.

Впоследствии дескриптор sock_fd, доступный на уровне приложения, это can_port.

**(3) Создание потока приёма CAN**

В STM32 прием использует прерывание FIFO приёма для обработки, в приложении Linux мы используем циклический опрос потока для чтения сообщений.

Поэтому нам нужно создать поток приёма CAN, конкретная реализация кода выглядит следующим образом:

```c
127 /**********************************************************************
128 * Имя функции: void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
129 * Описание функции: Создать поток приёма CAN и передать функцию обратного вызова приложения, функция обратного вызова главным образом обрабатывает функции уровня приложения
130 * Входной параметр: can_port, номер порта
131 *          callback: функция обратного вызова для обработки функций прерывания
132 * Выходной параметр: нет
133 * Возвращаемое значение: нет
134 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
135 * -----------------------------------------------
136 * 2020/05/13         V1.0             bert            создано
137 ***********************************************************************/
138 void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
139 {
140     int err;
141
142     if ( NULL != callback )
143     {
144         g_pCanInterrupt = callback;
145     }
146
147     err = pthread_create(&ntid, NULL,CAN1_RX0_IRQHandler, NULL );
148     if( err !=0 )
149     {
150         printf("create thread fail! \n");
151         return ;
152     }
153     printf("create thread success!\n");
154
155
156     return ;
157 }
```

Функция созданного потока выглядит следующим образом:

CAN1_RX0_IRQHandler это функция потока приёма CAN, похожая на функцию прерывания приёма CAN, только здесь используется циклический опрос для чтения сообщений CAN.

```c
253 /**********************************************************************
254 * Имя функции: void CAN1_RX0_IRQHandler(void)
255 * Описание функции: Функция потока приёма CAN
256 * Входной параметр: нет
257 * Выходной параметр: нет
258 * Возвращаемое значение: нет
259 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
260 * -----------------------------------------------
261 * 2020/05/13         V1.0             bert            создано
262 ***********************************************************************/
263 void *CAN1_RX0_IRQHandler(void *arg)
264 {
265     /* Определение принимаемого сообщения */
266     while( 1 )
267     {
268     /* Если функция обратного вызова существует, то выполнить функцию обратного вызова */
269         if( g_pCanInterrupt != NULL)
270         {
271             g_pCanInterrupt();
272         }
273         usleep(10000);
274     }
275 }
```

**(4) Функция чтения сообщения CAN**

```c
161 /**********************************************************************
162 * Имя функции: void CAN_Read(int can_port, CanRxMsg* recv_msg)
163 * Описание функции: Чтение регистра приёма CAN и извлечение принятого сообщения
164 * Входной параметр: can_port, номер порта
165 * Выходной параметр: recv_msg: принимаемое сообщение
166 * Возвращаемое значение: нет
167 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
168 * -----------------------------------------------
169 * 2020/05/13         V1.0             bert            создано
170 ***********************************************************************/
171 void CAN_Read(int can_port, CanRxMsg* recv_msg)
172 {
173     unsigned char i;
174     static unsigned int rxcounter =0;
175
176     int nbytes;
177     struct can_frame rxframe;
178
179
180     nbytes = read(can_port, &rxframe, sizeof(struct can_frame));
181 	if(nbytes>0)
182 	{
183 	    printf("nbytes = %d \n",nbytes );
184
185 	    recv_msg->StdId = rxframe.can_id;
186 	    recv_msg->DLC = rxframe.can_dlc;
187 	    memcpy( recv_msg->Data, &rxframe.data[0], rxframe.can_dlc);
188
189 		rxcounter++;
190 		printf("rxcounter=%d, ID=%03X, DLC=%d, data=%02X %02X %02X %02X %02X %02X %02X %02X \n",  \
191 			rxcounter,
192 			rxframe.can_id, rxframe.can_dlc,  \
193 			rxframe.data[0],\
194 			rxframe.data[1],\
195 			rxframe.data[2],\
196 			rxframe.data[3],\
197 			rxframe.data[4],\
198 			rxframe.data[5],\
199 			rxframe.data[6],\
200 			rxframe.data[7] );
201 	}
203     return ;
204 }
205
```

**(5) Функция отправки сообщения CAN**

```c
206 /**********************************************************************
207 * Имя функции: void CAN_Write(int can_port, CanTxMsg send_msg)
208 * Описание функции: Интерфейс отправки сообщения CAN, отправка сообщения через регистр передачи
209 * Входной параметр: can_port, номер порта
210 * Выходной параметр: send_msg: отправляемое сообщение
211 * Возвращаемое значение: нет
212 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
213 * -----------------------------------------------
214 * 2020/05/13         V1.0             bert            создано
215 ***********************************************************************/
216 void CAN_Write(int can_port, CanTxMsg send_msg)
217 {
217     unsigned char i;
218     static unsigned int txcounter=0;
219     int nbytes;
220
221     struct can_frame txframe;
222
223     txframe.can_id = send_msg.StdId;
224     txframe.can_dlc = send_msg.DLC;
225     memcpy(&txframe.data[0], &send_msg.Data[0], txframe.can_dlc);
226
227     nbytes = write(can_port, &txframe, sizeof(struct can_frame)); //отправка frame[0]
228
229 	if(nbytes == sizeof(txframe))
230 	{
231 	    txcounter++;
232 	    printf("txcounter=%d, ID=%03X, DLC=%d, data=%02X %02X %02X %02X %02X %02X %02X %02X \n",  \
233 			txcounter,
234 			txframe.can_id, txframe.can_dlc,  \
235 			txframe.data[0],\
236 			txframe.data[1],\
237 			txframe.data[2],\
238 			txframe.data[3],\
239 			txframe.data[4],\
240 			txframe.data[5],\
241 			txframe.data[6],\
242 			txframe.data[7] );
243     }
244     else
245 	{
246 		//printf("Send Error frame[0], nbytes=%d\n!",nbytes);
247 	}
248
249     return ;
250 }
251
```

**(6) Инициализация каркаса структуры абстракции CAN**

Похоже на определение экземпляра в разделе 14.3 STM32.

Определить экземпляр структуры can1_controller CAN_COMM_STRUCT;

Инициализировать can1_controller, используя функции, реализованные в шагах (1)~(5), составить точку связи, связанную с уровнем приложения.

```c
298 /**********************************************************************
299 * Имя:     can1_controller
300 * Описание функции: Инициализация структуры CAN1
301 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
302 * -----------------------------------------------
303 * 2020/05/13         V1.0             bert            создано
304 ***********************************************************************/
305 CAN_COMM_STRUCT can1_controller = {
306     .name                   = "can0",
307     .can_port               = CAN_PORT_CAN1,
308     .can_set_controller     = CAN_Set_Controller,
309     .can_set_interrput      = CAN_Set_Interrupt,
310     .can_read               = CAN_Read,
311     .can_write              = CAN_Write,
312 };
```

#### **14.4.3.2 Написание кода уровня приложения**

На основе 14.4.3.1 мы уже реализовали конкретные операции CAN в Linux socketCAN и уже абстрагировали и инстанцировали каркас программирования CAN.

Но в настоящее время ны ещё не связали уровень приложения, уровень приложения не знает, какой интерфейс вызывать.

**(1) Регистрация экземпляра контроллера CAN на уровне приложения**

Напишите универсальную функцию регистрации инстанцирования на уровне приложения.

Смотрите функцию int register_can_controller(const pCAN_COMM_STRUCT p_can_controller) в файле "app_can.c" в коде главы 14 "02_socketcan_send_addline".

Реализация кода выглядит следующим образом: (абсолютно идентична программированию приложения CAN STM32, код почти не нужно менять)

```c
73 /**********************************************************************
74 * Имя функции: int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
75 * Описание функции: Регистрация структуры CAN1 на уровне приложения
76 * Входной параметр: p_can_controller, структура абстракции контроллера CAN
77 * Выходной параметр: нет
78 * Возвращаемое значение: нет
79 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
80 * -----------------------------------------------
81 * 2020/05/13         V1.0             bert            создано
82 ***********************************************************************/
83 int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
84 {
85     /* Проверить, что передаваемый p_can_controller не пуст, чтобы убедиться, что эта структура это сущность */
86     if( p_can_controller != NULL )
87     {
88         /* Назначить передаваемый параметр p_can_controller структуре приложения gCAN_COMM_STRUCT */
89
90         /*Номер порта, типологично сокету socketcan*/
91         gCAN_COMM_STRUCT.can_port              = p_can_controller->can_port;
92         /*Функция конфигурирования контроллера CAN*/
93         gCAN_COMM_STRUCT.can_set_controller    = p_can_controller->can_set_controller;
94         /*Конфигурирование прерывания CAN*/
95         gCAN_COMM_STRUCT.can_set_interrput     = p_can_controller->can_set_interrput;
96         /*Функция чтения сообщения CAN*/
97         gCAN_COMM_STRUCT.can_read              = p_can_controller->can_read;
98         /*Функция отправки сообщения CAN*/
99         gCAN_COMM_STRUCT.can_write             = p_can_controller->can_write;
100         return 1;
101     }
102 	return 0;
103 }
```

**(2) Инициализация уровня приложения CAN**

Инициализация кода уровня приложения CAN выглядит следующим образом: (абсолютно идентична коду приложения CAN STM32)

```c
105 /**********************************************************************
106 * Имя функции: void app_can_init(void)
107 * Описание функции: Инициализация уровня приложения CAN
108 * Входной параметр: нет
109 * Выходной параметр: нет
110 * Возвращаемое значение: нет
111 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
112 * -----------------------------------------------
113 * 2020/05/13         V1.0             bert            создано
114 ***********************************************************************/
115 void app_can_init(void)
116 {
117     /**
118     * Регистрация структуры CAN1 на уровне приложения
119     */
120     CAN1_contoller_add();
121
122     /*
123     *Вызвать can_set_controller для конфигурирования контроллера CAN,
124     *вернуть can_port, типологично сокету Linux socketcan, в примере микроконтроллера это пользовательский канал CAN
125     */
126     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
127     /**
128     * Вызвать can_set_interrput для конфигурирования прерывания приёма CAN, типологично потоку приёма в socketcan, в этом примере приёмной части нет, поэтому функция обратного вызова передаёт NULL
129     */
130     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, NULL );
131 }
```

**(3) Проектирование простой функции периодической отправки сообщений**

Нам нужно сначала разработать функцию void app_can_tx_test(void), которая будет вызываться в функции периода 10ms, эта функция будет вызываться в основном потоке main.



Реализация функции периодической отправки сообщений CAN выглядит следующим образом:

```c
134 /**********************************************************************
135 * Имя функции: void app_can_tx_test(void)
136 * Описание функции: Функция отправки сообщения на уровне приложения CAN для тестирования периодической отправки сообщений
137 * Входной параметр: нет
138 * Выходной параметр: нет
139 * Возвращаемое значение: нет
140 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
141 * -----------------------------------------------
142 * 2020/05/13         V1.0             bert            создано
143 ***********************************************************************/
144 void app_can_tx_test(void)
145 {
146     // На основе 10ms, запустить тестовую программу CAN
147
148     unsigned char i=0;
149
150     /* Определение отправляемого сообщения */
151     CanTxMsg TxMessage;
152
153     /* Счётчик в отправляемом сообщении */
154     static unsigned char tx_counter = 0;
155
156     /* На основе 10ms, используя счётчик timer установить период работки кода после этого места на 1 секунду*/
157     static unsigned int timer =0;
158     if(timer++>100)
159     {
160         timer = 0;
161     }
162     else
163     {
164         return ;
165     }
166
167     /* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
168     TxMessage.StdId = TX_CAN_ID;	      /* Стандартный идентификатор 0x000~0x7FF */
169     TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
169     TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
170     TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных */
171     TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
172
173     /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
174     TxMessage.Data[0] = tx_counter++;       /* Используется для идентификации счётчика отправляемого сообщения */
175     for(i=1; i<TxMessage.DLC; i++)
176     {
177         TxMessage.Data[i] = i;
178     }
179
180     /*  Вызвать can_write отправить сообщение CAN */
181     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
182
183 }
184
```

Затем добавить функцию void app_can_tx_test(void) в функцию main для периодического выполнения с периодом 10ms, реализация кода выглядит следующим образом:

```c
188 /**********************************************************************
189 * Имя функции: int main(int argc, char **argv)
190 * Описание функции: Основная функция
191 * Входной параметр: нет
192 * Выходной параметр: нет
193 * Возвращаемое значение: нет
194 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
195 * -----------------------------------------------
196 * 2020/05/13         V1.0             bert            создано
197 ***********************************************************************/
198 int main(int argc, char **argv)
199 {
200     /* Инициализация уровня приложения CAN */
201     app_can_init();
202
203     while(1)
204     {
205         /* Периодическая отправка сообщения на уровне приложения CAN */
206         app_can_tx_test();
207
207         /* Использование функции задержки Linux для проектирования базиса работы 10ms */
208         usleep(10000);
209     }
210 }
```

#### **14.4.3.3 Проверка и верификация тестового случая**

Когда написание приведённого выше кода завершено, файлы каталога выглядят следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0019.png)

**(1) Написание Makfile**

Содержание файла Makefile выглядит следующим образом:

```c
all:
	arm-linux-gnueabihf-gcc -lpthread -o socketcan_send   can_controller.c  app_can.c
clean:
	rm socketcan_send
```

**(2) Компиляция socket_send**

 Примечание: компиляция выполняется в виртуальной машине 100ask-vmware_ubuntu18.04.

Войдите в каталог socket_send соответствующей виртуальной машины ubuntu

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0020.png)

Введите команду make:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0021.png)

После компиляции с помощью команды make, генерируется исполняемый файл socketcan_send.

**(3) Запуск socket_send**

Примечание: запуск на плате разработки 100ask_imx6.

Используется NFS файловая система для запуска.



Сначала подайте питание на плату разработки 100ask_imx6ull и откройте последовательный порт:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0022.png)

Введите пользователя root для входа в систему Linux на плате разработки;

Затем подключите NFS, операция выглядит следующим образом:

```c
Mount -t nfs -o nolock 192.168.1.100:/home/book  /mnt
```

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0023.png)

Примечание: мой текущий IP платы разработки: 192.168.1.101, виртуальной машины Ubuntu: 192.168.1.100.



Затем запустить ./socketcan_send

Если при запуске отображается сообщение об ошибке прав доступа, можно использовать команду chmod для установки прав:

```c
Chmod 777 socketcan_send
```

Информация печати последовательного порта после запуска выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0024.png)

Затем наблюдайте результаты тестирования на верхней панели Vehcile Spy3 следующим образом:

Сообщение отправляется периодически с периодом 1 секунда, сообщение ID 0x101 на CAN шине.

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0025.png)

**(4) Итоги теста**

До этого момента мы уже установили каркас программирования приложения в Linux с использованием socketcan и успешно отладили функцию периодической отправки сообщений CAN.

Впоследствии мы будем пошагово понимать программирование приложения CAN в Linux на основе этого каркаса;



Цели различных случаев разделов приведены ниже:

| Раздел                            | Цель                     |
| ------------------------------- | ------------------------ |
| 14.4.3 простой пример отправки socket_can   | Простой прямой прием отправки сообщений   |
| 14.4.4 простой пример приёма socket_can   | Простой прямой прием приёма сообщений   |
| 14.4.5 пример приёма и отправки socket_can | Комбинированная операция отправки и приёма сообщений |

### **14.4.4 простой пример приёма socket_can**

Каталог с кодом простого примера приёма: "03_socketcan_recv"

Мы уже понимали функцию отправки сообщений в разделе 14.4.3 и уже установили каркас программирования приложения в Linux; эта глава сосредоточена на простой функции приёма.



Описание случая:

1. Реализовать приём сообщений ID: 0x201.



#### **14.4.4.1 Написание функций реализации каркаса абстракции**

**(1) Определение устройства CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (1) "Определение устройства CAN".



**(2) Конфигурирование контроллера CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (2) "Конфигурирование контроллера CAN".

Так как в разделе "14.4.3.1" мы только отправляли и установили фильтр для запрета всех сообщений. Конкретный код выглядит следующим образом:

```c
109 /*************************************************************/
110 //Отключить правило фильтрации, этот процесс не принимает сообщения, только отправляет
111 setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
```

Этот случай требует конфигурирования приёма, фильтр конфигурирования имеет соответствующие различия, мы в настоящий момент конфигурируем приём только сообщения ID 0x201,

Конкретная реализация кода выглядит следующим образом:

```c
110 	//Определить правило приёма, принимать только сообщения с идентификатором 0x201
111 	struct can_filter rfilter[1];
112 	rfilter[0].can_id = 0x201;
113 	rfilter[0].can_mask = CAN_SFF_MASK;
114 	//Установить правило фильтрации
115 	setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
```

В качестве расширения, мы также можем установить несколько фильтров:

Определить фильтр:

```c
struct can_filter rfilter[5];  /*Определить 10 фильтров*/
rfilter[0].can_id = 0x201;
rfilter[0].can_mask = 0x7FF;  /*Правило фильтрации: can_id & mask = 0x201 & 0x7FF = 0x201*/
rfilter[1].can_id = 0x302;
rfilter[1].can_mask = 0x7FF;  /*Правило фильтрации: can_id & mask = 0x302& 0x7FF = 0x302*/
rfilter[2].can_id = 0x403;
rfilter[2].can_mask = 0x7FF;  /*Правило фильтрации: can_id & mask = 0x403& 0x7FF = 0x403*/
rfilter[3].can_id = 0x504;
rfilter[3].can_mask = 0x700;  /*Правило фильтрации: can_id & mask = 0x504 & 0x700 = 0x500, то есть прием сообщений ID 0x5** */
rfilter[3].can_id = 0x605;
rfilter[3].can_mask = 0x700;  /*Правило фильтрации: can_id & mask = 0x504 & 0x700 = 0x600*/
setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
```

**(3) Создание потока приёма CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (3) "Создание потока приёма CAN".

**(4) Функция чтения сообщения CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (4) "Функция чтения сообщения CAN".

**(5) Функция отправки сообщения CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (5) "Функция отправки сообщения CAN".

**(6) Инициализация каркаса структуры абстракции CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (6) "Инициализация каркаса структуры абстракции CAN".



#### **14.4.4.2** **Написание кода уровня приложения**

**(1) Регистрация экземпляра контроллера CAN на уровне приложения**

Смотрите описание в разделе "14.4.3.2 Написание кода уровня приложения" (1) "Регистрация экземпляра контроллера CAN на уровне приложения".



**(2) Инициализация уровня приложения CAN**

В этом простом примере приёма нам нужно передать указатель функции обратного вызова CAN_RX_IRQHandler_Callback в поток приёма, в этой функции уровень приложения может самостоятельно обработать чтение сообщений CAN и т.д.

```c
105 /**********************************************************************
106 * Имя функции: void app_can_init(void)
107 * Описание функции: Инициализация уровня приложения CAN
108 * Входной параметр: нет
109 * Выходной параметр: нет
110 * Возвращаемое значение: нет
111 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
112 * -----------------------------------------------
113 * 2020/05/13         V1.0             bert            создано
114 ***********************************************************************/
115 void app_can_init(void)
116 {
117     /**
118     * Регистрация структуры CAN1 на уровне приложения
119     */
120     CAN1_contoller_add();
121
122     /*
123     *Вызвать can_set_controller для конфигурирования контроллера CAN,
124     *вернуть can_port, типологично сокету Linux socketcan, в примере микроконтроллера это пользовательский канал CAN
125     */
126     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
127     /**
128     * Вызвать can_set_interrput для конфигурирования прерывания приёма CAN, типологично потоку приёма в socketcan
129     */
130     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, CAN_RX_IRQHandler_Callback );
131 }
```

**(3) Проектирование простой функции приёма сообщения**



Конкретная реализация void CAN_RX_IRQHandler_Callback(void) выглядит следующим образом:

Функция CAN_RX_IRQHandler_Callback циклически выполняется в потоке приёма, на уровне приложения в функции CAN_RX_IRQHandler_Callback выполняется gCAN_COMM_STRUCT.can_read чтение сообщения CAN.

```c
133 /**********************************************************************
134 * Имя функции: void CAN_RX_IRQHandler_Callback(void)
135 * Описание функции: Функция прерывания приёма CAN1; в Linux это можно сравнить с потоком или таймером для чтения данных CAN
136 * Входной параметр: нет
137 * Выходной параметр: нет
138 * Возвращаемое значение: нет
139 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
140 * -----------------------------------------------
141 * 2020/05/13         V1.0             bert            создано
142 ***********************************************************************/
143 void CAN_RX_IRQHandler_Callback(void)
144 {
145     /* Определение принимаемого сообщения */
146     CanRxMsg RxMessage;
147
148     /* Очистка принимаемого сообщения */
149     memset( &RxMessage, 0, sizeof(CanRxMsg) );
150
151     /* Через интерфейс can_read прочитать регистр и получить принятое сообщение */
152     gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);
154
155     /* Скопировать прочитанное сообщение CAN в глобальную структуру сообщения g_CAN1_Rx_Message */
156     memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
157
158 }
```

Этот случай не имеет функции отправки сообщений, код в основном потоке не обрабатывает, просто холостой ход, работает.

```c
159 /**********************************************************************
160 * Имя функции: int main(int argc, char **argv)
161 * Описание функции: Основная функция
162 * Входной параметр: нет
163 * Выходной параметр: нет
164 * Возвращаемое значение: нет
165 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
166 * -----------------------------------------------
167 * 2020/05/13         V1.0             bert            создано
168 ***********************************************************************/
169 int main(int argc, char **argv)
170 {
171     /* Инициализация уровня приложения CAN */
172     app_can_init();
173
174     while(1)
175     {
176         /* Использование функции задержки Linux для проектирования базиса работы 10ms */
177         usleep(10000);
178     }
179 }
180
```



#### **14.4.4.3** **Проверка и верификация тестового случая**

**(1) Написание Makfile**

Содержание файла Makefile выглядит следующим образом:

```c
all:

   arm-linux-gnueabihf-gcc -lpthread -o socketcan_recv  can_controller.c app_can.c

clean:

   rm socketcan_recv
```

**(2) Компиляция socket_recv**

 Примечание: компиляция выполняется в виртуальной машине 100ask-vmware_ubuntu18.04.

Войдите в каталог socket_recv соответствующей виртуальной машины ubuntu и выполните make all для компиляции.

Процесс компиляции выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0026.png)

**(3) Запуск socket_recv**

Примечание: запуск на плате разработки 100ask_imx6.

Используется NFS файловая система для запуска.

Подключение NFS, смотрите описание "14.4,3.3 Проверка и верификация тестового случая".

В окружении платы разработки 100ask_imx6 выполнить "./socket_recv" запуск программы;

Затем через Vehicle Spy3 отправить на CAN порт платы разработки 100ask_imx6 сообщение ID 0x201, трассировка сообщения выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0027.png)

Информация печати последовательного порта платы разработки 100ask_imx6 выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0028.png)

**(4) Итоги теста**

До этого момента мы успешно отладили функцию приёма сообщений CAN.



### **14.4.5 пример приёма и отправки socket_can**

Каталог с кодом примера приёма и отправки: "04_socketcan_recv_send"

Этот случай объединил "14.4.3 простой пример отправки" и "14.4.3 простой пример приёма", построен в комбинированный случай с как отправкой, так и приёмом.



Описание случая:

1. Реализовать периодическую отправку сообщения ID: 0x101 с периодом 1 секунда;

2. Реализовать приём сообщения ID: 0x201, скопировать содержимое в сообщение ID: 0x301 и отправить;



#### **14.4.5.1 Написание функций реализации каркаса абстракции**

**(1) Определение устройства CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (1) "Определение устройства CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (1) "Определение устройства CAN".



**(2) Конфигурирование контроллера CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (2) "Конфигурирование контроллера CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (2) "Конфигурирование контроллера CAN".



**(3) Создание потока приёма CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (3) "Создание потока приёма CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (3) "Создание потока приёма CAN".



**(4) Функция чтения сообщения CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (4) "Функция чтения сообщения CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (4) "Функция чтения сообщения CAN".



**(5) Функция отправки сообщения CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (5) "Функция отправки сообщения CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (5) "Функция отправки сообщения CAN".



**(6) Инициализация каркаса структуры абстракции CAN**

Смотрите описание в разделе "14.4.3.1 Написание функций реализации каркаса абстракции" (6) "Инициализация каркаса структуры абстракции CAN".

Смотрите описание в разделе "14.4.4.1 Написание функций реализации каркаса абстракции" (6) "Инициализация каркаса структуры абстракции CAN".



**14.4.5.2** **Написание кода уровня приложения**

**(1) Регистрация экземпляра контроллера CAN на уровне приложения**

Смотрите описание в разделе "14.4.3.2 Написание кода уровня приложения" (1) "Регистрация экземпляра контроллера CAN на уровне приложения".

Смотрите описание в разделе "14.4.4.2 Написание кода уровня приложения" (1) "Регистрация экземпляра контроллера CAN на уровне приложения".



**(2) Инициализация уровня приложения CAN**

Смотрите описание в разделе "14.4.4.2 Написание кода уровня приложения" (2) "Инициализация уровня приложения CAN".



**(3) Проектирование простой функции периодической отправки сообщения**

Смотрите описание в разделе "14.4.3.2 Написание кода уровня приложения" (3) "Проектирование простой функции периодической отправки сообщений".



**(4) Проектирование простой функции периодического приёма сообщения**

Смотрите описание в разделе "14.4.4.2 Написание кода уровня приложения" (3) "Проектирование простой функции приёма сообщения".



Одновременно нам нужно здесь скопировать содержимое принятого сообщения ID: 0X201 в сообщение ID: 0x301 и отправить.

На основе "14.4.4 простой пример приёма сообщения" добавляем простую логику, в функции обратного вызова CAN_RX_IRQHandler_Callback потока приёма, вызвать gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage) получить сообщение ID: 0x201, установить флаг g_CAN1_Rx_Flag = 1; затем в основном потоке проверить, установлен ли этот флаг на 1, что означает уже получено, тогда в void app_can_rx_test(void) скопировать содержимое сообщения ID:0X201 и затем присвоить сообщению ID:0x301.

Реализация кода функции обратного вызова потока приёма CAN_RX_IRQHandler_Callback выглядит следующим образом:

```c
231 /**********************************************************************
232 * Имя функции: void CAN_RX_IRQHandler_Callback(void)
233 * Описание функции: Функция прерывания приёма CAN1; в Linux это можно сравнить с потоком или таймером для чтения данных CAN
234 * Входной параметр: нет
235 * Выходной параметр: нет
236 * Возвращаемое значение: нет
237 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
238 * -----------------------------------------------
239 * 2020/05/13         V1.0             bert            создано
240 ***********************************************************************/
241 void CAN_RX_IRQHandler_Callback(void)
242 {
243     /* Определение принимаемого сообщения */
244     CanRxMsg RxMessage;
245
246     /* Очистка принимаемого сообщения */
247     memset( &RxMessage, 0, sizeof(CanRxMsg) );
248
249     /* Через интерфейс can_read прочитать регистр и получить принятое сообщение */
250     gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);

252     /* Скопировать прочитанное сообщение CAN в глобальную структуру сообщения g_CAN1_Rx_Message */
253     memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
254
255     /* Установить текущий флаг завершения приёма, проверить, что ID принятого сообщения равен RX_CAN_ID, затем установить g_CAN1_Rx_Flag=1*/
256     if( g_CAN1_Rx_Message.StdId == RX_CAN_ID )
257     {
258         g_CAN1_Rx_Flag = 1;
259     }
260 }
```

Функция обработки вызова приёма сообщения app_can_rx_test в основном потоке выглядит следующим образом:

```c
187 /**********************************************************************
188 * Имя функции: void app_can_rx_test(void)
189 * Описание функции: Функция обработки приёма сообщения на уровне приложения CAN для обработки принятого сообщения в функции прерывания
190 * Входной параметр: нет
191 * Выходной параметр: нет
192 * Возвращаемое значение: нет
193 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
194 * -----------------------------------------------
195 * 2020/05/13         V1.0             bert            создано
196 ***********************************************************************/
197 void app_can_rx_test(void)
198 {
199     unsigned char i=0;
200
201     /* Определение отправляемого сообщения */
202     CanTxMsg TxMessage;
203
203     /* Счётчик в отправляемом сообщении */
204     static unsigned char rx_counter = 0;
205
206
207     if( g_CAN1_Rx_Flag == 1)
208     {
209         g_CAN1_Rx_Flag = 0;
210
211         /* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
212         TxMessage.StdId = RX_TO_TX_CAN_ID;	  /* Стандартный идентификатор 0x000~0x7FF */
213         TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
213         TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
214         TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных */
215         TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
216
217         /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
218         TxMessage.Data[0] = rx_counter++;      /* Счётчик отправки */
219         for(i=1; i<TxMessage.DLC; i++)
220         {
221             TxMessage.Data[i] = g_CAN1_Rx_Message.Data[i];
222         }
223
224         /*  Вызвать can_write отправить сообщение CAN */
225         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
226     }
227 }
```



**14.4.5.3** **Проверка и верификация тестового случая**

**(1) Написание Makfile**

Содержание файла Makefile выглядит следующим образом:

```c
all:

   arm-linux-gnueabihf-gcc -lpthread -o socketcan_recv_send  can_controller.c app_can.c

clean:

   rm socketcan_recv_send
```



**(2) Компиляция socket_recv_send**

 Примечание: компиляция выполняется в виртуальной машине 100ask-vmware_ubuntu18.04.

Войдите в каталог socket_send соответствующей виртуальной машины ubuntu и выполните make all для компиляции.

Процесс компиляции выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0029.png)

**(3) Запуск socket_recv_send**

Примечание: запуск на плате разработки 100ask_imx6.

Используется NFS файловая система для запуска.

Подключение NFS, смотрите описание "14.4,3.3 Проверка и верификация тестового случая".

В окружении платы разработки 100ask_imx6 выполнить "./socket_recv_send" запуск программы;

Затем через Vehicle Spy3 отправить на CAN порт платы разработки 100ask_imx6 сообщение ID 0x201, трассировка сообщения выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0030.png)

Затем наблюдайте информацию печати последовательного порта платы разработки 100ask_imx6 выглядит следующим образом:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0028.png)

**(4) Итоги теста**

До этого момента мы успешно отладили функцию приёма и отправки сообщений CAN.

## **14.5** **Применение CAN автобус в автомобильной промышленности**

### **14.5.1** **Требования автопроизводителя к CAN шине**

Применение CAN шины наиболее широко распространено в области автомобилей, почти все автомобили поддерживают CAN шину, здесь кратко описаны некоторые требования CAN шины, связанные с автомобилями.



#### **14.5.1.1** **Структура сетевой топологии**

На следующей диаграмме сетевой топологии и большинства реальных топологий развитых мной транспортных средств в целом совпадают. Обычно это предоставляется производителями автомобилей поставщикам компонентов.

Как показано на рисунке:

![14.5.1 Топология сети транспортного средства](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0032.png)


В целом, сеть автомобиля разбита на 6 локальных CAN сетей:

| Разделение топологии транспортного средства                                                 | Описание                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| PT CAN <br/>(PowerTrain CAN )   <br/>CAN шина силовой установки         | Главным образом отвечает за организацию ECU, связанных с мощностью транспортного средства, это сеть CAN с самой высокой требуемой скоростью передачи в целом транспортном средстве; <br>  обычно включает соответствующие модули ECU: <br/> ECM(Engine Control  Module) модуль управления двигателем; <br/> SRS (  SupplementalRestraintSystem) электронная подушка безопасности  <br/> BMS ( Battery Management System ) система управления батареей   <br/>EPB Electronic Park Brake, система электронного стояночного тормоза |
| CH CAN   <br/>(Chassis CAN)   <br/>CAN шина управления шасси           | CH CAN отвечает за управление шасси транспортного средства и 4 колёсами торможения/стабилизации/поворота, так как это связано с торможением транспортного средства/усилением рулевого управления и т.д., <br/>поэтому приоритет сигнала его сети также довольно высокий.  <br/>обычно включает соответствующие модули ECU:  <br/>ABS ( Antilock Brake  System ) система предотвращения блокировки колёс <br/> ESP(Electronic  Stability Program) система электронной стабильности кузова  <br/>EPS(Electric Power  Steering) усилитель электромагнитного рулевого управления |
| Body CAN  <br/>CAN шина управления кузовом                                  | Body CAN отвечает за управление и контроль некоторых интеллектуальных аппаратных устройств на корпусе транспортного средства для повышения комфорта/безопасности, приоритет сигнала его сети<br/>низкий, потому что указанные выше устройства являются вспомогательными устройствами.  <br/>обычно включает соответствующие модули ECU: <br/>AC ( Air Condition ) кондиционирование воздуха  <br/>AVM(Around View  Monitor) 360 панорамный вид  <br/>BCM(Body Control  Module) люк, окно, противотуманные фары, поворотники, дворники…  <br/>IMMO(Immobilizer) система защиты от кражи двигателя  <br/>TPMS(Tire Pressure  Monitoring System) система контроля давления в шинах |
| Info CAN  <br/><br/> ( Infomercial CAN )   <br/>CAN шина развлекательной системы | Info CAN это дополнительное устройство, поэтому приоритет также низкий, главным образом отвечает за управление и контроль некоторых интеллектуальных аппаратных устройств на корпусе транспортного средства для повышения развлекательности.  <br/>обычно включает соответствующие модули ECU:  <br/>VAES( Video Audio  Entertainment System) система развлечений в автомобиле (центральное управление)  <br/>IP(Instrument Pack) приборная панель, в настоящее время цифровая приборная панель в основном имеет музыку, карту, функции телефонии и развлечения. |
| DiagCAN   ( Diagnose CAN )   CAN шина диагностического управления                    | CAN шина DiagCAN главным образом обеспечивает функцию удалённой диагностики, есть только один ECU:  <br/> Tbox(Telematics BOX) модуль удалённого управления |
| OBD CAN                                                      | OBD обычно обеспечивает внешний диагностический инструмент, в основном подключён к ворот ECU общей сети транспортного средства.           |



#### **14.5.1.2 Классификация сообщений CAN**

В сети CAN транспортного средства сообщения CAN в основном разделены на три типа: сообщения приложения, сообщения управления сетью и диагностические сообщения.

Независимо от того, являются ли сообщения управления сетью или диагностические сообщения, они разделены в соответствии с различными потребностями функции, в соответствии с различными потребностями разработать различные протоколы данных сообщения CAN.



**(1) Сообщения приложения CAN**

Сообщения приложения CAN главным образом используются для отправки и приёма информации о данных между различными узлами ECU в сети автомобиля, связанные с конкретной функцией приложения;

Сообщения приложения CAN в автомобилях определены и опубликованы производителем "таблица матрицы сигналов (формат Excel)" и "матрица сигналов (формат DBC)".

Детальное описание см. "14.5.2 анализ и примеры применения сообщения приложения CAN".



**(2) Сообщения управления сетью CAN**

Процесс, при котором электронная система автомобиля через сеть автомобиля конфигурирует и координирует работу всех ECU, называется управлением сетью.

Управление сетью может управлять каждым ECU на сети, отправляя команды и правила, чтобы реализовать координированный сон и пробуждение каждого ECU, CAN сообщение, используемое для координационного контроля, это сообщение управления сетью.

Управление сетью имеет OSEK управление сетью и AUTOSAR управление сетью два типа. Обычно только проекты переднеустановленных автопроизводителей требуют поддержки управления сетью.



**(3) Диагностические сообщения CAN**

Диагностика CAN главным образом реализует контроль функциональности транспортного средства, обнаружение отказов, запись/хранение информации об ошибках, хранение/чтение данных, а также диагностику EOL при снятии с производства, обновление ECU и другие функции.



На основе коммуникационной модели слоистой CAN:

| Слой OSI    | Стандарт диагностики производителя            | Стандарт OBD    |
| ---------- | ----------------------- | ---------- |
| Диагностическое приложение   | Определено пользователем                | ISO15031-5 |
| Уровень приложения     | ISO15765-3 / ISO14229-1 | ISO15031-5 |
| Уровень представления     | нет                      | нет         |
| Уровень сеанса     | ISO15765-3              | ISO15765-4 |
| Транспортный уровень     | нет                      | нет         |
| Сетевой уровень     | ISO15765-2              | ISO15765-4 |
| Уровень канала передачи данных | ISO11898-1              | ISO15765-4 |
| Физический уровень    | Определено пользователем                | ISO15765-4 |

![Диагностическое сообщение CAN модель OSI](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0034.png)


### **14.5.2 Анализ применения сообщения приложения CAN и примеры**

#### **14.5.2.1 Определение сообщения приложения CAN**

После запуска проекта автопроизводителя, на основе требований проекта, производитель будет предоставлять матрицу сигналов CAN (Excel) и базу данных матрицы сигналов (DBC).

**(1) Матрица сигналов CAN - формат Excel**

Формат файла матрицы сигналов (Excel), предоставленный производителем, см. в каталоге кода главы 14: CAN_Signal_Matrix.xlsx,

Из CAN_Signal_Matrix.xlsx извлечены определения сообщений, как показано ниже:

ECU_TX_MSG1: (сообщение периодической отправки, ID: 0x123)

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0035.png)

ECU_TX_MSG2: (сообщение событийной отправки, ID: 0x124)

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0036.png)

ECU_TX_MSG3: (периодическое&событийное сообщение отправки, ID: 0x125)

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0037.png)

ECU_RX_MSG1:(сообщение приёма событий, ID: 0X201)

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0038.png)

Из определения приведённого выше сообщения видно, что производитель определит множество атрибутов сообщения, таких как имя сообщения, ID сообщения, длина сообщения, период сообщения, тип отправки сообщения, а также имя сигнала в сообщении, начальный байт сигнала, длина сигнала, формат расположения (Intel или Motorola), диапазон значений сигнала, способ отправки сигнала и т.д.

(2) Матрица сигналов CAN - DBC

Пример матрицы CAN "CAN_Signal_Matrix.xlsx", предоставленный в этой главе, соответствующий файл DBC редактируется с помощью vector CANdb+ Editor; как показано на рисунке ниже, информация о сообщении, отображаемая файлом DBC, согласуется с содержимым, отображаемым таблицей Excel, формат файла не является ключевым, важно понимать требования производителя к сигналам CAN.

![Матрица сигналов CAN DBC](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0039.png)



#### 14.5.2.2 Правила отправки сообщения приложения CAN

Ранее мы упомянули, что производитель будет предоставлять таблицу матрицы сигналов CAN и определять периодические сообщения, событийные сообщения, периодические и событийные смешанные сообщения, каковы универсальные правила определения этих сигналов? Обычно производитель предоставляет спецификацию CAN шины, производитель определяет матрицу сигналов CAN на основе спецификации связи.

Ниже приводится спецификация связи производителя "XXX Communication Requirement Specification.pdf", каталог спецификации показан на рисунке ниже, из каталога видно, что главным образом представлены физический уровень CAN, уровень канала передачи данных, уровень взаимодействия связи и другие связанные правила.

На этот раздел, мы главным образом представляем правила уровня взаимодействия приложения "4 Interaction Layer" связанные содержание: тип отправки сообщения CAN (Message Send Type).

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0040.png)

Типы отправки сообщений CAN вводятся поочередно в соответствии с ранее отображенной матрицей следующим образом:

**(1) Периодическое сообщение (Cyclic Message)**

Периодическое сообщение, то есть периодическая отправка с периодом T.

Как показано на рисунке:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0042.png)

Когда система работает, ECU отправляет сообщение CAN периодически с периодом T.

**(2) Событийное сообщение (Event Message)**

Отправить событийное сообщение при возникновении события триггера, как показано на рисунке:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0043.png)

Когда система работает, ECU не отправляет событийное сообщение инициативно, но когда ECU запускается определённое условие (Event), ECU будет непрерывно отправлять три кадра событийного сообщения.

Конечно, требования производителя не ограничены этим, производитель также будет иметь дополнительные требования,

Например,

Требование 1,: после отправки трёх кадров триггера требуется восстановление сигнала на значение по умолчанию;

Требование 2: после отправки трёх кадров, интервал между кадрами требуется 50 ms;

**(3) Периодическое и событийное сообщение (Cyclic And Event Message)**

Периодическое и событийное смешанное сообщение (сокращённо CE), когда не возникает событие триггера, отправляется периодически с периодом T, когда возникает событие триггера, сообщение отправляется способом события триггера.

Как показано на рисунке:

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0044.png)

Фактические типы отправки сообщений CAN, определённые производителем, не только три вышеприведённых, но эти три являются наиболее важными способами отправки.



#### 14.5.2.3 Пример применения отправки сообщения приложения CAN автомобиля

Посредством описания предыдущего раздела, мы уже понимали три типа отправки сообщений приложения, указанные в стандартах производителя, в настоящее время мы начинаем проводить эксперимент на плате разработки 100ask_imx6, реализовать требования сообщения приложения производителя.



На основе каркаса программирования приложения Linux socketcan, который мы уже рассмотрели в "14.4 базовое программирование приложения Linux socketcan", мы теперь будем основываться на "14.4.5 примере приёма и отправки socketcan", перейти к примеру приложения этой главы, сосредоточив внимание на программировании app_can.c, can_controller.c может быть полностью использован.



О программировании приложения Linux socketcan, мы используем матрицу сообщений CAN, представленную в 14.5.2.1.



**(1) Подготовка каркаса программирования Linux can**

Используйте код примера "04_socketcan_recv_send" скопируйте папку переименуйте на "06_socketcan_ecu_application".

В файле app_can.c определить ID сообщений:

```c
30 /**************Определения макросов**************************************************/
31 /* ID сообщения CAN для тестирования периодической отправки в этом примере */
32 #define TX_CAN_CYCLIC_ID    0X123
33 #define TX_CAN_EVENT_ID     0X124
34 #define TX_CAN_CE_ID        0X125

36 /* ID сообщения CAN для тестирования приёма в этом примере */
37 #define RX_CAN_ID           0x201
```

**(2) Реализация периодического сообщения**

Реализуемая функция:

A. Программно реализовать периодическую отправку сообщения ID: 0x123, период T составляет 1000ms.



Реализация кода выглядит следующим образом:

```c
136 /**********************************************************************
137 * Имя функции: void app_can_cyclicmsg_test(void)
138 * Описание функции: Тестирование функции отправки периодического сообщения (ID:0X123) на уровне приложения CAN
139 * Входной параметр: нет
140 * Выходной параметр: нет
141 * Возвращаемое значение: нет
142 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
143 * -----------------------------------------------
144 * 2020/05/13         V1.0             bert            создано
145 ***********************************************************************/
146 void app_can_cyclicmsg_test(void)
147 {
148     // На основе 10ms, запустить тестовую программу CAN
149
150     unsigned char i=0;
151
152     /* Определение отправляемого сообщения */
153     CanTxMsg TxMessage;
154
155     /* Счётчик в отправляемом сообщении */
156     static unsigned char tx_counter = 0;
157
158     /* На основе 10ms, используя счётчик timer установить период работки кода после этого места на 1 секунду*/
159     static unsigned int timer =0;
160     if(timer++>100)
161     {
162         timer = 0;
163     }
164     else
165     {
166         return ;
167     }
168
169     /* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
170     TxMessage.StdId = TX_CAN_CYCLIC_ID;	  /* Стандартный идентификатор 0x000~0x7FF */
171     TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
172     TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
173     TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных  */
174     TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
175
176     /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
177     TxMessage.Data[0] = tx_counter++;       /* Используется для идентификации счётчика отправляемого сообщения */
178     for(i=1; i<TxMessage.DLC; i++)
179     {
180         TxMessage.Data[i] = i;
181     }
182
183     /*  Вызвать can_write отправить сообщение CAN */
184     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
185
186 }
```

**(3) Реализация событийного сообщения**

Реализуемая функция:

A.   Программно реализовать при приёме одного кадра сообщения (ID: 0x201) сигнал ECU_RX_MSG1_signal1=1, запустить отправку событийного сообщения (ID:0x124), пусть ECU_MSG2_signal2 (байт 1)=2 и интервал между двумя кадрами составляет 50ms.

B.   Условие запуска события: получено сообщение (ID:0x201), и ECU_RX_MSG1_signal1 (байт 0 бит 0) составляет 1



Реализация кода выглядит следующим образом:

```c
188 /**********************************************************************
189 * Имя функции: void app_can_eventmsg_test(void)
190 * Описание функции: Тестирование функции отправки событийного сообщения (ID:0X124) на уровне приложения CAN
191 * Входной параметр: нет
192 * Выходной параметр: нет
193 * Возвращаемое значение: нет
194 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
195 * -----------------------------------------------
196 * 2020/05/13         V1.0             bert            создано
197 ***********************************************************************/
198 void app_can_eventmsg_test(void)
199 {
200     unsigned char i=0;

202     /* Счётчик события отправки в отправляемом сообщении */
203     static unsigned char tx_counter = 0;

205     /* Определение отправляемого сообщения */
206     CanTxMsg TxMessage;

208     if( g_CAN1_Rx_Event_Flag == 1 )
209     {
210 	g_CAN1_Rx_Event_Flag = 0;
211 	printf("Message:0x124 is Triggered!\n");

213         /* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
214         TxMessage.StdId = TX_CAN_EVENT_ID;	  /* Стандартный идентификатор 0x000~0x7FF */
215         TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
216         TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
217         TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных  */
218         TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
219
220         /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
221         for(i=0; i<TxMessage.DLC; i++)
222         {
223             TxMessage.Data[i] = 0x00;
224         }
225         /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
226 	tx_counter = 0;
227
228 	/*Обновить данные первого кадра*/
229 	TxMessage.Data[1] = 0x02;
230 	TxMessage.Data[7] = (++tx_counter);
231         /*  Вызвать can_write отправить сообщение CAN, первый кадр */
232         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
233 	/*Задержка 50ms, как интервал между событийными сообщениями*/
234 	usleep(50000);

236 	/*Обновить данные второго кадра*/
237 	TxMessage.Data[1] = 0x02;
238 	TxMessage.Data[7] = (++tx_counter);
239 	/*  Вызвать can_write отправить сообщение CAN, второй кадр */
240         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
241 	/*Задержка 50ms, как интервал между событийными сообщениями*/
242 	usleep(50000);

244 	/*Обновить данные третьего кадра*/
245 	TxMessage.Data[1] = 0x02;
246 	TxMessage.Data[7] = (++tx_counter);
247 	/*  Вызвать can_write отправить сообщение CAN, третий кадр */
248         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
249 	/*Задержка 50ms, как интервал между событийными сообщениями*/
250 	usleep(50000);
251     }
252 }
```

**(4) Реализация периодического и событийного сообщения**

Реализуемая функция:

A.   Программно реализовать периодическую отправку сообщения (ID: 0x125);

B.   Когда получено одно сообщение (ID: 0x201) сигнал ECU_RX_MSG1_signal2=1, запустить отправку периодического и событийного сообщения (ID:0x125), пусть ECU_MSG3_signal9 (байт 1 бит 0)=1, и непрерывно отправить три кадра, интервал между двумя кадрами составляет 50ms, после отправки трёх кадров восстановить ECU_MSG3_signal5=0;

A.   Условие запуска события: получено сообщение (ID:0x201), и ECU_RX_MSG1_signal2 (байт 0 бит 1) составляет 1



Реализация кода выглядит следующим образом:

```c
255 /**********************************************************************
256 * Имя функции: void app_can_cycliceventmsg_test(void)
257 * Описание функции: Тестирование функции отправки периодического и событийного смешанного сообщения (ID:0X125) на уровне приложения CAN
258 * Входной параметр: нет
259 * Выходной параметр: нет
260 * Возвращаемое значение: нет
261 * Дата изменения, номер версии, человек, который редактировал, содержание отредактирования
262 * -----------------------------------------------
263 * 2020/05/13         V1.0             bert            создано
264 ***********************************************************************/
265 void app_can_cycliceventmsg_test(void)
266 {
267     unsigned char i=0;
268
269     /* Определение отправляемого сообщения */
270     CanTxMsg TxMessage;
271
272     /* Счётчик события отправки в отправляемом сообщении */
273     static unsigned char tx_counter = 0;

275     /* На основе 10ms, используя счётчик timer установить период работки кода после этого места на 1 секунду*/
276     static unsigned int timer =0;

278     if( g_CAN1_Rx_CE_Flag == 1)
279     {
280 	g_CAN1_Rx_CE_Flag = 0;
281 	printf("Message:0x125 is Triggered!\n");

283 	/* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
284         TxMessage.StdId = TX_CAN_CE_ID;	     /* Стандартный идентификатор 0x000~0x7FF */
285         TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
286         TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
287         TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных  */
288         TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
289
290         /* Очистка данных */
291         for(i=0; i<TxMessage.DLC; i++)
292         {
293             TxMessage.Data[i] = 0x00;
294         }
295 	/* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
296 	tx_counter = 0;

298         /*Обновить данные первого кадра*/
299 	TxMessage.Data[1] = 0x01;
300 	TxMessage.Data[7] = (++tx_counter);
301         /*  Вызвать can_write отправить сообщение CAN, первый кадр */
302         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
303 	/*Задержка 50ms, как интервал между событийными сообщениями*/
304 	usleep(50000);

306 	/*Обновить данные второго кадра*/
307 	TxMessage.Data[1] = 0x01;
308 	TxMessage.Data[7] = (++tx_counter);
309 	/*  Вызвать can_write отправить сообщение CAN, второй кадр */
310         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
311 	/*Задержка 50ms, как интервал между событийными сообщениями*/
312 	usleep(50000);

314 	/*Обновить данные третьего кадра*/
315 	TxMessage.Data[1] = 0x01;
316 	TxMessage.Data[7] = (++tx_counter);
317 	/*  Вызвать can_write отправить сообщение CAN, третий кадр */
318         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
319 	/*Задержка 50ms, как интервал между событийными сообщениями*/
320 	usleep(50000);
321     }

323     /* На основе 10ms, используя счётчик timer установить период работки кода после этого места на 1 секунду*/
324     if(timer++>100)
325     {
326         timer = 0;
327     }
328     else
329     {
330         return ;
331     }

333     /* Заполнение данных отправляемого сообщения, период этого сообщения 1 секунда */
334     TxMessage.StdId = TX_CAN_CE_ID;	  /* Стандартный идентификатор 0x000~0x7FF */
335     TxMessage.ExtId = 0x0000;             /* Расширенный идентификатор 0x0000 */
336     TxMessage.IDE   = CAN_ID_STD;         /* Использовать стандартный идентификатор */
337     TxMessage.RTR   = CAN_RTR_DATA;       /* Установить как кадр данных  */
338     TxMessage.DLC   = 8;                  /* Длина данных, максимальная длина данных по стандарту CAN сообщения 8 байт */
339
340     /* Заполнение данных, могут быть заполнены в соответствии с фактическим применением */
341     for(i=1; i<TxMessage.DLC; i++)
342     {
343 	TxMessage.Data[i] = 0x00;
344     }
345
346     /*  Вызвать can_write отправить сообщение CAN */
347     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
348 }
```

**(4) Тестирование случая**



**Первый шаг: тестирование периодического сообщения**

Запустить socket_ecu_test, информация печати последовательного порта выглядит следующим образом:
![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0031.png)

Затем наблюдайте трассировку сообщения, полученную программным обеспечением Vehicle Spy3, как показано ниже:
Сообщение ID: 0x123, 0x125 два сообщения отправляются периодически с периодом 1000ms;

![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0046.png)

**Второй шаг: тестирование событийного сообщения**
На программном обеспечении Vehicle Spy3 в Messages фильтруйте сообщения ID: 0X201, 0X124.
Затем вручную нажмите на сообщение ID: 0X201 на Tx Panel с правой стороны, запись в левом Messages на 100ask_imx6 отправляет 3 кадра сообщения ID: 0x124.
Через печать последовательного порта платы разработки видно: "Message:0x124 is Triggered!", после этой строки печати находятся три кадра сообщения ID: 0x124.
![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0047.png)
Наблюдаемая трассировка Messages с левой стороны выглядит следующим образом:
![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0048.png)
**Третий шаг: тестирование периодического и событийного сообщения**
На программном обеспечении Vehicle Spy3 в Messages фильтруйте сообщения ID: 0X201, 0X125.
Затем вручную нажмите на сообщение ID: 0X201 на Tx Panel с правой стороны, запись в левом Messages на 100ask_imx6 отправляет 3 кадра сообщения ID: 0x125, но данные сообщения отличаются от данных по умолчанию, содержимое данных Byte7 соответственно 0x01, 0x02, 0x03.
Через печать последовательного порта платы разработки видно: "Message:0x125 is Triggered!", после этой строки печати находятся три кадра сообщения ID: 0x124.
![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0049.png)
Наблюдаемая трассировка Messages с левой стороны выглядит следующим образом:
ID: 0X125 в нормальном состоянии отправляет сообщение по умолчанию с периодом 1000ms, когда сообщение ID: 201 запускает событие, это вызывает ID: 0X125 отправляет событийное сообщение.
**(5) Улучшение отправки событийного сообщения**
Посредством вышеприведённых шагов мы уже понимали типы отправки сообщения приложения и способ реализации различных типов отправки, но при этом обработка события имеет одно недостаток, то есть при запуске события отправка реализуется посредством функции ucsleep(), это задержка вызовет период периодического сообщения удлиниться, это можно обнаружить путём наблюдения трассировки сообщения CAN.
Здесь к примеру "06_socketcan_ecu_application" сделано небольшое улучшение, обработка запущенного события использует циклический счёт для реализации, конкретно смотрите код примера "07_socketcan_ecu_application_new".
![](http://photos.100ask.net/NewHomeSite/LinuxCan_Image0050.png)
