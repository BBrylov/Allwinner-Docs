# 7 Программирование камеры V4L2

## 7.1 Введение в V4L2

Video for Linux two (Video4Linux2), сокращенно V4L2, это улучшенная версия V4L. V4L2 - это набор универсальных API-интерфейсов для захвата изображений, видео и аудиоданных в операционной системе Linux. В сочетании с соответствующими устройствами захвата видео и драйверами можно реализовать захват изображений, видео и аудио. V4L2, как отличный курьер, безопасно и эффективно доставляет данные изображений с устройств видеозахвата различным пользователям с разными потребностями.

В Linux всё является файлом, все периферийные устройства рассматриваются как особый тип файлов, называемых "файлами устройств". Видеоустройства не исключение и могут рассматриваться как файлы устройств, к которым можно обращаться как к обычным файлам для чтения и записи. Файл устройства камеры с драйвером V4L2 обычно /dev/videoX (где X - любая цифра, соответствующая вашему устройству).

V4L2 поддерживает три способа захвата изображений: способ отображения памяти (mmap), способ прямого чтения (read) и пользовательский указатель. Способ отображения памяти обеспечивает более высокую скорость захвата и обычно используется для захвата непрерывных видеоданных, имеет более высокую вероятность применения в реальной работе; способ прямого чтения относительно медленнее, поэтому часто используется для захвата статических изображений; пользовательский указатель используется реже, при желании можно изучить самостоятельно. Поскольку способ отображения памяти применяется шире, в этой статье основное внимание уделяется видеозахвату с использованием отображения памяти.

## 7.2 Принцип захвата видео V4L2

Перед захватом изображений через V4L2 нужно многое сделать, но очень важный шаг - выделение буферов кадров и отображение выделенных буферов кадров из пространства ядра в пользовательское пространство, затем постановка полученных буферов кадров в очередь входа видеозахвата, остальное - ожидание поступления видеоданных. Но что происходит, когда видеоданные действительно поступают? Этот процесс потока данных нужно понимать.

После запуска видеозахвата драйвер начинает захватывать данные одного кадра изображения и помещает захваченные данные изображения в первый буфер кадров во входной очереди видеозахвата - один кадр изображения захвачен. Когда первый буфер кадров заполнен данными одного кадра изображения, драйвер перемещает этот буфер кадров в выходную очередь видеозахвата, ожидая извлечения приложением. Приложение извлекает данные изображения из выходной очереди, может обрабатывать или сохранять данные изображения, затем помещает этот буфер кадров в конец входной очереди видеозахвата. Драйвер продолжает захват следующего кадра данных, помещая их во второй буфер. Аналогично, когда буфер кадров заполнен данными одного кадра, драйвер перемещает этот буфер в выходную очередь видеозахвата. Приложение извлекает данные изображения этого буфера кадров, затем снова помещает этот буфер кадров в конец входной очереди видеозахвата. Таким образом, циклически реализуется непрерывный захват. Процесс показан на рисунке ниже:

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image1.png)

Для лучшего понимания этого процесса можем провести аналогию: "обработку данных приложением" сравним с "переработкой арбузов переработчиком арбузов", "захват данных драйвером V4L2" сравним с "сбором арбузов сборщиком арбузов". Заранее "переработчик арбузов" подготовит несколько пустых корзин для "сборщика арбузов", затем "сборщик арбузов" ждет у нескольких пустых корзин, пока "фермер" (устройство захвата изображений, например камера) заполнит пустые корзины. Когда "пустая корзина 1" заполнена "фермером", "сборщик арбузов" помещает корзину, полную арбузов, в "очередь переработки арбузов", ожидая, пока "переработчик арбузов" заберет ее для переработки. Когда "переработчик арбузов" забирает арбузы из полной корзины, он возвращает пустую корзину в конец очереди сбора арбузов, заранее подготовленной для "сборщика арбузов". Когда "фермер" заполняет следующую пустую корзину, "сборщик арбузов" аналогично помещает полную корзину арбузов в "очередь переработки арбузов", ожидая, пока "переработчик арбузов" заберет ее для переработки. Таким образом весь процесс будет продолжаться непрерывно.

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image2.png)

## 7.3 Поток реализации программы V4L2

Использование V4L2 для видеозахвата обычно делится на 5 шагов:

(1) Открыть устройство, выполнить настройку параметров инициализации, через интерфейс V4L2 установить окно захвата видеоизображений, размер точки захвата и формат;

(2) Запросить буферы кадров изображений и выполнить отображение памяти, отобразить эти буферы кадров из пространства ядра в пользовательское пространство для удобства чтения и обработки данных изображений приложением;

(3) Поставить буферы кадров в очередь, запустить видеозахват;

(4) Драйвер начинает захват видеоданных, приложение извлекает буфер кадров из выходной очереди видеозахвата, после обработки снова помещает буфер кадров в входную очередь видеозахвата, циклически захватывая непрерывные видеоданные;

(5) Освободить ресурсы, остановить захват.

В процессе разработки V4L2 часто используемые идентификаторы команд:

(1) VIDIOC_REQBUFS: выделение памяти;

(2) VIDIOC_QUERYBUF: преобразование кэша данных, выделенного в VIDIOC_REQBUFS, в физический адрес;

(3) VIDIOC_QUERYCAP: запрос функций драйвера;

(4) VIDIOC_ENUM_FMT: получение видеоформатов, поддерживаемых текущим драйвером;

(5) VIDIOC_S_FMT: установка формата видеозахвата текущего драйвера;

(6) VIDIOC_G_FMT: чтение формата видеозахвата текущего драйвера;

(7) VIDIOC_TRY_FMT: проверка формата отображения текущего драйвера;

(8) VIDIOC_CROPCAP: запрос функции обрезки драйвера;

(9) VIDIOC_S_CROP: установка рамки видеосигнала;

(10) VIDIOC_G_CROP: чтение рамки видеосигнала;

(11) VIDIOC_QBUF: чтение данных из кэша;

(12) VIDIOC_DQBUF: возврат данных в очередь кэша;

(13) VIDIOC_STREAMOP: запуск функции отображения видео;

(14) VIDIOC_STREAMOFF: завершение функции отображения видео;

(15) VIDIOC_QUERYSTD: проверка стандартов, поддерживаемых текущим видеоустройством, например PAL или NTSC;

Некоторые из этих вызовов IO обязательны, некоторые необязательны.

Конкретный поток показан на рисунке ниже:

![](http://photos.100ask.net/NewHomeSite/Video_V4L2_image3.png)

## 7.4 Пример программы V4L2

Код V4L2 в основном находится в файле video2lcd/video/v4l2.c. Далее в сочетании с потоком реализации программы V4L2, описанным выше, и важными структурами данных, используемыми в потоке, объясним код в файле v4l2.c. Код поддерживает два способа: отображение памяти и прямое чтение. Поскольку способ отображения памяти применяется шире, в этой статье подробно описан только способ отображения памяти, способ прямого чтения аналогичен способу отображения памяти, можно изучить самостоятельно.

### 7.4.1 Открытие устройства

Приложение может открыть видеоустройство в блокирующем или неблокирующем режиме. При использовании неблокирующего режима вызова видеоустройства, даже если информация еще не захвачена, драйвер все равно возвращает приложению содержимое буфера (DQBUFF). Если открыть устройство камеры в неблокирующем режиме, второй параметр функции open в строке 2 кода нужно изменить на O_RDWR | O_NONBLOCK.

```c
70     iFd = open(strDevName, O_RDWR);
71     if (iFd < 0)
72     {
73         DBG_PRINTF("can not open %s\n", strDevName);
74         return -1;
75     }
```

### 7.4.2 Запрос атрибутов устройства

Для запроса атрибутов устройства нужно использовать структуру struct v4l2_capability, которая описывает информацию о драйвере устройства видеозахвата.

```c
01 struct v4l2_capability
02 {
03     __u8 driver[16];       // Имя драйвера
04     __u8 card[32];         // Имя устройства
05     __u8 bus_info[32];     // Местоположение устройства в системе
06     __u32 version;         // Версия драйвера
07     __u32 capabilities;    // Операции, поддерживаемые устройством
08     __u32 reserved[4];     // Зарезервированные поля
09 };
```

Команда VIDIOC_QUERYCAP используется для проверки соответствия драйвера стандартам. Поскольку V4L2 требует, чтобы все драйверы и устройства поддерживали этот ioctl, успешность команды VIDIOC_QUERYCAP определяет, соответствуют ли текущее устройство и драйвер спецификации V4L2. При успешном выполнении этой команды также получается достаточная информация об устройстве, как показано в структуре struct v4l2_capability. Строки 86-98 кода проверяют, является ли текущее устройство устройством захвата, и проверяют, используется ли отображение памяти или прямое чтение для получения данных изображения.

```c
78     iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);
79     memset(&tV4l2Cap, 0, sizeof(struct v4l2_capability));
80     iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);
81     if (iError) {
82      DBG_PRINTF("Error opening device %s: unable to query device.\n", strDevName);
83      goto err_exit;
84     }
85
86     if (!(tV4l2Cap.capabilities & V4L2_CAP_VIDEO_CAPTURE))
87     {
88      DBG_PRINTF("%s is not a video capture device\n", strDevName);
89         goto err_exit;
90     }
91
92      if (tV4l2Cap.capabilities & V4L2_CAP_STREAMING) {
93          DBG_PRINTF("%s supports streaming i/o\n", strDevName);
94      }
95
96      if (tV4l2Cap.capabilities & V4L2_CAP_READWRITE) {
97          DBG_PRINTF("%s supports read i/o\n", strDevName);
98      }
```

### 7.4.3 Отображение всех поддерживаемых форматов

Для отображения всех поддерживаемых форматов нужна структура struct v4l2_fmtdesc, которая описывает информацию о форматах, поддерживаемых текущей камерой.

```c
01 struct v4l2_fmtdesc
02 {
03     __u32 index;               // Порядковый номер формата для запроса, устанавливается приложением
04     enum v4l2_buf_type type;   // Тип кадра, устанавливается приложением
05     __u32 flags;               // Является ли форматом сжатия
06     __u8 description[32];      // Имя формата
07     __u32 pixelformat;         // Поддерживаемый формат
08     __u32 reserved[4];         // Зарезервировано
09 };
```

Команда VIDIOC_ENUM_FMT используется для запроса всех форматов, поддерживаемых текущей камерой. В структуре struct v4l2_fmtdesc нужно установить index, начиная с 0; enum v4l2_buf_type type также нужно установить. Если используется устройство камеры, enum v4l2_buf_type type нужно установить в V4L2_BUF_TYPE_VIDEO_CAPTURE, потому что камера - это устройство CAPTURE. Остальное содержимое структуры заполняется драйвером. Параметр __u32 pixelformat нужен при установке формата кадра изображения.

```c
100     memset(&tFmtDesc, 0, sizeof(tFmtDesc));
101     tFmtDesc.index = 0;
102     tFmtDesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
103     while ((iError = ioctl(iFd, VIDIOC_ENUM_FMT, &tFmtDesc)) == 0) {
104         if (isSupportThisFormat(tFmtDesc.pixelformat))
105         {
106             ptVideoDevice->iPixelFormat = tFmtDesc.pixelformat;
107             break;
108         }
109             tFmtDesc.index++;
110     }
```

### 7.4.4 Установка формата кадра изображения

Для установки формата изображения нужна структура struct v4l2_format, которая описывает конкретный формат каждого кадра изображения, включая тип кадра и длину, ширину изображения и другую информацию.

```c
01 struct v4l2_format
02 {
03     enum v4l2_buf_type type;          // Тип кадра, устанавливается приложением
04     union fmt
05     {
06         struct v4l2_pix_format pix;   // Используется видеоустройством
07         struct v4l2_window win;
08         struct v4l2_vbi_format vbi;
09         struct v4l2_sliced_vbi_format sliced;
10         __u8 raw_data[200];
11     };
12 };
```

В структуре struct v4l2_format нужно установить enum v4l2_buf_type type и struct v4l2_pix_format pix в объединении union fmt. Enum v4l2_buf_type type, поскольку используется устройство камеры, а камера - это устройство CAPTURE, устанавливается в V4L2_BUF_TYPE_VIDEO_CAPTURE. Struct v4l2_pix_format pix устанавливает длину, ширину, формат и другие параметры одного кадра изображения. Для адаптации вывода на LCD длина и ширина устанавливаются в значения, поддерживаемые LCD, как показано в строках 124-125.

```c
119     /* set format in */
120     GetDispResolution(&iLcdWidth, &iLcdHeigt, &iLcdBpp);
121     memset(&tV4l2Fmt, 0, sizeof(struct v4l2_format));
122     tV4l2Fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
123     tV4l2Fmt.fmt.pix.pixelformat = ptVideoDevice->iPixelFormat;
124     tV4l2Fmt.fmt.pix.width       = iLcdWidth;
125     tV4l2Fmt.fmt.pix.height      = iLcdHeigt;
126     tV4l2Fmt.fmt.pix.field       = V4L2_FIELD_ANY;
127
128     /* Если драйвер обнаруживает невозможность некоторых параметров (например, разрешения),
129      * он корректирует эти параметры и возвращает их приложению
130      */
131     iError = ioctl(iFd, VIDIOC_S_FMT, &tV4l2Fmt);
132     if (iError)
133     {
134             DBG_PRINTF("Unable to set format\n");
135         goto err_exit;
136     }
```

### 7.4.5 Запрос буферов

Соответствующая структура описывает основную информацию о запрашиваемых буферах.

```c
01 struct v4l2_requestbuffers
02 {
03     __u32 count;                    // Количество буферных кадров в буферной области
04     enum v4l2_buf_type type;        // Формат данных буферных кадров
05     enum v4l2_memory memory;        // Различие между отображением памяти и способом пользовательского указателя
06     __u32 reserved[2];
07 };
```

Запросить буферную область с четырьмя буферными кадрами. __u32 count - количество буферных кадров; enum v4l2_buf_type type, как и ранее, устанавливается в V4L2_BUF_TYPE_VIDEO_CAPTURE; enum v4l2_memory memory используется для различения отображения памяти или пользовательского указателя. Мы используем способ отображения памяти, поэтому устанавливаем в V4L2_MEMORY_MMAP.

```c
140     /* request buffers */
141     memset(&tV4l2ReqBuffs, 0, sizeof(struct v4l2_requestbuffers));
142     tV4l2ReqBuffs.count = NB_BUFFER;
143     tV4l2ReqBuffs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
144     tV4l2ReqBuffs.memory = V4L2_MEMORY_MMAP;
145
146     iError = ioctl(iFd, VIDIOC_REQBUFS, &tV4l2ReqBuffs);
147     if (iError)
148     {
149             DBG_PRINTF("Unable to allocate buffers.\n");
150         goto err_exit;
151     }
```

### 7.4.6 Отображение запрошенных буферных кадров из пространства ядра в пользовательское пространство

Соответствующая структура представляет основную информацию о данных одного кадра изображения, включая порядковый номер, длину буферного кадра, адрес буферного кадра и другую информацию.

```c
01 struct v4l2_buffer
02 {
03     __u32 index;                    // Порядковый номер buffer
04     enum v4l2_buf_type type;        // Тип buffer
05     __u32 byteused;                 // Количество использованных байтов в buffer
06     __u32 flags;                    // Различие между MMAP и USERPTR
07     enum v4l2_field field;
08     struct timeval timestamp;       // Системное время при получении первого байта
09     struct v4l2_timecode timecode;
10     __u32 sequence;                 // Порядковый номер в очереди
11     enum v4l2_memory memory;        // Способ IO, устанавливается приложением
12     union m
13     {
14         __u32 offset;               // Адрес буферного кадра, действителен только для MMAP
15         unsigned long userptr;
16     };
17     __u32 length;                   // Длина буферного кадра
18     __u32 input;
19     __u32 reserved;
20 };
```

Для отображения буферов кадров из пространства ядра в пользовательское пространство нужны два данных для приема длины и адреса буфера кадров. Нужно определить собственную структуру. Эта структура находится в файле video2lcd/include/video_manager.h, где iVideoBufMaxLen принимает длину буфера кадров, pucVideBuf принимает адрес буфера кадров.

```c
16 struct VideoDevice {
17     int iFd;
18     int iPixelFormat;
19     int iWidth;
20     int iHeight;
21
22     int iVideoBufCnt;
23     int iVideoBufMaxLen;
24     int iVideoBufCurIndex;
25     unsigned char *pucVideBuf[NB_BUFFER];
26
27     /* Функции */
28     PT_VideoOpr ptOPr;
29 };
```

Следующий код использует команду VIDIOC_QUERYBUF и функцию mmap для отображения буферной области пространства ядра в пользовательское пространство. Использование команды VIDIOC_QUERYBUF требует параметра структуры struct v4l2_buffer, в структуре нужно установить параметры type, memory и index. Параметры type и memory устанавливаются так же, как и ранее, соответственно V4L2_BUF_TYPE_VIDEO_CAPTURE и V4L2_MEMORY_MMAP. Параметр index представляет номер запрошенного буферного кадра, начиная с 0, включая все запрошенные буферные кадры.

Прототип функции mmap:

```c
01 void *mmap(void*addr, size_t length, int prot, int flags, int fd, off_t offset);
```

Конкретное значение параметров:

1. addr: адрес начала отображения, обычно NULL, пусть ядро выбирает автоматически;

2. length: длина отображаемого блока памяти;

3. prot: флаг возможности чтения/записи после отображения, значение PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE;

4. flags: определяет, может ли это отображение памяти быть разделено другими процессами, может быть установлено в MAP_SHARED или MAP_PRIVATE;

5. fd: дескриптор файла устройства;

6. offset: определяет адрес памяти после отображения

```c
156         /* map the buffers */
157         for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
158         {
159             memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
160             tV4l2Buf.index = i;
161             tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
162             tV4l2Buf.memory = V4L2_MEMORY_MMAP;
163             iError = ioctl(iFd, VIDIOC_QUERYBUF, &tV4l2Buf);
164             if (iError)
165             {
166                 DBG_PRINTF("Unable to query buffer.\n");
167                 goto err_exit;
168             }
169
170             ptVideoDevice->iVideoBufMaxLen = tV4l2Buf.length;
171             ptVideoDevice->pucVideBuf[i] = mmap(0 /* start anywhere */ ,
172                               tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,
173                               tV4l2Buf.m.offset);
174             if (ptVideoDevice->pucVideBuf[i] == MAP_FAILED)
175             {
176                 DBG_PRINTF("Unable to map buffer\n");
177                 goto err_exit;
178             }
179         }
```

### 7.4.7 Постановка запрошенных буферных кадров в очередь и запуск потока данных

Код строк 184-194 использует команду VIDIOC_QBUF для последовательной постановки запрошенных буферных кадров во входную очередь буферных кадров, ожидая заполнения устройством захвата изображений;

```c
181         /* Queue the buffers. */
182         for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
183         {
184             memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
185             tV4l2Buf.index = i;
186             tV4l2Buf.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
187             tV4l2Buf.memory = V4L2_MEMORY_MMAP;
188             iError = ioctl(iFd, VIDIOC_QBUF, &tV4l2Buf);
189             if (iError)
190             {
191                 DBG_PRINTF("Unable to queue buffer.\n");
192                 goto err_exit;
193             }
194         }
```

### 7.4.8 Запуск захвата данных изображения

Запуск захвата данных изображения использует команду VIDIOC_STREAMON. После успешного выполнения этой команды можно ожидать поступления данных изображения.

```c
356 /**********************************************************************
357 * Имя функции: V4l2StartDevice
358 * Описание функции: начать захват данных изображения
359 * Входные параметры: ptVideoDevice
360 * Выходные параметры: нет
361 * Возвращаемое значение: нет
362 * Дата изменения             Версия        Автор           Содержание изменения
363 * -----------------------------------------------
364 * 2020/02/16         V1.0     zhenhua             Создано
365 ***********************************************************************/
366 static int V4l2StartDevice(PT_VideoDevice ptVideoDevice)
367 {
368     int iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
369     int iError;
370
371     iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMON, &iType);
372     if (iError)
373     {
374             DBG_PRINTF("Unable to start capture.\n");
375             return -1;
376     }
377     return 0;
378 }
```

### 7.4.9 Извлечение захваченного буфера кадров, обработка данных изображения, затем возврат кадра данных в очередь

Можно использовать команду VIDIOC_DQBUF для ожидания поступления буферного кадра. Когда буферный кадр помещается в выходную очередь видео, можно захватить один кадр изображения. После получения изображения можно выполнять операции с изображением, например сохранение, сжатие или вывод на LCD.

```c
243 /**********************************************************************
244 * Имя функции: V4l2GetFrameForStreaming
245 * Описание функции: получить данные одного кадра изображения из потока данных изображения
246 * Входные параметры: ptVideoDevice
247             ptVideoBuf
248 * Выходные параметры: нет
249 * Возвращаемое значение: нет
250 * Дата изменения             Версия        Автор           Содержание изменения
251 * -----------------------------------------------
252 * 2020/02/16         V1.0     zhenhua             Создано
253 ***********************************************************************/
254 static int V4l2GetFrameForStreaming(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)
255 {
256     struct pollfd tFds[1];
257     int iRet;
258     struct v4l2_buffer tV4l2Buf;
259
260     /* poll */
261     tFds[0].fd     = ptVideoDevice->iFd;
262     tFds[0].events = POLLIN;
263
264     iRet = poll(tFds, 1, -1);
265     if (iRet <= 0)
266     {
267         DBG_PRINTF("poll error!\n");
268         return -1;
269     }
270
271     /* VIDIOC_DQBUF */
272     memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
273     tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
274     tV4l2Buf.memory = V4L2_MEMORY_MMAP;
275     iRet = ioctl(ptVideoDevice->iFd, VIDIOC_DQBUF, &tV4l2Buf);
276     if (iRet < 0)
277     {
278             DBG_PRINTF("Unable to dequeue buffer.\n");
279             return -1;
280     }
281     ptVideoDevice->iVideoBufCurIndex = tV4l2Buf.index;
282
283     ptVideoBuf->iPixelFormat        = ptVideoDevice->iPixelFormat;
284     ptVideoBuf->tPixelDatas.iWidth  = ptVideoDevice->iWidth;
285     ptVideoBuf->tPixelDatas.iHeight = ptVideoDevice->iHeight;
286     ptVideoBuf->tPixelDatas.iBpp    = (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_YUYV) ? 16 : \
287                                         (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_MJPEG) ? 0 :  \
288                                         (ptVideoDevice->iPixelFormat == V4L2_PIX_FMT_RGB565) ? 16 :  \
289                                         0;
290     ptVideoBuf->tPixelDatas.iLineBytes    = ptVideoDevice->iWidth * ptVideoBuf->tPixelDatas.iBpp / 8;
291     ptVideoBuf->tPixelDatas.iTotalBytes   = tV4l2Buf.bytesused;
292     ptVideoBuf->tPixelDatas.aucPixelDatas = ptVideoDevice->pucVideBuf[tV4l2Buf.index];
293     return 0;
294 }
```

Когда мы извлекаем буферный кадр из выходной очереди буферных кадров и берем данные изображения, нужно вернуть буферный кадр обратно во входную очередь видео. Эта операция также использует команду VIDIOC_QBUF. После возврата в входную очередь буферных кадров продолжается ожидание заполнения.

```c
296 /**********************************************************************
297 * Имя функции: V4l2PutFrameForStreaming
298 * Описание функции: вернуть извлеченный буфер кадров обратно во входную очередь изображений
299 * Входные параметры: ptVideoDevice
300             ptVideoBuf
301 * Выходные параметры: нет
302 * Возвращаемое значение: нет
303 * Дата изменения             Версия        Автор           Содержание изменения
304 * -----------------------------------------------
305 * 2020/02/16         V1.0     zhenhua             Создано
306 ***********************************************************************/
307 static int V4l2PutFrameForStreaming(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)
308 {
309     /* VIDIOC_QBUF */
310     struct v4l2_buffer tV4l2Buf;
311     int iError;
312
313     memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
314     tV4l2Buf.index  = ptVideoDevice->iVideoBufCurIndex;
315     tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
316     tV4l2Buf.memory = V4L2_MEMORY_MMAP;
317     iError = ioctl(ptVideoDevice->iFd, VIDIOC_QBUF, &tV4l2Buf);
318     if (iError)
319     {
320         DBG_PRINTF("Unable to queue buffer.\n");
321         return -1;
322     }
323     return 0;
324 }
```

### 7.4.10 Остановка захвата данных изображения

Остановка захвата данных изображения: сначала использовать команду VIDIOC_STREAMOFF для закрытия захвата данных изображения. Также нужно обратить внимание на отмену отображения памяти и закрытие дескриптора для предотвращения утечки памяти. Код строк 390-407 для остановки захвата данных изображения; код строк 227-241 для отмены отображения памяти и закрытия дескриптора.

```c
380 /**********************************************************************
381 * Имя функции: V4l2StopDevice
382 * Описание функции: остановить захват данных изображения
383 * Входные параметры: ptVideoDevice
384 * Выходные параметры: нет
385 * Возвращаемое значение: нет
386 * Дата изменения             Версия        Автор           Содержание изменения
387 * -----------------------------------------------
388 * 2020/02/16         V1.0     zhenhua             Создано
389 ***********************************************************************/
390 static int V4l2StopDevice(PT_VideoDevice ptVideoDevice)
391 {
392     int iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
393     int iError;
394
395     iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMOFF, &iType);
396     if (iError)
397     {
398             DBG_PRINTF("Unable to stop capture.\n");
399             return -1;
400     }
401     return 0;
402 }
403
404 static int V4l2GetFormat(PT_VideoDevice ptVideoDevice)
405 {
406     return ptVideoDevice->iPixelFormat;
407 }
408
409
410 217 /**********************************************************************
218 * Имя функции: V4l2ExitDevice
219 * Описание функции: выйти из устройства захвата, отменить отображение буфера кадров и закрыть дескриптор
220 * Входные параметры: ptVideoDevice
221 * Выходные параметры: нет
222 * Возвращаемое значение: нет
223 * Дата изменения             Версия        Автор           Содержание изменения
224 * -----------------------------------------------
225 * 2020/02/16         V1.0     zhenhua             Создано
226 ***********************************************************************/
227 static int V4l2ExitDevice(PT_VideoDevice ptVideoDevice)
228 {
229     int i;
230     for (i = 0; i < ptVideoDevice->iVideoBufCnt; i++)
231     {
232         if (ptVideoDevice->pucVideBuf[i])
233         {
234             munmap(ptVideoDevice->pucVideBuf[i], ptVideoDevice->iVideoBufMaxLen);
235             ptVideoDevice->pucVideBuf[i] = NULL;
236         }
237     }
238
239     close(ptVideoDevice->iFd);
240     return 0;
241 }
```
